# Generated by SnakeBridge v0.10.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2

defmodule Dspy do
  @moduledoc """
  SnakeBridge bindings for `dspy`.

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Elixir.Dspy.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call
  - `:pool_name` - Target a specific Snakepit pool (multi-pool setups)
  - `:affinity` - Override session affinity (`:hint`, `:strict_queue`, `:strict_fail_fast`)

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Elixir.Dspy.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Elixir.Dspy.predict(data, __runtime__: [timeout: 600_000])

      # Route to a pool and enforce strict affinity
      Elixir.Dspy.predict(data, __runtime__: [pool_name: :strict_pool, affinity: :strict_queue])

  See `SnakeBridge.Defaults` for global timeout configuration.
  """

  def __snakebridge_python_name__, do: "dspy"
  def __snakebridge_library__, do: "dspy"

  @doc """
  Wraps a DSPy program so that it can be called asynchronously. This is useful for running a

  program in parallel with another task (e.g., another DSPy program).

  This implementation propagates the current thread's configuration context to the worker thread.

  ## Parameters

  - `program` - The DSPy program to be wrapped for asynchronous execution.

  Parameters:
  - `program` (term())

  Returns:
  - `term()`
  """
  @spec asyncify(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def asyncify(program, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :asyncify, [program], opts)
  end

  @doc """

  """
  @spec bootstrap_trace_data(Dspy.Primitives.Module.Module.t(), list(Dspy.Primitives.Example.t())) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          keyword()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          keyword()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term(),
          keyword()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term(),
          term()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term(),
          term(),
          keyword()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term(),
          term(),
          term()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term(),
          term(),
          term(),
          keyword()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term(),
          term(),
          term(),
          float()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term(),
          term(),
          term(),
          float(),
          keyword()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term(),
          term(),
          term(),
          float(),
          float()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term(),
          term(),
          term(),
          float(),
          float(),
          keyword()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term(),
          term(),
          term(),
          float(),
          float(),
          boolean()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term(),
          term(),
          term(),
          float(),
          float(),
          boolean(),
          keyword()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term(),
          term(),
          term(),
          float(),
          float(),
          boolean(),
          term()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  @spec bootstrap_trace_data(
          Dspy.Primitives.Module.Module.t(),
          list(Dspy.Primitives.Example.t()),
          term() | nil,
          term(),
          term(),
          term(),
          float(),
          float(),
          boolean(),
          term(),
          keyword()
        ) ::
          {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())} | {:error, Snakepit.Error.t()}
  def bootstrap_trace_data(program, dataset) do
    SnakeBridge.Runtime.call(__MODULE__, :bootstrap_trace_data, [program, dataset], [])
  end

  def bootstrap_trace_data(program, dataset, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :bootstrap_trace_data, [program, dataset], opts)
  end

  def bootstrap_trace_data(program, dataset, metric) do
    SnakeBridge.Runtime.call(__MODULE__, :bootstrap_trace_data, [program, dataset, metric], [])
  end

  def bootstrap_trace_data(program, dataset, metric, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :bootstrap_trace_data, [program, dataset, metric], opts)
  end

  def bootstrap_trace_data(program, dataset, metric, num_threads) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [program, dataset, metric, num_threads],
      []
    )
  end

  def bootstrap_trace_data(program, dataset, metric, num_threads, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [program, dataset, metric, num_threads],
      opts
    )
  end

  def bootstrap_trace_data(program, dataset, metric, num_threads, raise_on_error) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [program, dataset, metric, num_threads, raise_on_error],
      []
    )
  end

  def bootstrap_trace_data(program, dataset, metric, num_threads, raise_on_error, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [program, dataset, metric, num_threads, raise_on_error],
      opts
    )
  end

  def bootstrap_trace_data(
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [program, dataset, metric, num_threads, raise_on_error, capture_failed_parses],
      []
    )
  end

  def bootstrap_trace_data(
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [program, dataset, metric, num_threads, raise_on_error, capture_failed_parses],
      opts
    )
  end

  def bootstrap_trace_data(
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score
      ],
      []
    )
  end

  def bootstrap_trace_data(
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score
      ],
      opts
    )
  end

  def bootstrap_trace_data(
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score,
        format_failure_score
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score,
        format_failure_score
      ],
      []
    )
  end

  def bootstrap_trace_data(
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score,
        format_failure_score,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score,
        format_failure_score
      ],
      opts
    )
  end

  def bootstrap_trace_data(
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score,
        format_failure_score,
        log_format_failures
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score,
        format_failure_score,
        log_format_failures
      ],
      []
    )
  end

  def bootstrap_trace_data(
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score,
        format_failure_score,
        log_format_failures,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score,
        format_failure_score,
        log_format_failures
      ],
      opts
    )
  end

  def bootstrap_trace_data(
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score,
        format_failure_score,
        log_format_failures,
        callback_metadata
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score,
        format_failure_score,
        log_format_failures,
        callback_metadata
      ],
      []
    )
  end

  def bootstrap_trace_data(
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score,
        format_failure_score,
        log_format_failures,
        callback_metadata,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :bootstrap_trace_data,
      [
        program,
        dataset,
        metric,
        num_threads,
        raise_on_error,
        capture_failed_parses,
        failure_score,
        format_failure_score,
        log_format_failures,
        callback_metadata
      ],
      opts
    )
  end

  @doc """
  DSPy Cache

  `Cache` provides 2 levels of caching (in the given order):
    1. In-memory cache - implemented with cachetools.LRUCache
    2. On-disk cache - implemented with diskcache.FanoutCache

  Returns:
  - `Dspy.Clients.Cache.Cache.t()`
  """
  @spec cache() :: {:ok, Dspy.Clients.Cache.Cache.t()} | {:error, Snakepit.Error.t()}
  def cache() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :cache)
  end

  @doc """

  """
  @spec configure(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def configure(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :configure, [], opts)
  end

  @doc """
  Configure the cache for DSPy.



  ## Parameters

  - `enable_disk_cache` - Whether to enable on-disk cache.
  - `enable_memory_cache` - Whether to enable in-memory cache.
  - `disk_cache_dir` - The directory to store the on-disk cache.
  - `disk_size_limit_bytes` - The size limit of the on-disk cache.
  - `memory_max_entries` - The maximum number of entries in the in-memory cache. To allow the cache to grow without bounds, set this parameter to `math.inf` or a similar value.

  Parameters:
  - `enable_disk_cache` (term() default: True)
  - `enable_memory_cache` (term() default: True)
  - `disk_cache_dir` (term() default: '/home/home/.dspy_cache')
  - `disk_size_limit_bytes` (term() default: 30000000000)
  - `memory_max_entries` (integer() default: 1000000)

  Returns:
  - `term()`
  """
  @spec configure_cache() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec configure_cache(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec configure_cache(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec configure_cache(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec configure_cache(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec configure_cache(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec configure_cache(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec configure_cache(term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec configure_cache(term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec configure_cache(term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec configure_cache(term(), term(), term(), term(), integer()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec configure_cache(term(), term(), term(), term(), integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def configure_cache() do
    SnakeBridge.Runtime.call(__MODULE__, :configure_cache, [], [])
  end

  def configure_cache(opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :configure_cache, [], opts)
  end

  def configure_cache(enable_disk_cache) do
    SnakeBridge.Runtime.call(__MODULE__, :configure_cache, [enable_disk_cache], [])
  end

  def configure_cache(enable_disk_cache, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :configure_cache, [enable_disk_cache], opts)
  end

  def configure_cache(enable_disk_cache, enable_memory_cache) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :configure_cache,
      [enable_disk_cache, enable_memory_cache],
      []
    )
  end

  def configure_cache(enable_disk_cache, enable_memory_cache, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :configure_cache,
      [enable_disk_cache, enable_memory_cache],
      opts
    )
  end

  def configure_cache(enable_disk_cache, enable_memory_cache, disk_cache_dir) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :configure_cache,
      [enable_disk_cache, enable_memory_cache, disk_cache_dir],
      []
    )
  end

  def configure_cache(enable_disk_cache, enable_memory_cache, disk_cache_dir, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :configure_cache,
      [enable_disk_cache, enable_memory_cache, disk_cache_dir],
      opts
    )
  end

  def configure_cache(
        enable_disk_cache,
        enable_memory_cache,
        disk_cache_dir,
        disk_size_limit_bytes
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :configure_cache,
      [enable_disk_cache, enable_memory_cache, disk_cache_dir, disk_size_limit_bytes],
      []
    )
  end

  def configure_cache(
        enable_disk_cache,
        enable_memory_cache,
        disk_cache_dir,
        disk_size_limit_bytes,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :configure_cache,
      [enable_disk_cache, enable_memory_cache, disk_cache_dir, disk_size_limit_bytes],
      opts
    )
  end

  def configure_cache(
        enable_disk_cache,
        enable_memory_cache,
        disk_cache_dir,
        disk_size_limit_bytes,
        memory_max_entries
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :configure_cache,
      [
        enable_disk_cache,
        enable_memory_cache,
        disk_cache_dir,
        disk_size_limit_bytes,
        memory_max_entries
      ],
      []
    )
  end

  def configure_cache(
        enable_disk_cache,
        enable_memory_cache,
        disk_cache_dir,
        disk_size_limit_bytes,
        memory_max_entries,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :configure_cache,
      [
        enable_disk_cache,
        enable_memory_cache,
        disk_cache_dir,
        disk_size_limit_bytes,
        memory_max_entries
      ],
      opts
    )
  end

  @doc """

  """
  @spec configure_dspy_loggers(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def configure_dspy_loggers(root_module_name, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :configure_dspy_loggers, [root_module_name], opts)
  end

  @doc """
  Context manager for temporary configuration changes at the thread level.

  Does not affect global configuration. Changes only apply to the current thread.
  If threads are spawned inside this block using ParallelExecutor, they will inherit these overrides.

  Parameters:
  - `kwargs` (term())

  Returns:
  - `term()`
  """
  @spec context(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def context(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :context, [], opts)
  end

  @doc """

  """
  @spec disable_litellm_logging(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_litellm_logging(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :disable_litellm_logging, [], opts)
  end

  @doc """
  Disables the `DSPyLoggingStream` used by event logging APIs throughout DSPy

  (`eprint()`, `logger.info()`, etc), silencing all subsequent event logs.

  Returns:
  - `term()`
  """
  @spec disable_logging(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_logging(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :disable_logging, [], opts)
  end

  @doc """
  DSPy Cache

  `Cache` provides 2 levels of caching (in the given order):
    1. In-memory cache - implemented with cachetools.LRUCache
    2. On-disk cache - implemented with diskcache.FanoutCache

  Returns:
  - `Dspy.Clients.Cache.Cache.t()`
  """
  @spec dspy_cache() :: {:ok, Dspy.Clients.Cache.Cache.t()} | {:error, Snakepit.Error.t()}
  def dspy_cache() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, "DSPY_CACHE")
  end

  @doc """

  """
  @spec enable_litellm_logging(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_litellm_logging(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :enable_litellm_logging, [], opts)
  end

  @doc """
  Enables the `DSPyLoggingStream` used by event logging APIs throughout DSPy

  (`eprint()`, `logger.info()`, etc), emitting all subsequent event logs. This
  reverses the effects of `disable_logging()`.

  Returns:
  - `term()`
  """
  @spec enable_logging(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_logging(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :enable_logging, [], opts)
  end

  @doc """

  """
  @spec ensure_signature(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec ensure_signature(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec ensure_signature(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec ensure_signature(term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def ensure_signature(signature) do
    SnakeBridge.Runtime.call(__MODULE__, :ensure_signature, [signature], [])
  end

  def ensure_signature(signature, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :ensure_signature, [signature], opts)
  end

  def ensure_signature(signature, instructions) do
    SnakeBridge.Runtime.call(__MODULE__, :ensure_signature, [signature, instructions], [])
  end

  def ensure_signature(signature, instructions, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :ensure_signature, [signature, instructions], opts)
  end

  @doc """
  Infer a prefix from an attribute name by converting it to a human-readable format.



  ## Examples

    "camelCaseText" -> "Camel Case Text"
    "snake_case_text" -> "Snake Case Text"
    "text2number" -> "Text 2 Number"
    "HTMLParser" -> "HTML Parser"

  Parameters:
  - `attribute_name` (String.t())

  Returns:
  - `String.t()`
  """
  @spec infer_prefix(String.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def infer_prefix(attribute_name, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :infer_prefix, [attribute_name], opts)
  end

  @doc """

  """
  @spec input_field(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def input_field(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, "InputField", [], opts)
  end

  @doc """
  The global history shared across all LMs.

  Parameters:
  - `n` (integer() default: 1)

  Returns:
  - `term()`
  """
  @spec inspect_history() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec inspect_history(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec inspect_history(integer()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec inspect_history(integer(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def inspect_history() do
    SnakeBridge.Runtime.call(__MODULE__, :inspect_history, [], [])
  end

  def inspect_history(opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :inspect_history, [], opts)
  end

  def inspect_history(n) do
    SnakeBridge.Runtime.call(__MODULE__, :inspect_history, [n], [])
  end

  def inspect_history(n, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :inspect_history, [n], opts)
  end

  @doc """
  Load saved DSPy model.

  This method is used to load a saved DSPy model with `save_program=True`, i.e., the model is saved with cloudpickle.

  ## Parameters

  - `path` - Path to the saved model. (type: `String.t()`)
  - `allow_pickle` - Whether to allow loading the model with pickle. This is dangerous and should only be used if you are sure you trust the source of the model. (type: `boolean()`)

  Parameters:
  - `path` (String.t())
  - `allow_pickle` (boolean() default: False)

  Returns:
  - `term()`
  """
  @spec load(String.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec load(String.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec load(String.t(), boolean()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec load(String.t(), boolean(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def load(path) do
    SnakeBridge.Runtime.call(__MODULE__, :load, [path], [])
  end

  def load(path, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :load, [path], opts)
  end

  def load(path, allow_pickle) do
    SnakeBridge.Runtime.call(__MODULE__, :load, [path, allow_pickle], [])
  end

  def load(path, allow_pickle, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :load, [path, allow_pickle], opts)
  end

  @doc """
  Load the settings from a file using cloudpickle.



  ## Parameters

  - `path` - The file path to load the settings from.

  Parameters:
  - `path` (String.t())

  Returns:
  - `%{optional(String.t()) => term()}`
  """
  @spec load_settings(String.t(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def load_settings(path, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :load_settings, [path], opts)
  end

  @doc """
  Returns the most common completion for the target field (or the last field) in the signature.

  When normalize returns None, that completion is ignored.
  In case of a tie, earlier completion are prioritized.

  Parameters:
  - `prediction_or_completions` (term())
  - `normalize` (term() default: <function default_normalize at 0x79b21aa899e0>)
  - `field` (term() default: None)

  Returns:
  - `term()`
  """
  @spec majority(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec majority(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec majority(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec majority(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec majority(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec majority(term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def majority(prediction_or_completions) do
    SnakeBridge.Runtime.call(__MODULE__, :majority, [prediction_or_completions], [])
  end

  def majority(prediction_or_completions, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :majority, [prediction_or_completions], opts)
  end

  def majority(prediction_or_completions, normalize) do
    SnakeBridge.Runtime.call(__MODULE__, :majority, [prediction_or_completions, normalize], [])
  end

  def majority(prediction_or_completions, normalize, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :majority, [prediction_or_completions, normalize], opts)
  end

  def majority(prediction_or_completions, normalize, field) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :majority,
      [prediction_or_completions, normalize, field],
      []
    )
  end

  def majority(prediction_or_completions, normalize, field, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :majority,
      [prediction_or_completions, normalize, field],
      opts
    )
  end

  @doc """
  Create a new Signature subclass with the specified fields and instructions.



  ## Parameters

  - `signature` - Either a string in the format "input1, input2 -> output1, output2" or a dictionary mapping field names to tuples of (type, FieldInfo).
  - `instructions` - Optional string containing instructions/prompt for the signature. If not provided, defaults to a basic description of inputs and outputs.
  - `signature_name` - Optional string to name the generated Signature subclass. Defaults to "StringSignature".
  - `custom_types` - Optional dictionary mapping type names to their actual type objects. Useful for resolving custom types that aren't built-ins or in the typing module.

  Parameters:
  - `signature` (term())
  - `instructions` (term() default: None)
  - `signature_name` (String.t() default: 'StringSignature')
  - `custom_types` (term() default: None)

  Returns:
  - `term()`
  """
  @spec make_signature(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec make_signature(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec make_signature(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec make_signature(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec make_signature(term(), term(), String.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec make_signature(term(), term(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec make_signature(term(), term(), String.t(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec make_signature(term(), term(), String.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def make_signature(signature) do
    SnakeBridge.Runtime.call(__MODULE__, :make_signature, [signature], [])
  end

  def make_signature(signature, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :make_signature, [signature], opts)
  end

  def make_signature(signature, instructions) do
    SnakeBridge.Runtime.call(__MODULE__, :make_signature, [signature, instructions], [])
  end

  def make_signature(signature, instructions, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :make_signature, [signature, instructions], opts)
  end

  def make_signature(signature, instructions, signature_name) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :make_signature,
      [signature, instructions, signature_name],
      []
    )
  end

  def make_signature(signature, instructions, signature_name, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :make_signature,
      [signature, instructions, signature_name],
      opts
    )
  end

  def make_signature(signature, instructions, signature_name, custom_types) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :make_signature,
      [signature, instructions, signature_name, custom_types],
      []
    )
  end

  def make_signature(signature, instructions, signature_name, custom_types, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :make_signature,
      [signature, instructions, signature_name, custom_types],
      opts
    )
  end

  @doc """

  """
  @spec output_field(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def output_field(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, "OutputField", [], opts)
  end

  @doc """
  A singleton class for DSPy configuration settings.

  Thread-safe global configuration.
  - 'configure' can be called by only one 'owner' thread (the first thread that calls it).
  - Other threads see the configured global values from 'main_thread_config'.
  - 'context' sets thread-local overrides. These overrides propagate to threads spawned
  inside that context block, when (and only when!) using a ParallelExecutor that copies overrides.

  1. Only one unique thread (which can be any thread!) can call dspy.configure.
  2. It affects a global state, visible to all. As a result, user threads work, but they shouldn't be
     mixed with concurrent changes to dspy.configure from the "main" thread.
     (TODO: In the future, add warnings: if there are near-in-time user-thread reads followed by .configure calls.)
  3. Any thread can use dspy.context. It propagates to child threads created with DSPy primitives: Parallel, asyncify, etc.

  Returns:
  - `Dspy.Dsp.Utils.Settings.Settings.t()`
  """
  @spec settings() :: {:ok, Dspy.Dsp.Utils.Settings.Settings.t()} | {:error, Snakepit.Error.t()}
  def settings() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :settings)
  end

  @doc """
  Wrap a DSPy program so that it streams its outputs incrementally, rather than returning them

  all at once. It also provides status messages to the user to indicate the progress of the program, and users
  can implement their own status message provider to customize the status messages and what module to generate
  status messages for.

  ## Parameters

  - `program` - The DSPy program to wrap with streaming functionality.
  - `status_message_provider` - A custom status message generator to use instead of the default one. Users can implement their own status message generator to customize the status messages and what module to generate status messages for.
  - `stream_listeners` - A list of stream listeners to capture the streaming output of specific fields of sub predicts in the program. When provided, only the target fields in the target predict will be streamed to the user.
  - `include_final_prediction_in_output_stream` - Whether to include the final prediction in the output stream, only useful when `stream_listeners` is provided. If `False`, the final prediction will not be included in the output stream. When the program hit cache, or no listeners captured anything, the final prediction will still be included in the output stream even if this is `False`.
  - `is_async_program` - Whether the program is async. If `False`, the program will be wrapped with `asyncify`, otherwise the program will be called with `acall`.
  - `async_streaming` - Whether to return an async generator or a sync generator. If `False`, the streaming will be converted to a sync generator.

  Parameters:
  - `program` (term())
  - `status_message_provider` (term() default: None)
  - `stream_listeners` (term() default: None)
  - `include_final_prediction_in_output_stream` (boolean() default: True)
  - `is_async_program` (boolean() default: False)
  - `async_streaming` (boolean() default: True)

  Returns:
  - `term()`
  """
  @spec streamify(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec streamify(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec streamify(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec streamify(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec streamify(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec streamify(term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec streamify(term(), term(), term(), boolean()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec streamify(term(), term(), term(), boolean(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec streamify(term(), term(), term(), boolean(), boolean()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec streamify(term(), term(), term(), boolean(), boolean(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec streamify(term(), term(), term(), boolean(), boolean(), boolean()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec streamify(term(), term(), term(), boolean(), boolean(), boolean(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def streamify(program) do
    SnakeBridge.Runtime.call(__MODULE__, :streamify, [program], [])
  end

  def streamify(program, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :streamify, [program], opts)
  end

  def streamify(program, status_message_provider) do
    SnakeBridge.Runtime.call(__MODULE__, :streamify, [program, status_message_provider], [])
  end

  def streamify(program, status_message_provider, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :streamify, [program, status_message_provider], opts)
  end

  def streamify(program, status_message_provider, stream_listeners) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :streamify,
      [program, status_message_provider, stream_listeners],
      []
    )
  end

  def streamify(program, status_message_provider, stream_listeners, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :streamify,
      [program, status_message_provider, stream_listeners],
      opts
    )
  end

  def streamify(
        program,
        status_message_provider,
        stream_listeners,
        include_final_prediction_in_output_stream
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :streamify,
      [
        program,
        status_message_provider,
        stream_listeners,
        include_final_prediction_in_output_stream
      ],
      []
    )
  end

  def streamify(
        program,
        status_message_provider,
        stream_listeners,
        include_final_prediction_in_output_stream,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :streamify,
      [
        program,
        status_message_provider,
        stream_listeners,
        include_final_prediction_in_output_stream
      ],
      opts
    )
  end

  def streamify(
        program,
        status_message_provider,
        stream_listeners,
        include_final_prediction_in_output_stream,
        is_async_program
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :streamify,
      [
        program,
        status_message_provider,
        stream_listeners,
        include_final_prediction_in_output_stream,
        is_async_program
      ],
      []
    )
  end

  def streamify(
        program,
        status_message_provider,
        stream_listeners,
        include_final_prediction_in_output_stream,
        is_async_program,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :streamify,
      [
        program,
        status_message_provider,
        stream_listeners,
        include_final_prediction_in_output_stream,
        is_async_program
      ],
      opts
    )
  end

  def streamify(
        program,
        status_message_provider,
        stream_listeners,
        include_final_prediction_in_output_stream,
        is_async_program,
        async_streaming
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :streamify,
      [
        program,
        status_message_provider,
        stream_listeners,
        include_final_prediction_in_output_stream,
        is_async_program,
        async_streaming
      ],
      []
    )
  end

  def streamify(
        program,
        status_message_provider,
        stream_listeners,
        include_final_prediction_in_output_stream,
        is_async_program,
        async_streaming,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :streamify,
      [
        program,
        status_message_provider,
        stream_listeners,
        include_final_prediction_in_output_stream,
        is_async_program,
        async_streaming
      ],
      opts
    )
  end

  @doc """
  Convert an async DSPy module to a sync program.

  There are two modes of this function:

  - `in_place=True` (recommended): Modify the module in place. But this may not work if you already have a `forward`
    method which does different things from `aforward`.
  - `in_place=False`: Return a wrapper module. This changes the module's architecture, but it's more robust.

  ## Parameters

  - `program` - The async program to convert, must have an `aforward` method implemented.
  - `in_place` - If True, modify the module in place. Otherwise, return a wrapper module.

  Parameters:
  - `program` (term())
  - `in_place` (boolean() default: True)

  Returns:
  - `term()`
  """
  @spec syncify(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec syncify(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec syncify(term(), boolean()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec syncify(term(), boolean(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def syncify(program) do
    SnakeBridge.Runtime.call(__MODULE__, :syncify, [program], [])
  end

  def syncify(program, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :syncify, [program], opts)
  end

  def syncify(program, in_place) do
    SnakeBridge.Runtime.call(__MODULE__, :syncify, [program, in_place], [])
  end

  def syncify(program, in_place, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :syncify, [program, in_place], opts)
  end

  @doc """
  Context manager for tracking LM usage.

  Returns:
  - `term()`
  """
  @spec track_usage(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def track_usage(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :track_usage, [], opts)
  end

  defmodule Adapters.Types.Audio do
    def __snakebridge_python_name__, do: "dspy.adapters.types.audio"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Encode audio to a dict with 'data' and 'audio_format'.

    Accepts: local file path, URL, data URI, dict, Audio instance, numpy array, or bytes (with known format).

    Parameters:
    - `audio` ((((String.t() | binary()) | %{optional(term()) => term()}) | Dspy.Adapters.Types.Audio.Audio.t())
    | term())
    - `sampling_rate` (integer() default: 16000)
    - `format` (String.t() default: 'wav')

    Returns:
    - `%{optional(term()) => term()}`
    """
    @spec encode_audio(
            (((String.t() | binary()) | %{optional(term()) => term()})
             | Dspy.Adapters.Types.Audio.Audio.t())
            | term()
          ) :: {:ok, %{optional(term()) => term()}} | {:error, Snakepit.Error.t()}
    @spec encode_audio(
            (((String.t() | binary()) | %{optional(term()) => term()})
             | Dspy.Adapters.Types.Audio.Audio.t())
            | term(),
            keyword()
          ) :: {:ok, %{optional(term()) => term()}} | {:error, Snakepit.Error.t()}
    @spec encode_audio(
            (((String.t() | binary()) | %{optional(term()) => term()})
             | Dspy.Adapters.Types.Audio.Audio.t())
            | term(),
            integer()
          ) :: {:ok, %{optional(term()) => term()}} | {:error, Snakepit.Error.t()}
    @spec encode_audio(
            (((String.t() | binary()) | %{optional(term()) => term()})
             | Dspy.Adapters.Types.Audio.Audio.t())
            | term(),
            integer(),
            keyword()
          ) :: {:ok, %{optional(term()) => term()}} | {:error, Snakepit.Error.t()}
    @spec encode_audio(
            (((String.t() | binary()) | %{optional(term()) => term()})
             | Dspy.Adapters.Types.Audio.Audio.t())
            | term(),
            integer(),
            String.t()
          ) :: {:ok, %{optional(term()) => term()}} | {:error, Snakepit.Error.t()}
    @spec encode_audio(
            (((String.t() | binary()) | %{optional(term()) => term()})
             | Dspy.Adapters.Types.Audio.Audio.t())
            | term(),
            integer(),
            String.t(),
            keyword()
          ) :: {:ok, %{optional(term()) => term()}} | {:error, Snakepit.Error.t()}
    def encode_audio(audio) do
      SnakeBridge.Runtime.call(__MODULE__, :encode_audio, [audio], [])
    end

    def encode_audio(audio, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :encode_audio, [audio], opts)
    end

    def encode_audio(audio, sampling_rate) do
      SnakeBridge.Runtime.call(__MODULE__, :encode_audio, [audio, sampling_rate], [])
    end

    def encode_audio(audio, sampling_rate, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :encode_audio, [audio, sampling_rate], opts)
    end

    def encode_audio(audio, sampling_rate, format) do
      SnakeBridge.Runtime.call(__MODULE__, :encode_audio, [audio, sampling_rate, format], [])
    end

    def encode_audio(audio, sampling_rate, format, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :encode_audio, [audio, sampling_rate, format], opts)
    end
  end

  defmodule Adapters.Types.BaseType do
    def __snakebridge_python_name__, do: "dspy.adapters.types.base_type"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Split user message content into a list of content blocks.

    This method splits each user message's content in the `messages` list to be a list of content block, so that
    the custom types like `dspy.Image` can be properly formatted for better quality. For example, the split content
    may look like below if the user message has a `dspy.Image` object:

    ```
    [
      {"type": "text", "text": "{text_before_image}"},
      {"type": "image_url", "image_url": {"url": "{image_url}"}},
      {"type": "text", "text": "{text_after_image}"},
    ]
    ```

    This is implemented by finding the `<<CUSTOM-TYPE-START-IDENTIFIER>>` and `<<CUSTOM-TYPE-END-IDENTIFIER>>`
    in the user message content and splitting the content around them. The `<<CUSTOM-TYPE-START-IDENTIFIER>>`
    and `<<CUSTOM-TYPE-END-IDENTIFIER>>` are the reserved identifiers for the custom types as in `dspy.Type`.

    ## Parameters

    - `messages` - a list of messages sent to the LM. The format is the same as [OpenAI API's messages format](https://platform.openai.com/docs/guides/chat-completions/response-format).

    Parameters:
    - `messages` (list(%{optional(String.t()) => term()}))

    Returns:
    - `list(%{optional(String.t()) => term()})`
    """
    @spec split_message_content_for_custom_types(
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def split_message_content_for_custom_types(messages, opts \\ []) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :split_message_content_for_custom_types,
        [messages],
        opts
      )
    end
  end

  defmodule Adapters.Types.File do
    def __snakebridge_python_name__, do: "dspy.adapters.types.file"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Encode various file inputs to a dict with file_data, file_id, and/or filename.



    ## Parameters

    - `file_input` - Can be a file path (str), bytes, or File instance.

    ## Returns

    Returns `map()`. A dictionary with file_data, file_id, and/or filename keys.

    Parameters:
    - `file_input` (term())

    Returns:
    - `%{optional(term()) => term()}`
    """
    @spec encode_file_to_dict(term(), keyword()) ::
            {:ok, %{optional(term()) => term()}} | {:error, Snakepit.Error.t()}
    def encode_file_to_dict(file_input, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :encode_file_to_dict, [file_input], opts)
    end
  end

  defmodule Adapters.Types.Image do
    def __snakebridge_python_name__, do: "dspy.adapters.types.image"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Encode an image or file to a base64 data URI.



    ## Parameters

    - `image` - The image or file to encode. Can be a PIL Image, file path, URL, or data URI.
    - `download_images` - Whether to download images from URLs.

    ## Returns

    Returns `String.t()`. The data URI of the file or the URL if download_images is False.

    ## Raises

    - `ArgumentError` - If the file type is not supported.

    Parameters:
    - `image` (((String.t() | binary()) | term()) | %{optional(term()) => term()})
    - `download_images` (boolean() default: False)

    Returns:
    - `String.t()`
    """
    @spec encode_image(((String.t() | binary()) | term()) | %{optional(term()) => term()}) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    @spec encode_image(
            ((String.t() | binary()) | term()) | %{optional(term()) => term()},
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    @spec encode_image(
            ((String.t() | binary()) | term()) | %{optional(term()) => term()},
            boolean()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    @spec encode_image(
            ((String.t() | binary()) | term()) | %{optional(term()) => term()},
            boolean(),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def encode_image(image) do
      SnakeBridge.Runtime.call(__MODULE__, :encode_image, [image], [])
    end

    def encode_image(image, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :encode_image, [image], opts)
    end

    def encode_image(image, download_images) do
      SnakeBridge.Runtime.call(__MODULE__, :encode_image, [image, download_images], [])
    end

    def encode_image(image, download_images, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :encode_image, [image, download_images], opts)
    end

    @doc """
    Check if the object is an image or a valid media file reference.

    Parameters:
    - `obj` (term())

    Returns:
    - `boolean()`
    """
    @spec is_image(term(), keyword()) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_image(obj, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :is_image, [obj], opts)
    end

    @doc """
    Check if a string is a valid URL.

    Parameters:
    - `string` (String.t())

    Returns:
    - `boolean()`
    """
    @spec is_url(String.t(), keyword()) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_url(string, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :is_url, [string], opts)
    end
  end

  defmodule Adapters.Types.Tool do
    def __snakebridge_python_name__, do: "dspy.adapters.types.tool"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Convert an input json schema to tool arguments compatible with DSPy Tool.



    ## Parameters

    - `schema` - An input json schema describing the tool's input parameters

    Parameters:
    - `schema` (%{optional(String.t()) => term()})

    Returns:
    - `{%{optional(String.t()) => term()},
    %{optional(String.t()) => Dspy.Adapters.Types.BaseType.Type.t()},
    %{optional(String.t()) => String.t()}}`
    """
    @spec convert_input_schema_to_tool_args(%{optional(String.t()) => term()}, keyword()) ::
            {:ok,
             {%{optional(String.t()) => term()},
              %{optional(String.t()) => Dspy.Adapters.Types.BaseType.Type.t()},
              %{optional(String.t()) => String.t()}}}
            | {:error, Snakepit.Error.t()}
    def convert_input_schema_to_tool_args(schema, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :convert_input_schema_to_tool_args, [schema], opts)
    end
  end

  defmodule Adapters.Utils do
    def __snakebridge_python_name__, do: "dspy.adapters.utils"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Finds the enum member corresponding to the specified identifier, which may be the

    enum member's name or value.

    ## Parameters

    - `enum` - The enum to search for the member.
    - `identifier` - If the enum is explicitly-valued, this is the value of the enum member to find. If the enum is auto-valued, this is the name of the enum member to find.

    Parameters:
    - `enum` (term())
    - `identifier` (term())

    Returns:
    - `term()`
    """
    @spec find_enum_member(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def find_enum_member(enum, identifier, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :find_enum_member, [enum, identifier], opts)
    end

    @doc """
    Formats the value of the specified field according to the field's DSPy type (input or output),

    annotation (e.g. str, int, etc.), and the type of the value itself.

    Parameters:
    - `field_info` (term())
    - `value` (term())
    - `assume_text` (term() default: True)

    Returns:
    - `term()`
    """
    @spec format_field_value(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_field_value(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_field_value(term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_field_value(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_field_value(field_info, value) do
      SnakeBridge.Runtime.call(__MODULE__, :format_field_value, [field_info, value], [])
    end

    def format_field_value(field_info, value, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :format_field_value, [field_info, value], opts)
    end

    def format_field_value(field_info, value, assume_text) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :format_field_value,
        [field_info, value, assume_text],
        []
      )
    end

    def format_field_value(field_info, value, assume_text, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :format_field_value,
        [field_info, value, assume_text],
        opts
      )
    end

    @doc """

    """
    @spec get_annotation_name(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_annotation_name(annotation, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_annotation_name, [annotation], opts)
    end

    @doc """

    """
    @spec get_field_description_string(%{optional(term()) => term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def get_field_description_string(fields, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_field_description_string, [fields], opts)
    end

    @doc """

    """
    @spec parse_value(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_value(value, annotation, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :parse_value, [value, annotation], opts)
    end

    @doc """
    Formats the specified value so that it can be serialized as a JSON string.



    ## Parameters

    - `value` - The value to format as a JSON string.

    Parameters:
    - `value` (term())

    Returns:
    - `term()`
    """
    @spec serialize_for_json(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_for_json(value, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :serialize_for_json, [value], opts)
    end

    @doc """

    """
    @spec translate_field_type(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def translate_field_type(field_name, field_info, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :translate_field_type, [field_name, field_info], opts)
    end
  end

  defmodule Clients do
    def __snakebridge_python_name__, do: "dspy.clients"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Configure the cache for DSPy.



    ## Parameters

    - `enable_disk_cache` - Whether to enable on-disk cache.
    - `enable_memory_cache` - Whether to enable in-memory cache.
    - `disk_cache_dir` - The directory to store the on-disk cache.
    - `disk_size_limit_bytes` - The size limit of the on-disk cache.
    - `memory_max_entries` - The maximum number of entries in the in-memory cache. To allow the cache to grow without bounds, set this parameter to `math.inf` or a similar value.

    Parameters:
    - `enable_disk_cache` (term() default: True)
    - `enable_memory_cache` (term() default: True)
    - `disk_cache_dir` (term() default: '/home/home/.dspy_cache')
    - `disk_size_limit_bytes` (term() default: 30000000000)
    - `memory_max_entries` (integer() default: 1000000)

    Returns:
    - `term()`
    """
    @spec configure_cache() :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec configure_cache(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec configure_cache(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec configure_cache(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec configure_cache(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec configure_cache(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec configure_cache(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec configure_cache(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec configure_cache(term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec configure_cache(term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec configure_cache(term(), term(), term(), term(), integer()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec configure_cache(term(), term(), term(), term(), integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def configure_cache() do
      SnakeBridge.Runtime.call(__MODULE__, :configure_cache, [], [])
    end

    def configure_cache(opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :configure_cache, [], opts)
    end

    def configure_cache(enable_disk_cache) do
      SnakeBridge.Runtime.call(__MODULE__, :configure_cache, [enable_disk_cache], [])
    end

    def configure_cache(enable_disk_cache, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :configure_cache, [enable_disk_cache], opts)
    end

    def configure_cache(enable_disk_cache, enable_memory_cache) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :configure_cache,
        [enable_disk_cache, enable_memory_cache],
        []
      )
    end

    def configure_cache(enable_disk_cache, enable_memory_cache, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :configure_cache,
        [enable_disk_cache, enable_memory_cache],
        opts
      )
    end

    def configure_cache(enable_disk_cache, enable_memory_cache, disk_cache_dir) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :configure_cache,
        [enable_disk_cache, enable_memory_cache, disk_cache_dir],
        []
      )
    end

    def configure_cache(enable_disk_cache, enable_memory_cache, disk_cache_dir, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :configure_cache,
        [enable_disk_cache, enable_memory_cache, disk_cache_dir],
        opts
      )
    end

    def configure_cache(
          enable_disk_cache,
          enable_memory_cache,
          disk_cache_dir,
          disk_size_limit_bytes
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :configure_cache,
        [enable_disk_cache, enable_memory_cache, disk_cache_dir, disk_size_limit_bytes],
        []
      )
    end

    def configure_cache(
          enable_disk_cache,
          enable_memory_cache,
          disk_cache_dir,
          disk_size_limit_bytes,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :configure_cache,
        [enable_disk_cache, enable_memory_cache, disk_cache_dir, disk_size_limit_bytes],
        opts
      )
    end

    def configure_cache(
          enable_disk_cache,
          enable_memory_cache,
          disk_cache_dir,
          disk_size_limit_bytes,
          memory_max_entries
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :configure_cache,
        [
          enable_disk_cache,
          enable_memory_cache,
          disk_cache_dir,
          disk_size_limit_bytes,
          memory_max_entries
        ],
        []
      )
    end

    def configure_cache(
          enable_disk_cache,
          enable_memory_cache,
          disk_cache_dir,
          disk_size_limit_bytes,
          memory_max_entries,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :configure_cache,
        [
          enable_disk_cache,
          enable_memory_cache,
          disk_cache_dir,
          disk_size_limit_bytes,
          memory_max_entries
        ],
        opts
      )
    end

    @doc """

    """
    @spec disable_litellm_logging(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def disable_litellm_logging(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :disable_litellm_logging, [], opts)
    end

    @doc """

    """
    @spec enable_litellm_logging(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def enable_litellm_logging(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :enable_litellm_logging, [], opts)
    end

    @doc """
    The global history shared across all LMs.

    Parameters:
    - `n` (integer() default: 1)

    Returns:
    - `term()`
    """
    @spec inspect_history() :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec inspect_history(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec inspect_history(integer()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec inspect_history(integer(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history() do
      SnakeBridge.Runtime.call(__MODULE__, :inspect_history, [], [])
    end

    def inspect_history(opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :inspect_history, [], opts)
    end

    def inspect_history(n) do
      SnakeBridge.Runtime.call(__MODULE__, :inspect_history, [n], [])
    end

    def inspect_history(n, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :inspect_history, [n], opts)
    end
  end

  defmodule Clients.BaseLm do
    def __snakebridge_python_name__, do: "dspy.clients.base_lm"
    def __snakebridge_library__, do: "dspy"

    @doc """
    The global history shared across all LMs.

    Parameters:
    - `n` (integer() default: 1)

    Returns:
    - `term()`
    """
    @spec inspect_history() :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec inspect_history(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec inspect_history(integer()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec inspect_history(integer(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history() do
      SnakeBridge.Runtime.call(__MODULE__, :inspect_history, [], [])
    end

    def inspect_history(opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :inspect_history, [], opts)
    end

    def inspect_history(n) do
      SnakeBridge.Runtime.call(__MODULE__, :inspect_history, [n], [])
    end

    def inspect_history(n, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :inspect_history, [n], opts)
    end
  end

  defmodule Clients.Cache do
    def __snakebridge_python_name__, do: "dspy.clients.cache"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Decorator for applying caching to a function based on the request argument.



    ## Parameters

    - `cache_arg_name` - The name of the argument that contains the request. If not provided, the entire kwargs is used as the request.
    - `ignored_args_for_cache_key` - A list of arguments to ignore when computing the cache key from the request.
    - `enable_memory_cache` - Whether to enable in-memory cache at call time. If False, the memory cache will not be written to on new data.

    Parameters:
    - `cache_arg_name` (term() default: None)
    - `ignored_args_for_cache_key` (term() default: None)
    - `enable_memory_cache` (boolean() default: True)
    - `maxsize` (term() keyword-only default: None)

    Returns:
    - `term()`
    """
    @spec request_cache() :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec request_cache(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec request_cache(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec request_cache(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec request_cache(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec request_cache(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec request_cache(term(), term(), boolean()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec request_cache(term(), term(), boolean(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def request_cache() do
      SnakeBridge.Runtime.call(__MODULE__, :request_cache, [], [])
    end

    def request_cache(opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :request_cache, [], opts)
    end

    def request_cache(cache_arg_name) do
      SnakeBridge.Runtime.call(__MODULE__, :request_cache, [cache_arg_name], [])
    end

    def request_cache(cache_arg_name, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :request_cache, [cache_arg_name], opts)
    end

    def request_cache(cache_arg_name, ignored_args_for_cache_key) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :request_cache,
        [cache_arg_name, ignored_args_for_cache_key],
        []
      )
    end

    def request_cache(cache_arg_name, ignored_args_for_cache_key, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :request_cache,
        [cache_arg_name, ignored_args_for_cache_key],
        opts
      )
    end

    def request_cache(cache_arg_name, ignored_args_for_cache_key, enable_memory_cache) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :request_cache,
        [cache_arg_name, ignored_args_for_cache_key, enable_memory_cache],
        []
      )
    end

    def request_cache(cache_arg_name, ignored_args_for_cache_key, enable_memory_cache, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :request_cache,
        [cache_arg_name, ignored_args_for_cache_key, enable_memory_cache],
        opts
      )
    end
  end

  defmodule Clients.Lm do
    def __snakebridge_python_name__, do: "dspy.clients.lm"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec alitellm_completion(%{optional(String.t()) => term()}, integer()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec alitellm_completion(%{optional(String.t()) => term()}, integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec alitellm_completion(%{optional(String.t()) => term()}, integer(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec alitellm_completion(%{optional(String.t()) => term()}, integer(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def alitellm_completion(request, num_retries) do
      SnakeBridge.Runtime.call(__MODULE__, :alitellm_completion, [request, num_retries], [])
    end

    def alitellm_completion(request, num_retries, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :alitellm_completion, [request, num_retries], opts)
    end

    def alitellm_completion(request, num_retries, cache) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :alitellm_completion,
        [request, num_retries, cache],
        []
      )
    end

    def alitellm_completion(request, num_retries, cache, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :alitellm_completion,
        [request, num_retries, cache],
        opts
      )
    end

    @doc """

    """
    @spec alitellm_responses_completion(%{optional(String.t()) => term()}, integer()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec alitellm_responses_completion(%{optional(String.t()) => term()}, integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec alitellm_responses_completion(%{optional(String.t()) => term()}, integer(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec alitellm_responses_completion(
            %{optional(String.t()) => term()},
            integer(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def alitellm_responses_completion(request, num_retries) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :alitellm_responses_completion,
        [request, num_retries],
        []
      )
    end

    def alitellm_responses_completion(request, num_retries, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :alitellm_responses_completion,
        [request, num_retries],
        opts
      )
    end

    def alitellm_responses_completion(request, num_retries, cache) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :alitellm_responses_completion,
        [request, num_retries, cache],
        []
      )
    end

    def alitellm_responses_completion(request, num_retries, cache, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :alitellm_responses_completion,
        [request, num_retries, cache],
        opts
      )
    end

    @doc """

    """
    @spec alitellm_text_completion(%{optional(String.t()) => term()}, integer()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec alitellm_text_completion(%{optional(String.t()) => term()}, integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec alitellm_text_completion(%{optional(String.t()) => term()}, integer(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec alitellm_text_completion(
            %{optional(String.t()) => term()},
            integer(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def alitellm_text_completion(request, num_retries) do
      SnakeBridge.Runtime.call(__MODULE__, :alitellm_text_completion, [request, num_retries], [])
    end

    def alitellm_text_completion(request, num_retries, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :alitellm_text_completion,
        [request, num_retries],
        opts
      )
    end

    def alitellm_text_completion(request, num_retries, cache) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :alitellm_text_completion,
        [request, num_retries, cache],
        []
      )
    end

    def alitellm_text_completion(request, num_retries, cache, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :alitellm_text_completion,
        [request, num_retries, cache],
        opts
      )
    end

    @doc """

    """
    @spec litellm_completion(%{optional(String.t()) => term()}, integer()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec litellm_completion(%{optional(String.t()) => term()}, integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec litellm_completion(%{optional(String.t()) => term()}, integer(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec litellm_completion(%{optional(String.t()) => term()}, integer(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def litellm_completion(request, num_retries) do
      SnakeBridge.Runtime.call(__MODULE__, :litellm_completion, [request, num_retries], [])
    end

    def litellm_completion(request, num_retries, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :litellm_completion, [request, num_retries], opts)
    end

    def litellm_completion(request, num_retries, cache) do
      SnakeBridge.Runtime.call(__MODULE__, :litellm_completion, [request, num_retries, cache], [])
    end

    def litellm_completion(request, num_retries, cache, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :litellm_completion,
        [request, num_retries, cache],
        opts
      )
    end

    @doc """

    """
    @spec litellm_responses_completion(%{optional(String.t()) => term()}, integer()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec litellm_responses_completion(%{optional(String.t()) => term()}, integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec litellm_responses_completion(%{optional(String.t()) => term()}, integer(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec litellm_responses_completion(
            %{optional(String.t()) => term()},
            integer(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def litellm_responses_completion(request, num_retries) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :litellm_responses_completion,
        [request, num_retries],
        []
      )
    end

    def litellm_responses_completion(request, num_retries, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :litellm_responses_completion,
        [request, num_retries],
        opts
      )
    end

    def litellm_responses_completion(request, num_retries, cache) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :litellm_responses_completion,
        [request, num_retries, cache],
        []
      )
    end

    def litellm_responses_completion(request, num_retries, cache, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :litellm_responses_completion,
        [request, num_retries, cache],
        opts
      )
    end

    @doc """

    """
    @spec litellm_text_completion(%{optional(String.t()) => term()}, integer()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec litellm_text_completion(%{optional(String.t()) => term()}, integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec litellm_text_completion(%{optional(String.t()) => term()}, integer(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec litellm_text_completion(%{optional(String.t()) => term()}, integer(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def litellm_text_completion(request, num_retries) do
      SnakeBridge.Runtime.call(__MODULE__, :litellm_text_completion, [request, num_retries], [])
    end

    def litellm_text_completion(request, num_retries, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :litellm_text_completion, [request, num_retries], opts)
    end

    def litellm_text_completion(request, num_retries, cache) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :litellm_text_completion,
        [request, num_retries, cache],
        []
      )
    end

    def litellm_text_completion(request, num_retries, cache, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :litellm_text_completion,
        [request, num_retries, cache],
        opts
      )
    end
  end

  defmodule Clients.LmLocal do
    def __snakebridge_python_name__, do: "dspy.clients.lm_local"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec create_output_dir(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def create_output_dir(model_name, data_path, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :create_output_dir, [model_name, data_path], opts)
    end

    @doc """
    This function encodes a single example into a format that can be used for sft training.

    Here, we assume each example has a 'messages' field. Each message in it is a dict with 'role' and 'content' fields.
    We use the `apply_chat_template` function from the tokenizer to tokenize the messages and prepare the input and label tensors.

    Code obtained from the allenai/open-instruct repository: https://github.com/allenai/open-instruct/blob/4365dea3d1a6111e8b2712af06b22a4512a0df88/open_instruct/finetune.py

    Parameters:
    - `example` (term())
    - `tokenizer` (term())
    - `max_seq_length` (term())

    Returns:
    - `term()`
    """
    @spec encode_sft_example(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def encode_sft_example(example, tokenizer, max_seq_length, opts \\ []) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :encode_sft_example,
        [example, tokenizer, max_seq_length],
        opts
      )
    end

    @doc """
    Return a free TCP port on localhost.

    Returns:
    - `integer()`
    """
    @spec get_free_port(keyword()) :: {:ok, integer()} | {:error, Snakepit.Error.t()}
    def get_free_port(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_free_port, [], opts)
    end

    @doc """

    """
    @spec train_sft_locally(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def train_sft_locally(model_name, train_data, train_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :train_sft_locally,
        [model_name, train_data, train_kwargs],
        opts
      )
    end

    @doc """
    Wait for the server to be ready by polling the /v1/models endpoint.



    ## Parameters

    - `base_url` - The base URL of the server (e.g. http://localhost:1234)
    - `timeout` - Maximum time to wait in seconds. None means wait forever.

    Parameters:
    - `base_url` (String.t())
    - `timeout` (term() default: None)

    Returns:
    - `nil`
    """
    @spec wait_for_server(String.t()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    @spec wait_for_server(String.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    @spec wait_for_server(String.t(), term()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    @spec wait_for_server(String.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def wait_for_server(base_url) do
      SnakeBridge.Runtime.call(__MODULE__, :wait_for_server, [base_url], [])
    end

    def wait_for_server(base_url, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :wait_for_server, [base_url], opts)
    end

    def wait_for_server(base_url, timeout) do
      SnakeBridge.Runtime.call(__MODULE__, :wait_for_server, [base_url, timeout], [])
    end

    def wait_for_server(base_url, timeout, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :wait_for_server, [base_url, timeout], opts)
    end
  end

  defmodule Clients.UtilsFinetune do
    def __snakebridge_python_name__, do: "dspy.clients.utils_finetune"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec find_data_error_chat(%{optional(String.t()) => term()}, keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def find_data_error_chat(messages, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :find_data_error_chat, [messages], opts)
    end

    @doc """

    """
    @spec find_data_error_chat_message(%{optional(String.t()) => term()}, keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def find_data_error_chat_message(message, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :find_data_error_chat_message, [message], opts)
    end

    @doc """

    """
    @spec find_data_errors_completion(%{optional(String.t()) => String.t()}, keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def find_data_errors_completion(data_dict, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :find_data_errors_completion, [data_dict], opts)
    end

    @doc """

    """
    @spec get_finetune_directory(keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def get_finetune_directory(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_finetune_directory, [], opts)
    end

    @doc """

    """
    @spec infer_data_format(Dspy.Adapters.Base.Adapter.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def infer_data_format(adapter, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :infer_data_format, [adapter], opts)
    end

    @doc """

    """
    @spec save_data(list(%{optional(String.t()) => term()}), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def save_data(data, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :save_data, [data], opts)
    end

    @doc """

    """
    @spec validate_data_format(
            list(%{optional(String.t()) => term()}),
            Dspy.Clients.UtilsFinetune.TrainDataFormat.t(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate_data_format(data, data_format, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :validate_data_format, [data, data_format], opts)
    end

    @doc """

    """
    @spec write_lines(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def write_lines(file_path, data, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :write_lines, [file_path, data], opts)
    end
  end

  defmodule Datasets.Alfworld.Alfworld do
    def __snakebridge_python_name__, do: "dspy.datasets.alfworld.alfworld"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Worker process: creates a single AlfredTWEnv instance,

    handles 'init' (with task idx) and 'step' (with action).

    Parameters:
    - `inq` (term())
    - `outq` (term())

    Returns:
    - `term()`
    """
    @spec env_worker(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def env_worker(inq, outq, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :env_worker, [inq, outq], opts)
    end
  end

  defmodule Datasets.Gsm8k do
    def __snakebridge_python_name__, do: "dspy.datasets.gsm8k"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec gsm8k_metric(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec gsm8k_metric(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec gsm8k_metric(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec gsm8k_metric(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def gsm8k_metric(gold, pred) do
      SnakeBridge.Runtime.call(__MODULE__, :gsm8k_metric, [gold, pred], [])
    end

    def gsm8k_metric(gold, pred, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :gsm8k_metric, [gold, pred], opts)
    end

    def gsm8k_metric(gold, pred, trace) do
      SnakeBridge.Runtime.call(__MODULE__, :gsm8k_metric, [gold, pred, trace], [])
    end

    def gsm8k_metric(gold, pred, trace, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :gsm8k_metric, [gold, pred, trace], opts)
    end

    @doc """

    """
    @spec parse_integer_answer(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec parse_integer_answer(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec parse_integer_answer(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec parse_integer_answer(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_integer_answer(answer) do
      SnakeBridge.Runtime.call(__MODULE__, :parse_integer_answer, [answer], [])
    end

    def parse_integer_answer(answer, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :parse_integer_answer, [answer], opts)
    end

    def parse_integer_answer(answer, only_first_line) do
      SnakeBridge.Runtime.call(__MODULE__, :parse_integer_answer, [answer, only_first_line], [])
    end

    def parse_integer_answer(answer, only_first_line, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :parse_integer_answer, [answer, only_first_line], opts)
    end
  end

  defmodule Datasets.Math do
    def __snakebridge_python_name__, do: "dspy.datasets.math"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec extract_answer(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_answer(s, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :extract_answer, [s], opts)
    end
  end

  defmodule Dsp.Colbertv2 do
    def __snakebridge_python_name__, do: "dspy.dsp.colbertv2"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec colbertv2_get_request(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def colbertv2_get_request(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :colbertv2_get_request, [], opts)
    end

    @doc """

    """
    @spec colbertv2_get_request_v2(String.t(), String.t(), integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def colbertv2_get_request_v2(url, query, k, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :colbertv2_get_request_v2, [url, query, k], opts)
    end

    @doc """

    """
    @spec colbertv2_get_request_v2_wrapped(keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def colbertv2_get_request_v2_wrapped(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :colbertv2_get_request_v2_wrapped, [], opts)
    end

    @doc """

    """
    @spec colbertv2_post_request(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def colbertv2_post_request(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :colbertv2_post_request, [], opts)
    end

    @doc """

    """
    @spec colbertv2_post_request_v2(String.t(), String.t(), integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def colbertv2_post_request_v2(url, query, k, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :colbertv2_post_request_v2, [url, query, k], opts)
    end

    @doc """

    """
    @spec colbertv2_post_request_v2_wrapped(keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def colbertv2_post_request_v2_wrapped(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :colbertv2_post_request_v2_wrapped, [], opts)
    end
  end

  defmodule Dsp.Utils do
    def __snakebridge_python_name__, do: "dspy.dsp.utils"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec batch(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec batch(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec batch(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec batch(term(), term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(group, bsize) do
      SnakeBridge.Runtime.call(__MODULE__, :batch, [group, bsize], [])
    end

    def batch(group, bsize, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :batch, [group, bsize], opts)
    end

    def batch(group, bsize, provide_offset) do
      SnakeBridge.Runtime.call(__MODULE__, :batch, [group, bsize, provide_offset], [])
    end

    def batch(group, bsize, provide_offset, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :batch, [group, bsize, provide_offset], opts)
    end

    @doc """

    """
    @spec create_directory(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def create_directory(path, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :create_directory, [path], opts)
    end

    @doc """
    From Raymond Hettinger

    https://twitter.com/raymondh/status/944125570534621185
    Since Python 3.6 Dict are ordered
    Benchmark: https://gist.github.com/peterbe/67b9e40af60a1d5bcb1cfb4b2937b088

    Parameters:
    - `seq` (list(String.t()))

    Returns:
    - `list(String.t())`
    """
    @spec deduplicate(list(String.t()), keyword()) ::
            {:ok, list(String.t())} | {:error, Snakepit.Error.t()}
    def deduplicate(seq, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :deduplicate, [seq], opts)
    end

    @doc """

    """
    @spec default_config() ::
            {:ok, Dspy.Dsp.Utils.Utils.Dotdict.t()} | {:error, Snakepit.Error.t()}
    def default_config() do
      SnakeBridge.Runtime.get_module_attr(__MODULE__, "DEFAULT_CONFIG")
    end

    @doc """

    """
    @spec dpr_normalize(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dpr_normalize(text, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, "DPR_normalize", [text], opts)
    end

    @doc """

    """
    @spec dpr_tokenize(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dpr_tokenize(text, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, "DPR_tokenize", [text], opts)
    end

    @doc """

    """
    @spec file_tqdm(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def file_tqdm(file, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :file_tqdm, [file], opts)
    end

    @doc """

    """
    @spec flatten(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def flatten(data_list, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :flatten, [data_list], opts)
    end

    @doc """

    """
    @spec groupby_first_item(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def groupby_first_item(lst, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :groupby_first_item, [lst], opts)
    end

    @doc """
    Collect data into fixed-length chunks or blocks

    Example: grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
      Source: https://docs.python.org/3/library/itertools.html#itertools-recipes

    Parameters:
    - `iterable` (term())
    - `n` (term())
    - `fillvalue` (term() default: None)

    Returns:
    - `term()`
    """
    @spec grouper(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec grouper(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec grouper(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec grouper(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def grouper(iterable, n) do
      SnakeBridge.Runtime.call(__MODULE__, :grouper, [iterable, n], [])
    end

    def grouper(iterable, n, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :grouper, [iterable, n], opts)
    end

    def grouper(iterable, n, fillvalue) do
      SnakeBridge.Runtime.call(__MODULE__, :grouper, [iterable, n, fillvalue], [])
    end

    def grouper(iterable, n, fillvalue, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :grouper, [iterable, n, fillvalue], opts)
    end

    @doc """

    """
    @spec has_answer(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def has_answer(tokenized_answers, text, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :has_answer, [tokenized_answers, text], opts)
    end

    @doc """

    """
    @spec int_or_float(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def int_or_float(val, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :int_or_float, [val], opts)
    end

    @doc """

    """
    @spec lengths2offsets(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lengths2offsets(lengths, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :lengths2offsets, [lengths], opts)
    end

    @doc """

    """
    @spec load_batch_backgrounds(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_batch_backgrounds(args, qids, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :load_batch_backgrounds, [args, qids], opts)
    end

    @doc """
    Returns each occurrence of an answer as (offset, endpos) in terms of *characters*.

    Parameters:
    - `tokenized_answers` (term())
    - `text` (term())

    Returns:
    - `term()`
    """
    @spec locate_answers(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def locate_answers(tokenized_answers, text, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :locate_answers, [tokenized_answers, text], opts)
    end

    @doc """

    """
    @spec main_thread_config() ::
            {:ok, Dspy.Dsp.Utils.Utils.Dotdict.t()} | {:error, Snakepit.Error.t()}
    def main_thread_config() do
      SnakeBridge.Runtime.get_module_attr(__MODULE__, :main_thread_config)
    end

    @doc """

    """
    @spec print_message(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def print_message(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :print_message, [], opts)
    end

    @doc """
    Requires items in list to already be grouped by first item.

    Parameters:
    - `lst` (term())

    Returns:
    - `term()`
    """
    @spec process_grouped_by_first_item(term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def process_grouped_by_first_item(lst, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :process_grouped_by_first_item, [lst], opts)
    end

    @doc """

    """
    @spec s_tokenizer() ::
            {:ok, Dspy.Dsp.Utils.Dpr.SimpleTokenizer.t()} | {:error, Snakepit.Error.t()}
    def s_tokenizer() do
      SnakeBridge.Runtime.get_module_attr(__MODULE__, "STokenizer")
    end

    @doc """
    A singleton class for DSPy configuration settings.

    Thread-safe global configuration.
    - 'configure' can be called by only one 'owner' thread (the first thread that calls it).
    - Other threads see the configured global values from 'main_thread_config'.
    - 'context' sets thread-local overrides. These overrides propagate to threads spawned
    inside that context block, when (and only when!) using a ParallelExecutor that copies overrides.

    1. Only one unique thread (which can be any thread!) can call dspy.configure.
    2. It affects a global state, visible to all. As a result, user threads work, but they shouldn't be
       mixed with concurrent changes to dspy.configure from the "main" thread.
       (TODO: In the future, add warnings: if there are near-in-time user-thread reads followed by .configure calls.)
    3. Any thread can use dspy.context. It propagates to child threads created with DSPy primitives: Parallel, asyncify, etc.

    Returns:
    - `Dspy.Dsp.Utils.Settings.Settings.t()`
    """
    @spec settings() :: {:ok, Dspy.Dsp.Utils.Settings.Settings.t()} | {:error, Snakepit.Error.t()}
    def settings() do
      SnakeBridge.Runtime.get_module_attr(__MODULE__, :settings)
    end

    @doc """
    Strips accents from a piece of text.

    Parameters:
    - `text` (term())

    Returns:
    - `term()`
    """
    @spec strip_accents(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def strip_accents(text, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :strip_accents, [text], opts)
    end

    @doc """

    """
    @spec timestamp() :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec timestamp(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec timestamp(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec timestamp(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def timestamp() do
      SnakeBridge.Runtime.call(__MODULE__, :timestamp, [], [])
    end

    def timestamp(opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :timestamp, [], opts)
    end

    def timestamp(daydir) do
      SnakeBridge.Runtime.call(__MODULE__, :timestamp, [daydir], [])
    end

    def timestamp(daydir, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :timestamp, [daydir], opts)
    end

    @doc """

    """
    @spec zip_first(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def zip_first(list1, list2, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :zip_first, [list1, list2], opts)
    end

    @doc """
    A much faster A, B, C = zip(*[(a, b, c), (a, b, c), ...])

    May return lists or tuples.

    Parameters:
    - `data_list` (term())
    - `lazy` (term() default: False)

    Returns:
    - `term()`
    """
    @spec zipstar(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec zipstar(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec zipstar(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec zipstar(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def zipstar(data_list) do
      SnakeBridge.Runtime.call(__MODULE__, :zipstar, [data_list], [])
    end

    def zipstar(data_list, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :zipstar, [data_list], opts)
    end

    def zipstar(data_list, lazy) do
      SnakeBridge.Runtime.call(__MODULE__, :zipstar, [data_list, lazy], [])
    end

    def zipstar(data_list, lazy, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :zipstar, [data_list, lazy], opts)
    end
  end

  defmodule Dsp.Utils.Dpr do
    def __snakebridge_python_name__, do: "dspy.dsp.utils.dpr"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Source: DPR Implementation from Facebook Research

    https://github.com/facebookresearch/DPR/tree/master/dpr
    Original license: https://github.com/facebookresearch/DPR/blob/main/LICENSE

    Parameters:
    - `text` (term())

    Returns:
    - `term()`
    """
    @spec dpr_normalize(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dpr_normalize(text, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, "DPR_normalize", [text], opts)
    end

    @doc """
    Source: DPR Implementation from Facebook Research

    https://github.com/facebookresearch/DPR/tree/master/dpr
    Original license: https://github.com/facebookresearch/DPR/blob/main/LICENSE

    Parameters:
    - `text` (term())

    Returns:
    - `term()`
    """
    @spec dpr_tokenize(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dpr_tokenize(text, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, "DPR_tokenize", [text], opts)
    end

    @doc """
    Source: DPR Implementation from Facebook Research

    https://github.com/facebookresearch/DPR/tree/master/dpr
    Original license: https://github.com/facebookresearch/DPR/blob/main/LICENSE

    Parameters:
    - `tokenized_answers` (term())
    - `text` (term())

    Returns:
    - `term()`
    """
    @spec has_answer(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def has_answer(tokenized_answers, text, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :has_answer, [tokenized_answers, text], opts)
    end

    @doc """
    Returns each occurrence of an answer as (offset, endpos) in terms of *characters*.

    Parameters:
    - `tokenized_answers` (term())
    - `text` (term())

    Returns:
    - `term()`
    """
    @spec locate_answers(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def locate_answers(tokenized_answers, text, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :locate_answers, [tokenized_answers, text], opts)
    end

    @doc """
    Source: DPR Implementation from Facebook Research

    https://github.com/facebookresearch/DPR/tree/master/dpr
    Original license: https://github.com/facebookresearch/DPR/blob/main/LICENSE

    Returns:
    - `Dspy.Dsp.Utils.Dpr.SimpleTokenizer.t()`
    """
    @spec s_tokenizer() ::
            {:ok, Dspy.Dsp.Utils.Dpr.SimpleTokenizer.t()} | {:error, Snakepit.Error.t()}
    def s_tokenizer() do
      SnakeBridge.Runtime.get_module_attr(__MODULE__, "STokenizer")
    end

    @doc """
    Strips accents from a piece of text.

    Parameters:
    - `text` (term())

    Returns:
    - `term()`
    """
    @spec strip_accents(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def strip_accents(text, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :strip_accents, [text], opts)
    end
  end

  defmodule Dsp.Utils.Settings do
    def __snakebridge_python_name__, do: "dspy.dsp.utils.settings"
    def __snakebridge_library__, do: "dspy"

    @doc """
    A singleton class for DSPy configuration settings.

    Thread-safe global configuration.
    - 'configure' can be called by only one 'owner' thread (the first thread that calls it).
    - Other threads see the configured global values from 'main_thread_config'.
    - 'context' sets thread-local overrides. These overrides propagate to threads spawned
    inside that context block, when (and only when!) using a ParallelExecutor that copies overrides.

    1. Only one unique thread (which can be any thread!) can call dspy.configure.
    2. It affects a global state, visible to all. As a result, user threads work, but they shouldn't be
       mixed with concurrent changes to dspy.configure from the "main" thread.
       (TODO: In the future, add warnings: if there are near-in-time user-thread reads followed by .configure calls.)
    3. Any thread can use dspy.context. It propagates to child threads created with DSPy primitives: Parallel, asyncify, etc.

    Returns:
    - `Dspy.Dsp.Utils.Settings.Settings.t()`
    """
    @spec settings() :: {:ok, Dspy.Dsp.Utils.Settings.Settings.t()} | {:error, Snakepit.Error.t()}
    def settings() do
      SnakeBridge.Runtime.get_module_attr(__MODULE__, :settings)
    end
  end

  defmodule Dsp.Utils.Utils do
    def __snakebridge_python_name__, do: "dspy.dsp.utils.utils"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec batch(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec batch(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec batch(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec batch(term(), term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(group, bsize) do
      SnakeBridge.Runtime.call(__MODULE__, :batch, [group, bsize], [])
    end

    def batch(group, bsize, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :batch, [group, bsize], opts)
    end

    def batch(group, bsize, provide_offset) do
      SnakeBridge.Runtime.call(__MODULE__, :batch, [group, bsize, provide_offset], [])
    end

    def batch(group, bsize, provide_offset, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :batch, [group, bsize, provide_offset], opts)
    end

    @doc """

    """
    @spec create_directory(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def create_directory(path, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :create_directory, [path], opts)
    end

    @doc """
    From Raymond Hettinger

    https://twitter.com/raymondh/status/944125570534621185
    Since Python 3.6 Dict are ordered
    Benchmark: https://gist.github.com/peterbe/67b9e40af60a1d5bcb1cfb4b2937b088

    Parameters:
    - `seq` (list(String.t()))

    Returns:
    - `list(String.t())`
    """
    @spec deduplicate(list(String.t()), keyword()) ::
            {:ok, list(String.t())} | {:error, Snakepit.Error.t()}
    def deduplicate(seq, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :deduplicate, [seq], opts)
    end

    @doc """

    """
    @spec file_tqdm(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def file_tqdm(file, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :file_tqdm, [file], opts)
    end

    @doc """

    """
    @spec flatten(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def flatten(data_list, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :flatten, [data_list], opts)
    end

    @doc """

    """
    @spec groupby_first_item(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def groupby_first_item(lst, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :groupby_first_item, [lst], opts)
    end

    @doc """
    Collect data into fixed-length chunks or blocks

    Example: grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
      Source: https://docs.python.org/3/library/itertools.html#itertools-recipes

    Parameters:
    - `iterable` (term())
    - `n` (term())
    - `fillvalue` (term() default: None)

    Returns:
    - `term()`
    """
    @spec grouper(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec grouper(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec grouper(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec grouper(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def grouper(iterable, n) do
      SnakeBridge.Runtime.call(__MODULE__, :grouper, [iterable, n], [])
    end

    def grouper(iterable, n, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :grouper, [iterable, n], opts)
    end

    def grouper(iterable, n, fillvalue) do
      SnakeBridge.Runtime.call(__MODULE__, :grouper, [iterable, n, fillvalue], [])
    end

    def grouper(iterable, n, fillvalue, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :grouper, [iterable, n, fillvalue], opts)
    end

    @doc """

    """
    @spec int_or_float(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def int_or_float(val, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :int_or_float, [val], opts)
    end

    @doc """

    """
    @spec lengths2offsets(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lengths2offsets(lengths, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :lengths2offsets, [lengths], opts)
    end

    @doc """

    """
    @spec load_batch_backgrounds(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_batch_backgrounds(args, qids, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :load_batch_backgrounds, [args, qids], opts)
    end

    @doc """

    """
    @spec print_message(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def print_message(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :print_message, [], opts)
    end

    @doc """
    Requires items in list to already be grouped by first item.

    Parameters:
    - `lst` (term())

    Returns:
    - `term()`
    """
    @spec process_grouped_by_first_item(term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def process_grouped_by_first_item(lst, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :process_grouped_by_first_item, [lst], opts)
    end

    @doc """

    """
    @spec timestamp() :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec timestamp(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec timestamp(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec timestamp(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def timestamp() do
      SnakeBridge.Runtime.call(__MODULE__, :timestamp, [], [])
    end

    def timestamp(opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :timestamp, [], opts)
    end

    def timestamp(daydir) do
      SnakeBridge.Runtime.call(__MODULE__, :timestamp, [daydir], [])
    end

    def timestamp(daydir, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :timestamp, [daydir], opts)
    end

    @doc """

    """
    @spec zip_first(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def zip_first(list1, list2, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :zip_first, [list1, list2], opts)
    end

    @doc """
    A much faster A, B, C = zip(*[(a, b, c), (a, b, c), ...])

    May return lists or tuples.

    Parameters:
    - `data_list` (term())
    - `lazy` (term() default: False)

    Returns:
    - `term()`
    """
    @spec zipstar(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec zipstar(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec zipstar(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec zipstar(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def zipstar(data_list) do
      SnakeBridge.Runtime.call(__MODULE__, :zipstar, [data_list], [])
    end

    def zipstar(data_list, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :zipstar, [data_list], opts)
    end

    def zipstar(data_list, lazy) do
      SnakeBridge.Runtime.call(__MODULE__, :zipstar, [data_list, lazy], [])
    end

    def zipstar(data_list, lazy, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :zipstar, [data_list, lazy], opts)
    end
  end

  defmodule Evaluate do
    def __snakebridge_python_name__, do: "dspy.evaluate"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Evaluate exact match or F1-thresholded match for an example/prediction pair.

    If `example.answer` is a string, compare `pred.answer` against it. If it's a list,
    compare against any of the references. When `frac >= 1.0` (default), use EM;
    otherwise require that the maximum F1 across references is at least `frac`.

    ## Parameters

    - `example` - `dspy.Example` object with field `answer` (str or list[str]).
    - `pred` - `dspy.Prediction` object with field `answer` (str).
    - `trace` - Unused; reserved for compatibility.
    - `frac` - Threshold in [0.0, 1.0]. `1.0` means EM. (type: `float()`)

    ## Returns

    Returns `boolean()`. True if the match condition holds; otherwise False.

    ## Examples

      ```python
      import dspy

      example = dspy.Example(answer=["Eiffel Tower", "Louvre"])
      pred = dspy.Prediction(answer="The Eiffel Tower")

      answer_exact_match(example, pred, frac=1.0)  # equivalent to EM, True
      answer_exact_match(example, pred, frac=0.5)  # True
      ```

    Parameters:
    - `example` (term())
    - `pred` (term())
    - `trace` (term() default: None)
    - `frac` (term() default: 1.0)

    Returns:
    - `term()`
    """
    @spec answer_exact_match(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_exact_match(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_exact_match(term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_exact_match(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_exact_match(term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_exact_match(term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def answer_exact_match(example, pred) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_exact_match, [example, pred], [])
    end

    def answer_exact_match(example, pred, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_exact_match, [example, pred], opts)
    end

    def answer_exact_match(example, pred, trace) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_exact_match, [example, pred, trace], [])
    end

    def answer_exact_match(example, pred, trace, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_exact_match, [example, pred, trace], opts)
    end

    def answer_exact_match(example, pred, trace, frac) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_exact_match, [example, pred, trace, frac], [])
    end

    def answer_exact_match(example, pred, trace, frac, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :answer_exact_match,
        [example, pred, trace, frac],
        opts
      )
    end

    @doc """
    Return True if any passage in `pred.context` contains the answer(s).

    Strings are normalized (and passages also use DPR normalization internally).

    ## Parameters

    - `example` - `dspy.Example` object with field `answer` (str or list[str]).
    - `pred` - `dspy.Prediction` object with field `context` (list[str]) containing passages.
    - `trace` - Unused; reserved for compatibility.

    ## Returns

    Returns `boolean()`. True if any passage contains any reference answer; otherwise False.

    ## Examples

      ```python
      import dspy

      example = dspy.Example(answer="Eiffel Tower")
      pred = dspy.Prediction(context=["The Eiffel Tower is in Paris.", "..."])

      answer_passage_match(example, pred)  # True
      ```

    Parameters:
    - `example` (term())
    - `pred` (term())
    - `trace` (term() default: None)

    Returns:
    - `term()`
    """
    @spec answer_passage_match(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_passage_match(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_passage_match(term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_passage_match(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def answer_passage_match(example, pred) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_passage_match, [example, pred], [])
    end

    def answer_passage_match(example, pred, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_passage_match, [example, pred], opts)
    end

    def answer_passage_match(example, pred, trace) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_passage_match, [example, pred, trace], [])
    end

    def answer_passage_match(example, pred, trace, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_passage_match, [example, pred, trace], opts)
    end

    @doc """
    Compute the Exact Match (EM) metric between a prediction and reference answers.

    Returns True if any reference exactly matches the prediction after normalization;
    otherwise False. Normalization applies Unicode NFD, lowercasing, punctuation
    removal, English article removal ("a", "an", "the"), and whitespace collapse.

    ## Parameters

    - `prediction` - Predicted answer string. (type: `String.t()`)
    - `answers_list` - List of reference answers. (type: `list(String.t())`)

    ## Returns

    Returns `boolean()`. Whether any reference exactly equals the prediction after normalization.

    ## Examples

      ```python
      EM("The Eiffel Tower", ["Eiffel Tower", "Louvre"])  # True

      EM("paris", ["Paris"])  # True
      EM("paris", ["Paris, France"])  # False
      ```

    Parameters:
    - `prediction` (term())
    - `answers_list` (term())

    Returns:
    - `term()`
    """
    @spec em(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def em(prediction, answers_list, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, "EM", [prediction, answers_list], opts)
    end

    @doc """
    Normalize text for string and token comparisons.

    Steps:
      1) Unicode NFD normalization
      2) lowercasing
      3) punctuation removal
      4) English article removal ("a", "an", "the")
      5) whitespace collapse

    ## Parameters

    - `s` - Input string. (type: `String.t()`)

    ## Returns

    Returns `String.t()`. Normalized string.

    ## Examples

      ```python
      normalize_text("The,  Eiffel  Tower!")  # "eiffel tower"
      ```

    Parameters:
    - `s` (term())

    Returns:
    - `term()`
    """
    @spec normalize_text(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def normalize_text(s, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :normalize_text, [s], opts)
    end
  end

  defmodule Evaluate.AutoEvaluation do
    def __snakebridge_python_name__, do: "dspy.evaluate.auto_evaluation"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec f1_score(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def f1_score(precision, recall, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :f1_score, [precision, recall], opts)
    end
  end

  defmodule Evaluate.Evaluate do
    def __snakebridge_python_name__, do: "dspy.evaluate.evaluate"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Set various pandas display options for DataFrame in an IPython notebook environment.

    Parameters:
    - `df` (term())

    Returns:
    - `term()`
    """
    @spec configure_dataframe_for_ipython_notebook_display(term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def configure_dataframe_for_ipython_notebook_display(df, opts \\ []) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :configure_dataframe_for_ipython_notebook_display,
        [df],
        opts
      )
    end

    @doc """
    Display the specified Python object in the console.



    ## Parameters

    - `obj` - The Python object to display.

    Parameters:
    - `obj` (term())

    Returns:
    - `nil`
    """
    @spec display(term(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def display(obj, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :display, [obj], opts)
    end

    @doc """
    Display the specified Pandas DataFrame in the console.



    ## Parameters

    - `df` - The Pandas DataFrame to display.

    Parameters:
    - `df` (term())

    Returns:
    - `nil`
    """
    @spec display_dataframe(term(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def display_dataframe(df, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :display_dataframe, [df], opts)
    end

    @doc """
    Obtain the HTML representation of the specified string.

    Parameters:
    - `x` (String.t())

    Returns:
    - `String.t()`
    """
    @spec html(String.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def html(x, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, "HTML", [x], opts)
    end

    @doc """
    Check if the current environment is an IPython notebook environment.

    :return: True if the current environment is an IPython notebook environment, False otherwise.

    Returns:
    - `term()`
    """
    @spec is_in_ipython_notebook_environment(keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def is_in_ipython_notebook_environment(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :is_in_ipython_notebook_environment, [], opts)
    end

    @doc """

    """
    @spec merge_dicts(term(), term(), keyword()) ::
            {:ok, %{optional(term()) => term()}} | {:error, Snakepit.Error.t()}
    def merge_dicts(d1, d2, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :merge_dicts, [d1, d2], opts)
    end

    @doc """

    """
    @spec prediction_is_dictlike(term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prediction_is_dictlike(prediction, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :prediction_is_dictlike, [prediction], opts)
    end

    @doc """
    Stylize the cell contents of a pandas DataFrame corresponding to the specified metric name.



    ## Parameters

    - `df` - The pandas DataFrame for which to stylize cell contents.
    - `metric_name` - The name of the metric for which to stylize DataFrame cell contents.

    Parameters:
    - `df` (term())
    - `metric_name` (String.t())

    Returns:
    - `term()`
    """
    @spec stylize_metric_name(term(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def stylize_metric_name(df, metric_name, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :stylize_metric_name, [df, metric_name], opts)
    end

    @doc """
    Truncate content of a cell to 25 words.

    Parameters:
    - `content` (term())

    Returns:
    - `String.t()`
    """
    @spec truncate_cell(term(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def truncate_cell(content, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :truncate_cell, [content], opts)
    end
  end

  defmodule Evaluate.Metrics do
    def __snakebridge_python_name__, do: "dspy.evaluate.metrics"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Evaluate exact match or F1-thresholded match for an example/prediction pair.

    If `example.answer` is a string, compare `pred.answer` against it. If it's a list,
    compare against any of the references. When `frac >= 1.0` (default), use EM;
    otherwise require that the maximum F1 across references is at least `frac`.

    ## Parameters

    - `example` - `dspy.Example` object with field `answer` (str or list[str]).
    - `pred` - `dspy.Prediction` object with field `answer` (str).
    - `trace` - Unused; reserved for compatibility.
    - `frac` - Threshold in [0.0, 1.0]. `1.0` means EM. (type: `float()`)

    ## Returns

    Returns `boolean()`. True if the match condition holds; otherwise False.

    ## Examples

      ```python
      import dspy

      example = dspy.Example(answer=["Eiffel Tower", "Louvre"])
      pred = dspy.Prediction(answer="The Eiffel Tower")

      answer_exact_match(example, pred, frac=1.0)  # equivalent to EM, True
      answer_exact_match(example, pred, frac=0.5)  # True
      ```

    Parameters:
    - `example` (term())
    - `pred` (term())
    - `trace` (term() default: None)
    - `frac` (term() default: 1.0)

    Returns:
    - `term()`
    """
    @spec answer_exact_match(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_exact_match(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_exact_match(term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_exact_match(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_exact_match(term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_exact_match(term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def answer_exact_match(example, pred) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_exact_match, [example, pred], [])
    end

    def answer_exact_match(example, pred, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_exact_match, [example, pred], opts)
    end

    def answer_exact_match(example, pred, trace) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_exact_match, [example, pred, trace], [])
    end

    def answer_exact_match(example, pred, trace, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_exact_match, [example, pred, trace], opts)
    end

    def answer_exact_match(example, pred, trace, frac) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_exact_match, [example, pred, trace, frac], [])
    end

    def answer_exact_match(example, pred, trace, frac, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :answer_exact_match,
        [example, pred, trace, frac],
        opts
      )
    end

    @doc """
    Return True if any passage in `pred.context` contains the answer(s).

    Strings are normalized (and passages also use DPR normalization internally).

    ## Parameters

    - `example` - `dspy.Example` object with field `answer` (str or list[str]).
    - `pred` - `dspy.Prediction` object with field `context` (list[str]) containing passages.
    - `trace` - Unused; reserved for compatibility.

    ## Returns

    Returns `boolean()`. True if any passage contains any reference answer; otherwise False.

    ## Examples

      ```python
      import dspy

      example = dspy.Example(answer="Eiffel Tower")
      pred = dspy.Prediction(context=["The Eiffel Tower is in Paris.", "..."])

      answer_passage_match(example, pred)  # True
      ```

    Parameters:
    - `example` (term())
    - `pred` (term())
    - `trace` (term() default: None)

    Returns:
    - `term()`
    """
    @spec answer_passage_match(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_passage_match(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_passage_match(term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec answer_passage_match(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def answer_passage_match(example, pred) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_passage_match, [example, pred], [])
    end

    def answer_passage_match(example, pred, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_passage_match, [example, pred], opts)
    end

    def answer_passage_match(example, pred, trace) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_passage_match, [example, pred, trace], [])
    end

    def answer_passage_match(example, pred, trace, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :answer_passage_match, [example, pred, trace], opts)
    end

    @doc """
    Compute the Exact Match (EM) metric between a prediction and reference answers.

    Returns True if any reference exactly matches the prediction after normalization;
    otherwise False. Normalization applies Unicode NFD, lowercasing, punctuation
    removal, English article removal ("a", "an", "the"), and whitespace collapse.

    ## Parameters

    - `prediction` - Predicted answer string. (type: `String.t()`)
    - `answers_list` - List of reference answers. (type: `list(String.t())`)

    ## Returns

    Returns `boolean()`. Whether any reference exactly equals the prediction after normalization.

    ## Examples

      ```python
      EM("The Eiffel Tower", ["Eiffel Tower", "Louvre"])  # True

      EM("paris", ["Paris"])  # True
      EM("paris", ["Paris, France"])  # False
      ```

    Parameters:
    - `prediction` (term())
    - `answers_list` (term())

    Returns:
    - `term()`
    """
    @spec em(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def em(prediction, answers_list, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, "EM", [prediction, answers_list], opts)
    end

    @doc """
    Compute boolean exact match after normalization.



    ## Parameters

    - `prediction` - Predicted answer. (type: `String.t()`)
    - `ground_truth` - Reference answer. (type: `String.t()`)

    ## Returns

    Returns `boolean()`. True if normalized strings are identical; otherwise False.

    ## Examples

      ```python
      em_score("Paris", "paris")  # True
      ```

    Parameters:
    - `prediction` (term())
    - `ground_truth` (term())

    Returns:
    - `term()`
    """
    @spec em_score(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def em_score(prediction, ground_truth, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :em_score, [prediction, ground_truth], opts)
    end

    @doc """
    Compute the maximum token-level F1 score against reference answers.

    Strings are normalized (same as in `EM`) and whitespace-tokenized. The function
    returns the maximum F1 over all provided references.

    ## Parameters

    - `prediction` - Predicted answer string. (type: `String.t()`)
    - `answers_list` - List of reference answers. (type: `list(String.t())`)

    ## Returns

    Returns `float()`. Highest F1 score in [0.0, 1.0].

    ## Examples

      ```python
      round(F1("Eiffel Tower is in Paris", ["Paris"]), 2)  # 0.33
      ```

    Parameters:
    - `prediction` (term())
    - `answers_list` (term())

    Returns:
    - `term()`
    """
    @spec f1(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def f1(prediction, answers_list, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, "F1", [prediction, answers_list], opts)
    end

    @doc """
    Compute token-level F1 between prediction and reference (after normalization).

    Strings are normalized (see `normalize_text`) and split by whitespace. F1 is
    computed from token precision and recall. If there is no token overlap, returns 0.
    If both sides are empty, a diagnostic message is printed; score remains 0.

    ## Parameters

    - `prediction` - Predicted answer. (type: `String.t()`)
    - `ground_truth` - Reference answer. (type: `String.t()`)

    ## Returns

    Returns `float()`. F1 score in [0.0, 1.0].

    ## Examples

      ```python
      round(f1_score("the Eiffel Tower", "Eiffel Tower"), 2)  # 1.0
      ```

    Parameters:
    - `prediction` (term())
    - `ground_truth` (term())

    Returns:
    - `term()`
    """
    @spec f1_score(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def f1_score(prediction, ground_truth, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :f1_score, [prediction, ground_truth], opts)
    end

    @doc """
    Compute the maximum HotPotQA-style F1 score against reference answers.

    Like `F1`, but if either normalized side is one of {"yes", "no", "noanswer"}
    and they differ, the score is 0. Otherwise, standard token-level F1 is used.

    ## Parameters

    - `prediction` - Predicted answer. (type: `String.t()`)
    - `answers_list` - List of reference answers. (type: `list(String.t())`)

    ## Returns

    Returns `float()`. Highest HotPotQA-style F1 in [0.0, 1.0].

    ## Examples

      ```python
      HotPotF1("yes", ["no"])  # 0.0
      ```

    Parameters:
    - `prediction` (term())
    - `answers_list` (term())

    Returns:
    - `term()`
    """
    @spec hot_pot_f1(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def hot_pot_f1(prediction, answers_list, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, "HotPotF1", [prediction, answers_list], opts)
    end

    @doc """
    Compute HotPotQA-style token F1 with special labels.

    If either normalized string is in {"yes", "no", "noanswer"} and they differ,
    the score is 0. Otherwise compute standard token F1 after normalization.

    ## Parameters

    - `prediction` - Predicted answer. (type: `String.t()`)
    - `ground_truth` - Reference answer. (type: `String.t()`)

    ## Returns

    Returns `float()`. HotPotQA-style F1 score in [0.0, 1.0].

    ## Examples

      ```python
      hotpot_f1_score("no", "yes")  # 0.0
      ```

    Parameters:
    - `prediction` (term())
    - `ground_truth` (term())

    Returns:
    - `term()`
    """
    @spec hotpot_f1_score(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def hotpot_f1_score(prediction, ground_truth, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :hotpot_f1_score, [prediction, ground_truth], opts)
    end

    @doc """
    Normalize text for string and token comparisons.

    Steps:
      1) Unicode NFD normalization
      2) lowercasing
      3) punctuation removal
      4) English article removal ("a", "an", "the")
      5) whitespace collapse

    ## Parameters

    - `s` - Input string. (type: `String.t()`)

    ## Returns

    Returns `String.t()`. Normalized string.

    ## Examples

      ```python
      normalize_text("The,  Eiffel  Tower!")  # "eiffel tower"
      ```

    Parameters:
    - `s` (term())

    Returns:
    - `term()`
    """
    @spec normalize_text(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def normalize_text(s, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :normalize_text, [s], opts)
    end

    @doc """
    Compute token-level precision of prediction against reference (after normalization).

    Precision is (# overlapping tokens) / (# tokens in prediction). If there is no
    token overlap, returns 0. If both sides are empty, a diagnostic message is printed;
    precision remains 0.

    ## Parameters

    - `prediction` - Predicted answer. (type: `String.t()`)
    - `ground_truth` - Reference answer. (type: `String.t()`)

    ## Returns

    Returns `float()`. Precision in [0.0, 1.0].

    ## Examples

      ```python
      precision_score("eiffel tower in paris", "eiffel tower")  # 0.67
      ```

    Parameters:
    - `prediction` (term())
    - `ground_truth` (term())

    Returns:
    - `term()`
    """
    @spec precision_score(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def precision_score(prediction, ground_truth, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :precision_score, [prediction, ground_truth], opts)
    end
  end

  defmodule Predict do
    def __snakebridge_python_name__, do: "dspy.predict"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Returns the most common completion for the target field (or the last field) in the signature.

    When normalize returns None, that completion is ignored.
    In case of a tie, earlier completion are prioritized.

    Parameters:
    - `prediction_or_completions` (term())
    - `normalize` (term() default: <function default_normalize at 0x79b21aa899e0>)
    - `field` (term() default: None)

    Returns:
    - `term()`
    """
    @spec majority(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec majority(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec majority(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec majority(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec majority(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec majority(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def majority(prediction_or_completions) do
      SnakeBridge.Runtime.call(__MODULE__, :majority, [prediction_or_completions], [])
    end

    def majority(prediction_or_completions, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :majority, [prediction_or_completions], opts)
    end

    def majority(prediction_or_completions, normalize) do
      SnakeBridge.Runtime.call(__MODULE__, :majority, [prediction_or_completions, normalize], [])
    end

    def majority(prediction_or_completions, normalize, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :majority,
        [prediction_or_completions, normalize],
        opts
      )
    end

    def majority(prediction_or_completions, normalize, field) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :majority,
        [prediction_or_completions, normalize, field],
        []
      )
    end

    def majority(prediction_or_completions, normalize, field, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :majority,
        [prediction_or_completions, normalize, field],
        opts
      )
    end
  end

  defmodule Predict.Aggregation do
    def __snakebridge_python_name__, do: "dspy.predict.aggregation"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec default_normalize(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def default_normalize(s, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :default_normalize, [s], opts)
    end

    @doc """
    Returns the most common completion for the target field (or the last field) in the signature.

    When normalize returns None, that completion is ignored.
    In case of a tie, earlier completion are prioritized.

    Parameters:
    - `prediction_or_completions` (term())
    - `normalize` (term() default: <function default_normalize at 0x79b21aa899e0>)
    - `field` (term() default: None)

    Returns:
    - `term()`
    """
    @spec majority(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec majority(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec majority(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec majority(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec majority(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec majority(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def majority(prediction_or_completions) do
      SnakeBridge.Runtime.call(__MODULE__, :majority, [prediction_or_completions], [])
    end

    def majority(prediction_or_completions, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :majority, [prediction_or_completions], opts)
    end

    def majority(prediction_or_completions, normalize) do
      SnakeBridge.Runtime.call(__MODULE__, :majority, [prediction_or_completions, normalize], [])
    end

    def majority(prediction_or_completions, normalize, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :majority,
        [prediction_or_completions, normalize],
        opts
      )
    end

    def majority(prediction_or_completions, normalize, field) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :majority,
        [prediction_or_completions, normalize, field],
        []
      )
    end

    def majority(prediction_or_completions, normalize, field, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :majority,
        [prediction_or_completions, normalize, field],
        opts
      )
    end
  end

  defmodule Predict.Avatar do
    def __snakebridge_python_name__, do: "dspy.predict.avatar"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec get_number_with_suffix(integer(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def get_number_with_suffix(number, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_number_with_suffix, [number], opts)
    end
  end

  defmodule Predict.Avatar.Avatar do
    def __snakebridge_python_name__, do: "dspy.predict.avatar.avatar"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec get_number_with_suffix(integer(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def get_number_with_suffix(number, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_number_with_suffix, [number], opts)
    end
  end

  defmodule Predict.Predict do
    def __snakebridge_python_name__, do: "dspy.predict.predict"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Recursively serialize a given object into a JSON-compatible format.

    Supports Pydantic models, lists, dicts, and primitive types.

    Parameters:
    - `obj` (term())

    Returns:
    - `term()`
    """
    @spec serialize_object(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_object(obj, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :serialize_object, [obj], opts)
    end
  end

  defmodule Predict.Refine do
    def __snakebridge_python_name__, do: "dspy.predict.refine"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec inspect_modules(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_modules(program, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :inspect_modules, [program], opts)
    end

    @doc """

    """
    @spec recursive_mask(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def recursive_mask(o, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :recursive_mask, [o], opts)
    end
  end

  defmodule Primitives.Module do
    def __snakebridge_python_name__, do: "dspy.primitives.module"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec set_attribute_by_name(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_attribute_by_name(obj, name, value, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :set_attribute_by_name, [obj, name, value], opts)
    end
  end

  defmodule Propose.DatasetSummaryGenerator do
    def __snakebridge_python_name__, do: "dspy.propose.dataset_summary_generator"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec create_dataset_summary(term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_dataset_summary(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_dataset_summary(term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_dataset_summary(term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_dataset_summary(term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_dataset_summary(term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def create_dataset_summary(trainset, view_data_batch_size, prompt_model) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_dataset_summary,
        [trainset, view_data_batch_size, prompt_model],
        []
      )
    end

    def create_dataset_summary(trainset, view_data_batch_size, prompt_model, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_dataset_summary,
        [trainset, view_data_batch_size, prompt_model],
        opts
      )
    end

    def create_dataset_summary(trainset, view_data_batch_size, prompt_model, log_file) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_dataset_summary,
        [trainset, view_data_batch_size, prompt_model, log_file],
        []
      )
    end

    def create_dataset_summary(trainset, view_data_batch_size, prompt_model, log_file, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_dataset_summary,
        [trainset, view_data_batch_size, prompt_model, log_file],
        opts
      )
    end

    def create_dataset_summary(trainset, view_data_batch_size, prompt_model, log_file, verbose) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_dataset_summary,
        [trainset, view_data_batch_size, prompt_model, log_file, verbose],
        []
      )
    end

    def create_dataset_summary(
          trainset,
          view_data_batch_size,
          prompt_model,
          log_file,
          verbose,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_dataset_summary,
        [trainset, view_data_batch_size, prompt_model, log_file, verbose],
        opts
      )
    end

    @doc """

    """
    @spec order_input_keys_in_string(term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def order_input_keys_in_string(unordered_repr, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :order_input_keys_in_string, [unordered_repr], opts)
    end
  end

  defmodule Propose.GroundedProposer do
    def __snakebridge_python_name__, do: "dspy.propose.grounded_proposer"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec generate_instruction_class() :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec generate_instruction_class(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec generate_instruction_class(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec generate_instruction_class(term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec generate_instruction_class(term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec generate_instruction_class(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec generate_instruction_class(term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec generate_instruction_class(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec generate_instruction_class(term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec generate_instruction_class(term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec generate_instruction_class(term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec generate_instruction_class(term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def generate_instruction_class() do
      SnakeBridge.Runtime.call(__MODULE__, :generate_instruction_class, [], [])
    end

    def generate_instruction_class(opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :generate_instruction_class, [], opts)
    end

    def generate_instruction_class(use_dataset_summary) do
      SnakeBridge.Runtime.call(__MODULE__, :generate_instruction_class, [use_dataset_summary], [])
    end

    def generate_instruction_class(use_dataset_summary, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :generate_instruction_class,
        [use_dataset_summary],
        opts
      )
    end

    def generate_instruction_class(use_dataset_summary, program_aware) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :generate_instruction_class,
        [use_dataset_summary, program_aware],
        []
      )
    end

    def generate_instruction_class(use_dataset_summary, program_aware, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :generate_instruction_class,
        [use_dataset_summary, program_aware],
        opts
      )
    end

    def generate_instruction_class(use_dataset_summary, program_aware, use_task_demos) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :generate_instruction_class,
        [use_dataset_summary, program_aware, use_task_demos],
        []
      )
    end

    def generate_instruction_class(use_dataset_summary, program_aware, use_task_demos, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :generate_instruction_class,
        [use_dataset_summary, program_aware, use_task_demos],
        opts
      )
    end

    def generate_instruction_class(
          use_dataset_summary,
          program_aware,
          use_task_demos,
          use_instruct_history
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :generate_instruction_class,
        [use_dataset_summary, program_aware, use_task_demos, use_instruct_history],
        []
      )
    end

    def generate_instruction_class(
          use_dataset_summary,
          program_aware,
          use_task_demos,
          use_instruct_history,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :generate_instruction_class,
        [use_dataset_summary, program_aware, use_task_demos, use_instruct_history],
        opts
      )
    end

    def generate_instruction_class(
          use_dataset_summary,
          program_aware,
          use_task_demos,
          use_instruct_history,
          use_tip
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :generate_instruction_class,
        [use_dataset_summary, program_aware, use_task_demos, use_instruct_history, use_tip],
        []
      )
    end

    def generate_instruction_class(
          use_dataset_summary,
          program_aware,
          use_task_demos,
          use_instruct_history,
          use_tip,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :generate_instruction_class,
        [use_dataset_summary, program_aware, use_task_demos, use_instruct_history, use_tip],
        opts
      )
    end
  end

  defmodule Propose.Utils do
    def __snakebridge_python_name__, do: "dspy.propose.utils"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec create_example_string(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def create_example_string(fields, example, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :create_example_string, [fields, example], opts)
    end

    @doc """

    """
    @spec create_instruction_set_history_string(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def create_instruction_set_history_string(base_program, trial_logs, top_n, opts \\ []) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_instruction_set_history_string,
        [base_program, trial_logs, top_n],
        opts
      )
    end

    @doc """

    """
    @spec create_predictor_level_history_string(term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def create_predictor_level_history_string(
          base_program,
          predictor_i,
          trial_logs,
          top_n,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_predictor_level_history_string,
        [base_program, predictor_i, trial_logs, top_n],
        opts
      )
    end

    @doc """

    """
    @spec get_dspy_source_code(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_dspy_source_code(module, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_dspy_source_code, [module], opts)
    end

    @doc """

    """
    @spec get_program_instruction_set_string(term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_program_instruction_set_string(program, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_program_instruction_set_string, [program], opts)
    end

    @doc """

    """
    @spec parse_list_of_instructions(term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_list_of_instructions(instruction_string, opts \\ []) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :parse_list_of_instructions,
        [instruction_string],
        opts
      )
    end

    @doc """

    """
    @spec strip_prefix(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def strip_prefix(text, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :strip_prefix, [text], opts)
    end
  end

  defmodule Retrievers.Retrieve do
    def __snakebridge_python_name__, do: "dspy.retrievers.retrieve"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec single_query_passage(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def single_query_passage(passages, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :single_query_passage, [passages], opts)
    end
  end

  defmodule Signatures do
    def __snakebridge_python_name__, do: "dspy.signatures"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec ensure_signature(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec ensure_signature(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec ensure_signature(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec ensure_signature(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def ensure_signature(signature) do
      SnakeBridge.Runtime.call(__MODULE__, :ensure_signature, [signature], [])
    end

    def ensure_signature(signature, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :ensure_signature, [signature], opts)
    end

    def ensure_signature(signature, instructions) do
      SnakeBridge.Runtime.call(__MODULE__, :ensure_signature, [signature, instructions], [])
    end

    def ensure_signature(signature, instructions, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :ensure_signature, [signature, instructions], opts)
    end

    @doc """
    Infer a prefix from an attribute name by converting it to a human-readable format.



    ## Examples

      "camelCaseText" -> "Camel Case Text"
      "snake_case_text" -> "Snake Case Text"
      "text2number" -> "Text 2 Number"
      "HTMLParser" -> "HTML Parser"

    Parameters:
    - `attribute_name` (String.t())

    Returns:
    - `String.t()`
    """
    @spec infer_prefix(String.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def infer_prefix(attribute_name, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :infer_prefix, [attribute_name], opts)
    end

    @doc """

    """
    @spec input_field(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def input_field(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, "InputField", [], opts)
    end

    @doc """
    Create a new Signature subclass with the specified fields and instructions.



    ## Parameters

    - `signature` - Either a string in the format "input1, input2 -> output1, output2" or a dictionary mapping field names to tuples of (type, FieldInfo).
    - `instructions` - Optional string containing instructions/prompt for the signature. If not provided, defaults to a basic description of inputs and outputs.
    - `signature_name` - Optional string to name the generated Signature subclass. Defaults to "StringSignature".
    - `custom_types` - Optional dictionary mapping type names to their actual type objects. Useful for resolving custom types that aren't built-ins or in the typing module.

    Parameters:
    - `signature` (term())
    - `instructions` (term() default: None)
    - `signature_name` (String.t() default: 'StringSignature')
    - `custom_types` (term() default: None)

    Returns:
    - `term()`
    """
    @spec make_signature(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), term(), String.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), term(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), term(), String.t(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), term(), String.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def make_signature(signature) do
      SnakeBridge.Runtime.call(__MODULE__, :make_signature, [signature], [])
    end

    def make_signature(signature, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :make_signature, [signature], opts)
    end

    def make_signature(signature, instructions) do
      SnakeBridge.Runtime.call(__MODULE__, :make_signature, [signature, instructions], [])
    end

    def make_signature(signature, instructions, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :make_signature, [signature, instructions], opts)
    end

    def make_signature(signature, instructions, signature_name) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :make_signature,
        [signature, instructions, signature_name],
        []
      )
    end

    def make_signature(signature, instructions, signature_name, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :make_signature,
        [signature, instructions, signature_name],
        opts
      )
    end

    def make_signature(signature, instructions, signature_name, custom_types) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :make_signature,
        [signature, instructions, signature_name, custom_types],
        []
      )
    end

    def make_signature(signature, instructions, signature_name, custom_types, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :make_signature,
        [signature, instructions, signature_name, custom_types],
        opts
      )
    end

    @doc """

    """
    @spec output_field(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def output_field(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, "OutputField", [], opts)
    end
  end

  defmodule Signatures.Field do
    def __snakebridge_python_name__, do: "dspy.signatures.field"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec input_field(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def input_field(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, "InputField", [], opts)
    end

    @doc """

    """
    @spec move_kwargs(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def move_kwargs(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :move_kwargs, [], opts)
    end

    @doc """

    """
    @spec new_to_old_field(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def new_to_old_field(field, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :new_to_old_field, [field], opts)
    end

    @doc """

    """
    @spec output_field(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def output_field(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, "OutputField", [], opts)
    end
  end

  defmodule Signatures.Signature do
    def __snakebridge_python_name__, do: "dspy.signatures.signature"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Signature class for DSPy.

    You typically subclass the Signature class, like this:
      class MySignature(dspy.Signature):
          input: str = InputField(desc="...")
          output: int = OutputField(desc="...")

    You can call Signature("input1, input2 -> output1, output2") to create a new signature type.
    You can also include instructions, Signature("input -> output", "This is a test").
    But it's generally better to use the make_signature function.

    If you are not sure if your input is a string representation, (like "input1, input2 -> output1, output2"),
    or a signature, you can use the ensure_signature function.

    For compatibility with the legacy dsp format, you can use the signature_to_template function.

    Parameters:
    - `signature` (term())
    - `instructions` (term() default: None)

    Returns:
    - `term()`
    """
    @spec ensure_signature(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec ensure_signature(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec ensure_signature(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec ensure_signature(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def ensure_signature(signature) do
      SnakeBridge.Runtime.call(__MODULE__, :ensure_signature, [signature], [])
    end

    def ensure_signature(signature, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :ensure_signature, [signature], opts)
    end

    def ensure_signature(signature, instructions) do
      SnakeBridge.Runtime.call(__MODULE__, :ensure_signature, [signature, instructions], [])
    end

    def ensure_signature(signature, instructions, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :ensure_signature, [signature, instructions], opts)
    end

    @doc """
    Infer a prefix from an attribute name by converting it to a human-readable format.



    ## Examples

      "camelCaseText" -> "Camel Case Text"
      "snake_case_text" -> "Snake Case Text"
      "text2number" -> "Text 2 Number"
      "HTMLParser" -> "HTML Parser"

    Parameters:
    - `attribute_name` (String.t())

    Returns:
    - `String.t()`
    """
    @spec infer_prefix(String.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def infer_prefix(attribute_name, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :infer_prefix, [attribute_name], opts)
    end

    @doc """
    Create a new Signature subclass with the specified fields and instructions.



    ## Parameters

    - `signature` - Either a string in the format "input1, input2 -> output1, output2" or a dictionary mapping field names to tuples of (type, FieldInfo).
    - `instructions` - Optional string containing instructions/prompt for the signature. If not provided, defaults to a basic description of inputs and outputs.
    - `signature_name` - Optional string to name the generated Signature subclass. Defaults to "StringSignature".
    - `custom_types` - Optional dictionary mapping type names to their actual type objects. Useful for resolving custom types that aren't built-ins or in the typing module.

    Parameters:
    - `signature` (term())
    - `instructions` (term() default: None)
    - `signature_name` (String.t() default: 'StringSignature')
    - `custom_types` (term() default: None)

    Returns:
    - `term()`
    """
    @spec make_signature(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), term(), String.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), term(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), term(), String.t(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec make_signature(term(), term(), String.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def make_signature(signature) do
      SnakeBridge.Runtime.call(__MODULE__, :make_signature, [signature], [])
    end

    def make_signature(signature, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :make_signature, [signature], opts)
    end

    def make_signature(signature, instructions) do
      SnakeBridge.Runtime.call(__MODULE__, :make_signature, [signature, instructions], [])
    end

    def make_signature(signature, instructions, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :make_signature, [signature, instructions], opts)
    end

    def make_signature(signature, instructions, signature_name) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :make_signature,
        [signature, instructions, signature_name],
        []
      )
    end

    def make_signature(signature, instructions, signature_name, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :make_signature,
        [signature, instructions, signature_name],
        opts
      )
    end

    def make_signature(signature, instructions, signature_name, custom_types) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :make_signature,
        [signature, instructions, signature_name, custom_types],
        []
      )
    end

    def make_signature(signature, instructions, signature_name, custom_types, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :make_signature,
        [signature, instructions, signature_name, custom_types],
        opts
      )
    end
  end

  defmodule Signatures.Utils do
    def __snakebridge_python_name__, do: "dspy.signatures.utils"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec get_dspy_field_type(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_dspy_field_type(field, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_dspy_field_type, [field], opts)
    end
  end

  defmodule Streaming do
    def __snakebridge_python_name__, do: "dspy.streaming"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Convert the async streaming generator to a sync generator.

    Parameters:
    - `async_generator` (term())

    Returns:
    - `term()`
    """
    @spec apply_sync_streaming(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def apply_sync_streaming(async_generator, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :apply_sync_streaming, [async_generator], opts)
    end

    @doc """
    Wrap a DSPy program so that it streams its outputs incrementally, rather than returning them

    all at once. It also provides status messages to the user to indicate the progress of the program, and users
    can implement their own status message provider to customize the status messages and what module to generate
    status messages for.

    ## Parameters

    - `program` - The DSPy program to wrap with streaming functionality.
    - `status_message_provider` - A custom status message generator to use instead of the default one. Users can implement their own status message generator to customize the status messages and what module to generate status messages for.
    - `stream_listeners` - A list of stream listeners to capture the streaming output of specific fields of sub predicts in the program. When provided, only the target fields in the target predict will be streamed to the user.
    - `include_final_prediction_in_output_stream` - Whether to include the final prediction in the output stream, only useful when `stream_listeners` is provided. If `False`, the final prediction will not be included in the output stream. When the program hit cache, or no listeners captured anything, the final prediction will still be included in the output stream even if this is `False`.
    - `is_async_program` - Whether the program is async. If `False`, the program will be wrapped with `asyncify`, otherwise the program will be called with `acall`.
    - `async_streaming` - Whether to return an async generator or a sync generator. If `False`, the streaming will be converted to a sync generator.

    Parameters:
    - `program` (term())
    - `status_message_provider` (term() default: None)
    - `stream_listeners` (term() default: None)
    - `include_final_prediction_in_output_stream` (boolean() default: True)
    - `is_async_program` (boolean() default: False)
    - `async_streaming` (boolean() default: True)

    Returns:
    - `term()`
    """
    @spec streamify(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), boolean()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), boolean(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), boolean(), boolean()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), boolean(), boolean(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), boolean(), boolean(), boolean()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), boolean(), boolean(), boolean(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def streamify(program) do
      SnakeBridge.Runtime.call(__MODULE__, :streamify, [program], [])
    end

    def streamify(program, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :streamify, [program], opts)
    end

    def streamify(program, status_message_provider) do
      SnakeBridge.Runtime.call(__MODULE__, :streamify, [program, status_message_provider], [])
    end

    def streamify(program, status_message_provider, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :streamify, [program, status_message_provider], opts)
    end

    def streamify(program, status_message_provider, stream_listeners) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [program, status_message_provider, stream_listeners],
        []
      )
    end

    def streamify(program, status_message_provider, stream_listeners, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [program, status_message_provider, stream_listeners],
        opts
      )
    end

    def streamify(
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream
        ],
        []
      )
    end

    def streamify(
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream
        ],
        opts
      )
    end

    def streamify(
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program
        ],
        []
      )
    end

    def streamify(
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program
        ],
        opts
      )
    end

    def streamify(
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program,
          async_streaming
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program,
          async_streaming
        ],
        []
      )
    end

    def streamify(
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program,
          async_streaming,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program,
          async_streaming
        ],
        opts
      )
    end

    @doc """
    Convert a DSPy program output stream to an OpenAI-compatible output stream that can be

    used by a service as an API response to a streaming request.

    ## Parameters

    - `streamer` - An async generator that yields values from a DSPy program output stream.

    Parameters:
    - `streamer` (term())

    Returns:
    - `term()`
    """
    @spec streaming_response(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def streaming_response(streamer, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :streaming_response, [streamer], opts)
    end
  end

  defmodule Streaming.Messages do
    def __snakebridge_python_name__, do: "dspy.streaming.messages"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Send message to stream in a sync context, regardless of event loop state.

    Parameters:
    - `stream` (term())
    - `message` (term())

    Returns:
    - `term()`
    """
    @spec sync_send_to_stream(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def sync_send_to_stream(stream, message, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :sync_send_to_stream, [stream, message], opts)
    end
  end

  defmodule Streaming.Streamify do
    def __snakebridge_python_name__, do: "dspy.streaming.streamify"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Convert the async streaming generator to a sync generator.

    Parameters:
    - `async_generator` (term())

    Returns:
    - `term()`
    """
    @spec apply_sync_streaming(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def apply_sync_streaming(async_generator, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :apply_sync_streaming, [async_generator], opts)
    end

    @doc """
    Wrap a DSPy program so that it streams its outputs incrementally, rather than returning them

    all at once. It also provides status messages to the user to indicate the progress of the program, and users
    can implement their own status message provider to customize the status messages and what module to generate
    status messages for.

    ## Parameters

    - `program` - The DSPy program to wrap with streaming functionality.
    - `status_message_provider` - A custom status message generator to use instead of the default one. Users can implement their own status message generator to customize the status messages and what module to generate status messages for.
    - `stream_listeners` - A list of stream listeners to capture the streaming output of specific fields of sub predicts in the program. When provided, only the target fields in the target predict will be streamed to the user.
    - `include_final_prediction_in_output_stream` - Whether to include the final prediction in the output stream, only useful when `stream_listeners` is provided. If `False`, the final prediction will not be included in the output stream. When the program hit cache, or no listeners captured anything, the final prediction will still be included in the output stream even if this is `False`.
    - `is_async_program` - Whether the program is async. If `False`, the program will be wrapped with `asyncify`, otherwise the program will be called with `acall`.
    - `async_streaming` - Whether to return an async generator or a sync generator. If `False`, the streaming will be converted to a sync generator.

    Parameters:
    - `program` (term())
    - `status_message_provider` (term() default: None)
    - `stream_listeners` (term() default: None)
    - `include_final_prediction_in_output_stream` (boolean() default: True)
    - `is_async_program` (boolean() default: False)
    - `async_streaming` (boolean() default: True)

    Returns:
    - `term()`
    """
    @spec streamify(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), boolean()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), boolean(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), boolean(), boolean()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), boolean(), boolean(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), boolean(), boolean(), boolean()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec streamify(term(), term(), term(), boolean(), boolean(), boolean(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def streamify(program) do
      SnakeBridge.Runtime.call(__MODULE__, :streamify, [program], [])
    end

    def streamify(program, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :streamify, [program], opts)
    end

    def streamify(program, status_message_provider) do
      SnakeBridge.Runtime.call(__MODULE__, :streamify, [program, status_message_provider], [])
    end

    def streamify(program, status_message_provider, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :streamify, [program, status_message_provider], opts)
    end

    def streamify(program, status_message_provider, stream_listeners) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [program, status_message_provider, stream_listeners],
        []
      )
    end

    def streamify(program, status_message_provider, stream_listeners, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [program, status_message_provider, stream_listeners],
        opts
      )
    end

    def streamify(
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream
        ],
        []
      )
    end

    def streamify(
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream
        ],
        opts
      )
    end

    def streamify(
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program
        ],
        []
      )
    end

    def streamify(
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program
        ],
        opts
      )
    end

    def streamify(
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program,
          async_streaming
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program,
          async_streaming
        ],
        []
      )
    end

    def streamify(
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program,
          async_streaming,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :streamify,
        [
          program,
          status_message_provider,
          stream_listeners,
          include_final_prediction_in_output_stream,
          is_async_program,
          async_streaming
        ],
        opts
      )
    end

    @doc """
    Convert a DSPy program output stream to an OpenAI-compatible output stream that can be

    used by a service as an API response to a streaming request.

    ## Parameters

    - `streamer` - An async generator that yields values from a DSPy program output stream.

    Parameters:
    - `streamer` (term())

    Returns:
    - `term()`
    """
    @spec streaming_response(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def streaming_response(streamer, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :streaming_response, [streamer], opts)
    end
  end

  defmodule Streaming.StreamingListener do
    def __snakebridge_python_name__, do: "dspy.streaming.streaming_listener"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Find the predictor for each stream listener.

    This is a utility function to automatically find the predictor for each stream listener. It is used when some
    listeners don't specify the predictor they want to listen to. If a listener's `signature_field_name` is not
    unique in the program, this function will raise an error.

    Parameters:
    - `program` (term())
    - `stream_listeners` (list(Dspy.Streaming.StreamingListener.StreamListener.t()))

    Returns:
    - `%{optional(integer()) => list(Dspy.Streaming.StreamingListener.StreamListener.t())}`
    """
    @spec find_predictor_for_stream_listeners(
            term(),
            list(Dspy.Streaming.StreamingListener.StreamListener.t()),
            keyword()
          ) ::
            {:ok,
             %{optional(integer()) => list(Dspy.Streaming.StreamingListener.StreamListener.t())}}
            | {:error, Snakepit.Error.t()}
    def find_predictor_for_stream_listeners(program, stream_listeners, opts \\ []) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :find_predictor_for_stream_listeners,
        [program, stream_listeners],
        opts
      )
    end
  end

  defmodule Teleprompt do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t())
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            float()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            float(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            float(),
            boolean()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            float(),
            boolean(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            float(),
            boolean(),
            term()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            float(),
            boolean(),
            term(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    def bootstrap_trace_data(program, dataset) do
      SnakeBridge.Runtime.call(__MODULE__, :bootstrap_trace_data, [program, dataset], [])
    end

    def bootstrap_trace_data(program, dataset, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :bootstrap_trace_data, [program, dataset], opts)
    end

    def bootstrap_trace_data(program, dataset, metric) do
      SnakeBridge.Runtime.call(__MODULE__, :bootstrap_trace_data, [program, dataset, metric], [])
    end

    def bootstrap_trace_data(program, dataset, metric, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric],
        opts
      )
    end

    def bootstrap_trace_data(program, dataset, metric, num_threads) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric, num_threads],
        []
      )
    end

    def bootstrap_trace_data(program, dataset, metric, num_threads, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric, num_threads],
        opts
      )
    end

    def bootstrap_trace_data(program, dataset, metric, num_threads, raise_on_error) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric, num_threads, raise_on_error],
        []
      )
    end

    def bootstrap_trace_data(program, dataset, metric, num_threads, raise_on_error, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric, num_threads, raise_on_error],
        opts
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric, num_threads, raise_on_error, capture_failed_parses],
        []
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric, num_threads, raise_on_error, capture_failed_parses],
        opts
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score
        ],
        []
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score
        ],
        opts
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score
        ],
        []
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score
        ],
        opts
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures
        ],
        []
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures
        ],
        opts
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures,
          callback_metadata
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures,
          callback_metadata
        ],
        []
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures,
          callback_metadata,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures,
          callback_metadata
        ],
        opts
      )
    end
  end

  defmodule Teleprompt.BootstrapFinetune do
    def __snakebridge_python_name__, do: "dspy.teleprompt.bootstrap_finetune"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Return True if all predictors in the program have an LM set.

    Parameters:
    - `program` (Dspy.Primitives.Module.Module.t())

    Returns:
    - `boolean()`
    """
    @spec all_predictors_have_lms(Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def all_predictors_have_lms(program, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :all_predictors_have_lms, [program], opts)
    end

    @doc """

    """
    @spec assert_no_shared_predictor(
            Dspy.Primitives.Module.Module.t(),
            Dspy.Primitives.Module.Module.t(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def assert_no_shared_predictor(program1, program2, opts \\ []) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :assert_no_shared_predictor,
        [program1, program2],
        opts
      )
    end

    @doc """

    """
    @spec assert_structural_equivalency(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def assert_structural_equivalency(program1, program2, opts \\ []) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :assert_structural_equivalency,
        [program1, program2],
        opts
      )
    end

    @doc """

    """
    @spec build_call_data_from_trace(
            list(%{optional(term()) => term()}),
            integer(),
            Dspy.Adapters.Base.Adapter.t()
          ) ::
            {:ok, %{optional(String.t()) => list(%{optional(String.t()) => term()})}}
            | {:error, Snakepit.Error.t()}
    @spec build_call_data_from_trace(
            list(%{optional(term()) => term()}),
            integer(),
            Dspy.Adapters.Base.Adapter.t(),
            keyword()
          ) ::
            {:ok, %{optional(String.t()) => list(%{optional(String.t()) => term()})}}
            | {:error, Snakepit.Error.t()}
    @spec build_call_data_from_trace(
            list(%{optional(term()) => term()}),
            integer(),
            Dspy.Adapters.Base.Adapter.t(),
            boolean()
          ) ::
            {:ok, %{optional(String.t()) => list(%{optional(String.t()) => term()})}}
            | {:error, Snakepit.Error.t()}
    @spec build_call_data_from_trace(
            list(%{optional(term()) => term()}),
            integer(),
            Dspy.Adapters.Base.Adapter.t(),
            boolean(),
            keyword()
          ) ::
            {:ok, %{optional(String.t()) => list(%{optional(String.t()) => term()})}}
            | {:error, Snakepit.Error.t()}
    def build_call_data_from_trace(trace, pred_ind, adapter) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :build_call_data_from_trace,
        [trace, pred_ind, adapter],
        []
      )
    end

    def build_call_data_from_trace(trace, pred_ind, adapter, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :build_call_data_from_trace,
        [trace, pred_ind, adapter],
        opts
      )
    end

    def build_call_data_from_trace(trace, pred_ind, adapter, exclude_demos) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :build_call_data_from_trace,
        [trace, pred_ind, adapter, exclude_demos],
        []
      )
    end

    def build_call_data_from_trace(trace, pred_ind, adapter, exclude_demos, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :build_call_data_from_trace,
        [trace, pred_ind, adapter, exclude_demos],
        opts
      )
    end

    @doc """

    """
    @spec copy_program_with_lms(Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def copy_program_with_lms(program, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :copy_program_with_lms, [program], opts)
    end

    @doc """

    """
    @spec get_unique_lms(Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, list(Dspy.Clients.LMClass.t())} | {:error, Snakepit.Error.t()}
    def get_unique_lms(program, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_unique_lms, [program], opts)
    end

    @doc """

    """
    @spec kill_lms(Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill_lms(program, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :kill_lms, [program], opts)
    end

    @doc """

    """
    @spec launch_lms(Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch_lms(program, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :launch_lms, [program], opts)
    end

    @doc """

    """
    @spec prepare_student(Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def prepare_student(student, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :prepare_student, [student], opts)
    end

    @doc """

    """
    @spec prepare_teacher(Dspy.Primitives.Module.Module.t()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    @spec prepare_teacher(Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    @spec prepare_teacher(Dspy.Primitives.Module.Module.t(), term()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    @spec prepare_teacher(Dspy.Primitives.Module.Module.t(), term(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def prepare_teacher(student) do
      SnakeBridge.Runtime.call(__MODULE__, :prepare_teacher, [student], [])
    end

    def prepare_teacher(student, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :prepare_teacher, [student], opts)
    end

    def prepare_teacher(student, teacher) do
      SnakeBridge.Runtime.call(__MODULE__, :prepare_teacher, [student, teacher], [])
    end

    def prepare_teacher(student, teacher, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :prepare_teacher, [student, teacher], opts)
    end
  end

  defmodule Teleprompt.BootstrapTrace do
    def __snakebridge_python_name__, do: "dspy.teleprompt.bootstrap_trace"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t())
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            float()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            float(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            float(),
            boolean()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            float(),
            boolean(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            float(),
            boolean(),
            term()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    @spec bootstrap_trace_data(
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            term() | nil,
            term(),
            term(),
            term(),
            float(),
            float(),
            boolean(),
            term(),
            keyword()
          ) ::
            {:ok, list(Dspy.Teleprompt.BootstrapTrace.TraceData.t())}
            | {:error, Snakepit.Error.t()}
    def bootstrap_trace_data(program, dataset) do
      SnakeBridge.Runtime.call(__MODULE__, :bootstrap_trace_data, [program, dataset], [])
    end

    def bootstrap_trace_data(program, dataset, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :bootstrap_trace_data, [program, dataset], opts)
    end

    def bootstrap_trace_data(program, dataset, metric) do
      SnakeBridge.Runtime.call(__MODULE__, :bootstrap_trace_data, [program, dataset, metric], [])
    end

    def bootstrap_trace_data(program, dataset, metric, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric],
        opts
      )
    end

    def bootstrap_trace_data(program, dataset, metric, num_threads) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric, num_threads],
        []
      )
    end

    def bootstrap_trace_data(program, dataset, metric, num_threads, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric, num_threads],
        opts
      )
    end

    def bootstrap_trace_data(program, dataset, metric, num_threads, raise_on_error) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric, num_threads, raise_on_error],
        []
      )
    end

    def bootstrap_trace_data(program, dataset, metric, num_threads, raise_on_error, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric, num_threads, raise_on_error],
        opts
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric, num_threads, raise_on_error, capture_failed_parses],
        []
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [program, dataset, metric, num_threads, raise_on_error, capture_failed_parses],
        opts
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score
        ],
        []
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score
        ],
        opts
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score
        ],
        []
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score
        ],
        opts
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures
        ],
        []
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures
        ],
        opts
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures,
          callback_metadata
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures,
          callback_metadata
        ],
        []
      )
    end

    def bootstrap_trace_data(
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures,
          callback_metadata,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :bootstrap_trace_data,
        [
          program,
          dataset,
          metric,
          num_threads,
          raise_on_error,
          capture_failed_parses,
          failure_score,
          format_failure_score,
          log_format_failures,
          callback_metadata
        ],
        opts
      )
    end
  end

  defmodule Teleprompt.Grpo do
    def __snakebridge_python_name__, do: "dspy.teleprompt.grpo"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Disable the LM cache for all predictors in the program.

    Parameters:
    - `program` (Dspy.Primitives.Module.Module.t())
    - `lm_cache_dict` (%{optional(term()) => term()})

    Returns:
    - `term()`
    """
    @spec disable_lm_cache(
            Dspy.Primitives.Module.Module.t(),
            %{optional(term()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def disable_lm_cache(program, lm_cache_dict, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :disable_lm_cache, [program, lm_cache_dict], opts)
    end

    @doc """
    Recover the LM caches for all predictors in the program to their original state.

    Parameters:
    - `program` (Dspy.Primitives.Module.Module.t())
    - `lm_cache_dict` (%{optional(term()) => term()})

    Returns:
    - `term()`
    """
    @spec recover_lm_cache(
            Dspy.Primitives.Module.Module.t(),
            %{optional(term()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def recover_lm_cache(program, lm_cache_dict, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :recover_lm_cache, [program, lm_cache_dict], opts)
    end
  end

  defmodule Teleprompt.SimbaUtils do
    def __snakebridge_python_name__, do: "dspy.teleprompt.simba_utils"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec append_a_demo(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def append_a_demo(demo_input_field_maxlen, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :append_a_demo, [demo_input_field_maxlen], opts)
    end

    @doc """

    """
    @spec append_a_rule(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def append_a_rule(bucket, system, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :append_a_rule, [bucket, system], opts)
    end

    @doc """

    """
    @spec inspect_modules(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_modules(program, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :inspect_modules, [program], opts)
    end

    @doc """

    """
    @spec prepare_models_for_resampling(Dspy.Primitives.Module.Module.t(), integer()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec prepare_models_for_resampling(Dspy.Primitives.Module.Module.t(), integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec prepare_models_for_resampling(Dspy.Primitives.Module.Module.t(), integer(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec prepare_models_for_resampling(
            Dspy.Primitives.Module.Module.t(),
            integer(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepare_models_for_resampling(program, n) do
      SnakeBridge.Runtime.call(__MODULE__, :prepare_models_for_resampling, [program, n], [])
    end

    def prepare_models_for_resampling(program, n, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :prepare_models_for_resampling, [program, n], opts)
    end

    def prepare_models_for_resampling(program, n, teacher_settings) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :prepare_models_for_resampling,
        [program, n, teacher_settings],
        []
      )
    end

    def prepare_models_for_resampling(program, n, teacher_settings, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :prepare_models_for_resampling,
        [program, n, teacher_settings],
        opts
      )
    end

    @doc """

    """
    @spec recursive_mask(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def recursive_mask(o, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :recursive_mask, [o], opts)
    end

    @doc """

    """
    @spec wrap_program(Dspy.Primitives.Module.Module.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def wrap_program(program, metric, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :wrap_program, [program, metric], opts)
    end
  end

  defmodule Teleprompt.Utils do
    def __snakebridge_python_name__, do: "dspy.teleprompt.utils"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Calculate the average and best quality of the last n programs proposed. This is useful for seeing if our proposals

    are actually 'improving' overtime or not.

    Parameters:
    - `base_program` (term())
    - `trial_logs` (term())
    - `evaluate` (term())
    - `trainset` (term())
    - `devset` (term())
    - `n` (term())

    Returns:
    - `term()`
    """
    @spec calculate_last_n_proposed_quality(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def calculate_last_n_proposed_quality(
          base_program,
          trial_logs,
          evaluate,
          trainset,
          devset,
          n,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :calculate_last_n_proposed_quality,
        [base_program, trial_logs, evaluate, trainset, devset, n],
        opts
      )
    end

    @doc """
    Create a minibatch from the trainset.

    Parameters:
    - `trainset` (term())
    - `batch_size` (term() default: 50)
    - `rng` (term() default: None)

    Returns:
    - `term()`
    """
    @spec create_minibatch(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_minibatch(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_minibatch(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_minibatch(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_minibatch(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_minibatch(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def create_minibatch(trainset) do
      SnakeBridge.Runtime.call(__MODULE__, :create_minibatch, [trainset], [])
    end

    def create_minibatch(trainset, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :create_minibatch, [trainset], opts)
    end

    def create_minibatch(trainset, batch_size) do
      SnakeBridge.Runtime.call(__MODULE__, :create_minibatch, [trainset, batch_size], [])
    end

    def create_minibatch(trainset, batch_size, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :create_minibatch, [trainset, batch_size], opts)
    end

    def create_minibatch(trainset, batch_size, rng) do
      SnakeBridge.Runtime.call(__MODULE__, :create_minibatch, [trainset, batch_size, rng], [])
    end

    def create_minibatch(trainset, batch_size, rng, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :create_minibatch, [trainset, batch_size, rng], opts)
    end

    @doc """
    This function is copied from random_search.py, and creates fewshot examples in the same way that random search does.

    This allows us to take advantage of using the same fewshot examples when we use the same random seed in our optimizers.

    Parameters:
    - `student` (term())
    - `num_candidate_sets` (term())
    - `trainset` (term())
    - `max_labeled_demos` (term())
    - `max_bootstrapped_demos` (term())
    - `metric` (term())
    - `teacher_settings` (term())
    - `max_errors` (term() default: None)
    - `max_rounds` (term() default: 1)
    - `labeled_sample` (term() default: True)
    - `min_num_samples` (term() default: 1)
    - `metric_threshold` (term() default: None)
    - `teacher` (term() default: None)
    - `include_non_bootstrapped` (term() default: True)
    - `seed` (term() default: 0)
    - `rng` (term() default: None)

    Returns:
    - `term()`
    """
    @spec create_n_fewshot_demo_sets(term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec create_n_fewshot_demo_sets(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings
        ],
        []
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings
        ],
        opts
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors
        ],
        []
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors
        ],
        opts
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds
        ],
        []
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds
        ],
        opts
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample
        ],
        []
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample
        ],
        opts
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples
        ],
        []
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples
        ],
        opts
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold
        ],
        []
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold
        ],
        opts
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher
        ],
        []
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher
        ],
        opts
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher,
          include_non_bootstrapped
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher,
          include_non_bootstrapped
        ],
        []
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher,
          include_non_bootstrapped,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher,
          include_non_bootstrapped
        ],
        opts
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher,
          include_non_bootstrapped,
          seed
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher,
          include_non_bootstrapped,
          seed
        ],
        []
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher,
          include_non_bootstrapped,
          seed,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher,
          include_non_bootstrapped,
          seed
        ],
        opts
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher,
          include_non_bootstrapped,
          seed,
          rng
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher,
          include_non_bootstrapped,
          seed,
          rng
        ],
        []
      )
    end

    def create_n_fewshot_demo_sets(
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher,
          include_non_bootstrapped,
          seed,
          rng,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :create_n_fewshot_demo_sets,
        [
          student,
          num_candidate_sets,
          trainset,
          max_labeled_demos,
          max_bootstrapped_demos,
          metric,
          teacher_settings,
          max_errors,
          max_rounds,
          labeled_sample,
          min_num_samples,
          metric_threshold,
          teacher,
          include_non_bootstrapped,
          seed,
          rng
        ],
        opts
      )
    end

    @doc """
    Evaluate a candidate program on the trainset, using the specified batch size.

    Parameters:
    - `batch_size` (term())
    - `trainset` (term())
    - `candidate_program` (term())
    - `evaluate` (term())
    - `rng` (term() default: None)

    Returns:
    - `term()`
    """
    @spec eval_candidate_program(term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec eval_candidate_program(term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec eval_candidate_program(term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec eval_candidate_program(term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def eval_candidate_program(batch_size, trainset, candidate_program, evaluate) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :eval_candidate_program,
        [batch_size, trainset, candidate_program, evaluate],
        []
      )
    end

    def eval_candidate_program(batch_size, trainset, candidate_program, evaluate, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :eval_candidate_program,
        [batch_size, trainset, candidate_program, evaluate],
        opts
      )
    end

    def eval_candidate_program(batch_size, trainset, candidate_program, evaluate, rng) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :eval_candidate_program,
        [batch_size, trainset, candidate_program, evaluate, rng],
        []
      )
    end

    def eval_candidate_program(batch_size, trainset, candidate_program, evaluate, rng, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :eval_candidate_program,
        [batch_size, trainset, candidate_program, evaluate, rng],
        opts
      )
    end

    @doc """
    Evaluation of candidate_program with pruning implemented

    Parameters:
    - `trial` (term())
    - `trial_logs` (term())
    - `trainset` (term())
    - `candidate_program` (term())
    - `evaluate` (term())
    - `trial_num` (term())
    - `batch_size` (term() default: 100)

    Returns:
    - `term()`
    """
    @spec eval_candidate_program_with_pruning(term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec eval_candidate_program_with_pruning(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec eval_candidate_program_with_pruning(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec eval_candidate_program_with_pruning(
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def eval_candidate_program_with_pruning(
          trial,
          trial_logs,
          trainset,
          candidate_program,
          evaluate,
          trial_num
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :eval_candidate_program_with_pruning,
        [trial, trial_logs, trainset, candidate_program, evaluate, trial_num],
        []
      )
    end

    def eval_candidate_program_with_pruning(
          trial,
          trial_logs,
          trainset,
          candidate_program,
          evaluate,
          trial_num,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :eval_candidate_program_with_pruning,
        [trial, trial_logs, trainset, candidate_program, evaluate, trial_num],
        opts
      )
    end

    def eval_candidate_program_with_pruning(
          trial,
          trial_logs,
          trainset,
          candidate_program,
          evaluate,
          trial_num,
          batch_size
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :eval_candidate_program_with_pruning,
        [trial, trial_logs, trainset, candidate_program, evaluate, trial_num, batch_size],
        []
      )
    end

    def eval_candidate_program_with_pruning(
          trial,
          trial_logs,
          trainset,
          candidate_program,
          evaluate,
          trial_num,
          batch_size,
          opts
        )
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :eval_candidate_program_with_pruning,
        [trial, trial_logs, trainset, candidate_program, evaluate, trial_num, batch_size],
        opts
      )
    end

    @doc """
    Used as a helper function for bayesian + minibatching optimizers. Returns the program with the highest average score from the batches evaluated so far.

    Parameters:
    - `param_score_dict` (term())
    - `fully_evaled_param_combos` (term())

    Returns:
    - `term()`
    """
    @spec get_program_with_highest_avg_score(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_program_with_highest_avg_score(
          param_score_dict,
          fully_evaled_param_combos,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :get_program_with_highest_avg_score,
        [param_score_dict, fully_evaled_param_combos],
        opts
      )
    end

    @doc """

    """
    @spec get_prompt_model(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_prompt_model(prompt_model, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_prompt_model, [prompt_model], opts)
    end

    @doc """

    """
    @spec get_signature(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_signature(predictor, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_signature, [predictor], opts)
    end

    @doc """
    Get a full trace of the task model's history for a given candidate program.

    Parameters:
    - `candidate_program` (term())
    - `task_model` (term())
    - `devset` (term())
    - `evaluate` (term())

    Returns:
    - `term()`
    """
    @spec get_task_model_history_for_full_example(term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_task_model_history_for_full_example(
          candidate_program,
          task_model,
          devset,
          evaluate,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :get_task_model_history_for_full_example,
        [candidate_program, task_model, devset, evaluate],
        opts
      )
    end

    @doc """
    Extract total input tokens and output tokens from a model's interaction history.

    Returns (total_input_tokens, total_output_tokens).

    Parameters:
    - `model` (term())

    Returns:
    - `{integer(), integer()}`
    """
    @spec get_token_usage(term(), keyword()) ::
            {:ok, {integer(), integer()}} | {:error, Snakepit.Error.t()}
    def get_token_usage(model, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_token_usage, [model], opts)
    end

    @doc """
    Extract total input and output tokens used by each model and log to trial_logs[trial_num]["token_usage"].

    Parameters:
    - `trial_logs` (term())
    - `trial_num` (term())
    - `model_dict` (term())

    Returns:
    - `term()`
    """
    @spec log_token_usage(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def log_token_usage(trial_logs, trial_num, model_dict, opts \\ []) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :log_token_usage,
        [trial_logs, trial_num, model_dict],
        opts
      )
    end

    @doc """

    """
    @spec new_getfile(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def new_getfile(object, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :new_getfile, [object], opts)
    end

    @doc """
    Work out which source or compiled file an object was defined in.

    Parameters:
    - `object` (term())

    Returns:
    - `term()`
    """
    @spec old_getfile(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def old_getfile(object, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :old_getfile, [object], opts)
    end

    @doc """
    Print out the program's instructions & prefixes for each module.

    Parameters:
    - `program` (term())

    Returns:
    - `term()`
    """
    @spec print_full_program(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def print_full_program(program, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :print_full_program, [program], opts)
    end

    @doc """
    Save the candidate program to the log directory.

    Parameters:
    - `program` (term())
    - `log_dir` (term())
    - `trial_num` (term())
    - `note` (term() default: None)

    Returns:
    - `term()`
    """
    @spec save_candidate_program(term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec save_candidate_program(term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec save_candidate_program(term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec save_candidate_program(term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save_candidate_program(program, log_dir, trial_num) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :save_candidate_program,
        [program, log_dir, trial_num],
        []
      )
    end

    def save_candidate_program(program, log_dir, trial_num, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :save_candidate_program,
        [program, log_dir, trial_num],
        opts
      )
    end

    def save_candidate_program(program, log_dir, trial_num, note) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :save_candidate_program,
        [program, log_dir, trial_num, note],
        []
      )
    end

    def save_candidate_program(program, log_dir, trial_num, note, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :save_candidate_program,
        [program, log_dir, trial_num, note],
        opts
      )
    end

    @doc """

    """
    @spec save_file_to_log_dir(term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save_file_to_log_dir(source_file_path, log_dir, opts \\ []) do
      SnakeBridge.Runtime.call(
        __MODULE__,
        :save_file_to_log_dir,
        [source_file_path, log_dir],
        opts
      )
    end

    @doc """

    """
    @spec set_signature(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_signature(predictor, updated_signature, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :set_signature, [predictor, updated_signature], opts)
    end

    @doc """
    Setup logger, which will log our print statements to a txt file at our log_dir for later viewing

    Parameters:
    - `log_dir` (term())

    Returns:
    - `term()`
    """
    @spec setup_logging(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def setup_logging(log_dir, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :setup_logging, [log_dir], opts)
    end
  end

  defmodule Utils do
    def __snakebridge_python_name__, do: "dspy.utils"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec download(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def download(url, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :download, [url], opts)
    end

    @doc """

    """
    @spec dummy_rm() :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec dummy_rm(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec dummy_rm(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec dummy_rm(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dummy_rm() do
      SnakeBridge.Runtime.call(__MODULE__, :dummy_rm, [], [])
    end

    def dummy_rm(opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :dummy_rm, [], opts)
    end

    def dummy_rm(passages) do
      SnakeBridge.Runtime.call(__MODULE__, :dummy_rm, [passages], [])
    end

    def dummy_rm(passages, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :dummy_rm, [passages], opts)
    end

    @doc """
    Decorator / decorator creator for marking APIs experimental in the docstring.



    ## Parameters

    - `f` - The function to be decorated.
    - `version` - The version in which the API was introduced as experimental. The version is used to determine whether the API should be considered as stable or not when releasing a new version of DSPy.

    Parameters:
    - `f` (term() | nil default: None)
    - `version` (term() default: None)

    Returns:
    - `term()`
    """
    @spec experimental() :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec experimental(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec experimental(term() | nil) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec experimental(term() | nil, keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec experimental(term() | nil, term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec experimental(term() | nil, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def experimental() do
      SnakeBridge.Runtime.call(__MODULE__, :experimental, [], [])
    end

    def experimental(opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :experimental, [], opts)
    end

    def experimental(f) do
      SnakeBridge.Runtime.call(__MODULE__, :experimental, [f], [])
    end

    def experimental(f, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :experimental, [f], opts)
    end

    def experimental(f, version) do
      SnakeBridge.Runtime.call(__MODULE__, :experimental, [f, version], [])
    end

    def experimental(f, version, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :experimental, [f, version], opts)
    end

    @doc """
    Prints the last n prompts and their completions.

    Parameters:
    - `history` (term())
    - `n` (integer() default: 1)

    Returns:
    - `term()`
    """
    @spec pretty_print_history(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pretty_print_history(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pretty_print_history(term(), integer()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pretty_print_history(term(), integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def pretty_print_history(history) do
      SnakeBridge.Runtime.call(__MODULE__, :pretty_print_history, [history], [])
    end

    def pretty_print_history(history, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :pretty_print_history, [history], opts)
    end

    def pretty_print_history(history, n) do
      SnakeBridge.Runtime.call(__MODULE__, :pretty_print_history, [history, n], [])
    end

    def pretty_print_history(history, n, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :pretty_print_history, [history, n], opts)
    end

    @doc """
    Decorator to add callback functionality to instance methods.

    Parameters:
    - `fn` (term())

    Returns:
    - `term()`
    """
    @spec with_callbacks(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_callbacks(py_fn, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :with_callbacks, [py_fn], opts)
    end
  end

  defmodule Utils.Annotation do
    def __snakebridge_python_name__, do: "dspy.utils.annotation"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Decorator / decorator creator for marking APIs experimental in the docstring.



    ## Parameters

    - `f` - The function to be decorated.
    - `version` - The version in which the API was introduced as experimental. The version is used to determine whether the API should be considered as stable or not when releasing a new version of DSPy.

    Parameters:
    - `f` (term() | nil default: None)
    - `version` (term() default: None)

    Returns:
    - `term()`
    """
    @spec experimental() :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec experimental(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec experimental(term() | nil) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec experimental(term() | nil, keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec experimental(term() | nil, term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec experimental(term() | nil, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def experimental() do
      SnakeBridge.Runtime.call(__MODULE__, :experimental, [], [])
    end

    def experimental(opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :experimental, [], opts)
    end

    def experimental(f) do
      SnakeBridge.Runtime.call(__MODULE__, :experimental, [f], [])
    end

    def experimental(f, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :experimental, [f], opts)
    end

    def experimental(f, version) do
      SnakeBridge.Runtime.call(__MODULE__, :experimental, [f, version], [])
    end

    def experimental(f, version, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :experimental, [f, version], opts)
    end

    @doc """
    Parameter specification variable.

    The preferred way to construct a parameter specification is via the
    dedicated syntax for generic functions, classes, and type aliases,
    where the use of '**' creates a parameter specification::

      type IntFunc[**P] = Callable[P, int]

    For compatibility with Python 3.11 and earlier, ParamSpec objects
    can also be created as follows::

      P = ParamSpec('P')

    Parameter specification variables exist primarily for the benefit of
    static type checkers.  They are used to forward the parameter types of
    one callable to another callable, a pattern commonly found in
    higher-order functions and decorators.  They are only valid when used
    in ``Concatenate``, or as the first argument to ``Callable``, or as
    parameters for user-defined Generics. See class Generic for more
    information on generic types.

    An example for annotating a decorator::

      def add_logging[**P, T](f: Callable[P, T]) -> Callable[P, T]:
          '''A type-safe decorator to add logging to a function.'''
          def inner(*args: P.args, **kwargs: P.kwargs) -> T:
              logging.info(f'{f.__name__} was called')
              return f(*args, **kwargs)
          return inner

      @add_logging
      def add_two(x: float, y: float) -> float:
          '''Add two numbers together.'''
          return x + y

    Parameter specification variables can be introspected. e.g.::

      >>> P = ParamSpec("P")
      >>> P.__name__
      'P'

    Note that only parameter specification variables defined in the global
    scope can be pickled.

    Returns:
    - `term()`
    """
    @spec p() :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def p() do
      SnakeBridge.Runtime.get_module_attr(__MODULE__, "P")
    end

    @doc """
    Type variable.

    The preferred way to construct a type variable is via the dedicated
    syntax for generic functions, classes, and type aliases::

      class Sequence[T]:  # T is a TypeVar
          ...

    This syntax can also be used to create bound and constrained type
    variables::

      # S is a TypeVar bound to str
      class StrSequence[S: str]:
          ...

      # A is a TypeVar constrained to str or bytes
      class StrOrBytesSequence[A: (str, bytes)]:
          ...

    However, if desired, reusable type variables can also be constructed
    manually, like so::

     T = TypeVar('T')  # Can be anything
     S = TypeVar('S', bound=str)  # Can be any subtype of str
     A = TypeVar('A', str, bytes)  # Must be exactly str or bytes

    Type variables exist primarily for the benefit of static type
    checkers.  They serve as the parameters for generic types as well
    as for generic function and type alias definitions.

    The variance of type variables is inferred by type checkers when they
    are created through the type parameter syntax and when
    ``infer_variance=True`` is passed. Manually created type variables may
    be explicitly marked covariant or contravariant by passing
    ``covariant=True`` or ``contravariant=True``. By default, manually
    created type variables are invariant. See PEP 484 and PEP 695 for more
    details.

    Returns:
    - `term()`
    """
    @spec r() :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def r() do
      SnakeBridge.Runtime.get_module_attr(__MODULE__, "R")
    end
  end

  defmodule Utils.Asyncify do
    def __snakebridge_python_name__, do: "dspy.utils.asyncify"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Wraps a DSPy program so that it can be called asynchronously. This is useful for running a

    program in parallel with another task (e.g., another DSPy program).

    This implementation propagates the current thread's configuration context to the worker thread.

    ## Parameters

    - `program` - The DSPy program to be wrapped for asynchronous execution.

    Parameters:
    - `program` (term())

    Returns:
    - `term()`
    """
    @spec asyncify(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def asyncify(program, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :asyncify, [program], opts)
    end

    @doc """

    """
    @spec get_async_max_workers(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_async_max_workers(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_async_max_workers, [], opts)
    end

    @doc """

    """
    @spec get_limiter(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_limiter(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_limiter, [], opts)
    end
  end

  defmodule Utils.Caching do
    def __snakebridge_python_name__, do: "dspy.utils.caching"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Create a subdirectory in the DSPy cache directory.

    Parameters:
    - `subdir` (String.t())

    Returns:
    - `String.t()`
    """
    @spec create_subdir_in_cachedir(String.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def create_subdir_in_cachedir(subdir, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :create_subdir_in_cachedir, [subdir], opts)
    end
  end

  defmodule Utils.Callback do
    def __snakebridge_python_name__, do: "dspy.utils.callback"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Decorator to add callback functionality to instance methods.

    Parameters:
    - `fn` (term())

    Returns:
    - `term()`
    """
    @spec with_callbacks(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_callbacks(py_fn, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :with_callbacks, [py_fn], opts)
    end
  end

  defmodule Utils.Dummies do
    def __snakebridge_python_name__, do: "dspy.utils.dummies"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec dummy_rm() :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec dummy_rm(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec dummy_rm(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec dummy_rm(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dummy_rm() do
      SnakeBridge.Runtime.call(__MODULE__, :dummy_rm, [], [])
    end

    def dummy_rm(opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :dummy_rm, [], opts)
    end

    def dummy_rm(passages) do
      SnakeBridge.Runtime.call(__MODULE__, :dummy_rm, [passages], [])
    end

    def dummy_rm(passages, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :dummy_rm, [passages], opts)
    end
  end

  defmodule Utils.InspectHistory do
    def __snakebridge_python_name__, do: "dspy.utils.inspect_history"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Prints the last n prompts and their completions.

    Parameters:
    - `history` (term())
    - `n` (integer() default: 1)

    Returns:
    - `term()`
    """
    @spec pretty_print_history(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pretty_print_history(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pretty_print_history(term(), integer()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pretty_print_history(term(), integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def pretty_print_history(history) do
      SnakeBridge.Runtime.call(__MODULE__, :pretty_print_history, [history], [])
    end

    def pretty_print_history(history, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :pretty_print_history, [history], opts)
    end

    def pretty_print_history(history, n) do
      SnakeBridge.Runtime.call(__MODULE__, :pretty_print_history, [history, n], [])
    end

    def pretty_print_history(history, n, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :pretty_print_history, [history, n], opts)
    end
  end

  defmodule Utils.LangchainTool do
    def __snakebridge_python_name__, do: "dspy.utils.langchain_tool"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Build a DSPy tool from a LangChain tool.

    This function converts a LangChain tool (either created with @tool decorator
    or by subclassing BaseTool) into a DSPy Tool.

    ## Parameters

    - `tool` - The LangChain tool to convert.

    Parameters:
    - `tool` (term())

    Returns:
    - `Dspy.Adapters.Types.Tool.Tool.t()`
    """
    @spec convert_langchain_tool(term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Tool.Tool.t()} | {:error, Snakepit.Error.t()}
    def convert_langchain_tool(tool, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :convert_langchain_tool, [tool], opts)
    end
  end

  defmodule Utils.LoggingUtils do
    def __snakebridge_python_name__, do: "dspy.utils.logging_utils"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec configure_dspy_loggers(term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def configure_dspy_loggers(root_module_name, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :configure_dspy_loggers, [root_module_name], opts)
    end

    @doc """
    Disables the `DSPyLoggingStream` used by event logging APIs throughout DSPy

    (`eprint()`, `logger.info()`, etc), silencing all subsequent event logs.

    Returns:
    - `term()`
    """
    @spec disable_logging(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def disable_logging(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :disable_logging, [], opts)
    end

    @doc """
    A Python stream for use with event logging APIs throughout DSPy (`eprint()`,

    `logger.info()`, etc.). This stream wraps `sys.stderr`, forwarding `write()` and
    `flush()` calls to the stream referred to by `sys.stderr` at the time of the call.
    It also provides capabilities for disabling the stream to silence event logs.

    Returns:
    - `Dspy.Utils.LoggingUtils.DSPyLoggingStream.t()`
    """
    @spec dspy_logging_stream() ::
            {:ok, Dspy.Utils.LoggingUtils.DSPyLoggingStream.t()} | {:error, Snakepit.Error.t()}
    def dspy_logging_stream() do
      SnakeBridge.Runtime.get_module_attr(__MODULE__, "DSPY_LOGGING_STREAM")
    end

    @doc """
    Enables the `DSPyLoggingStream` used by event logging APIs throughout DSPy

    (`eprint()`, `logger.info()`, etc), emitting all subsequent event logs. This
    reverses the effects of `disable_logging()`.

    Returns:
    - `term()`
    """
    @spec enable_logging(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def enable_logging(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :enable_logging, [], opts)
    end
  end

  defmodule Utils.Magicattr do
    def __snakebridge_python_name__, do: "dspy.utils.magicattr"
    def __snakebridge_library__, do: "dspy"

    @doc """
    A delattr that supports deletion of a nested lookups on objects,

    dicts, lists, and any combination in between.

    Parameters:
    - `obj` (term())
    - `attr` (term())

    Returns:
    - `term()`
    """
    @spec delete(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(obj, attr, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :delete, [obj, attr], opts)
    end

    @doc """
    A getattr that supports nested lookups on objects, dicts, lists, and

    any combination in between.

    Parameters:
    - `obj` (term())
    - `attr` (term())
    - `kwargs` (term())

    Returns:
    - `term()`
    """
    @spec get(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(obj, attr, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get, [obj, attr], opts)
    end

    @doc """
    Like get but instead of returning the final value it returns the

    object and action that will be done.

    Parameters:
    - `obj` (term())
    - `attr` (term())

    Returns:
    - `term()`
    """
    @spec lookup(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lookup(obj, attr, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :lookup, [obj, attr], opts)
    end

    @doc """
    A setattr that supports nested lookups on objects, dicts, lists, and

    any combination in between.

    Parameters:
    - `obj` (term())
    - `attr` (term())
    - `val` (term())

    Returns:
    - `term()`
    """
    @spec set(term(), term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def set(obj, attr, val, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :set, [obj, attr, val], opts)
    end
  end

  defmodule Utils.Mcp do
    def __snakebridge_python_name__, do: "dspy.utils.mcp"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Build a DSPy tool from an MCP tool.



    ## Parameters

    - `session` - The MCP session to use.
    - `tool` - The MCP tool to convert.

    Parameters:
    - `session` (term())
    - `tool` (term())

    Returns:
    - `Dspy.Adapters.Types.Tool.Tool.t()`
    """
    @spec convert_mcp_tool(term(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Tool.Tool.t()} | {:error, Snakepit.Error.t()}
    def convert_mcp_tool(session, tool, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :convert_mcp_tool, [session, tool], opts)
    end
  end

  defmodule Utils.Saving do
    def __snakebridge_python_name__, do: "dspy.utils.saving"
    def __snakebridge_library__, do: "dspy"

    @doc """

    """
    @spec get_dependency_versions(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_dependency_versions(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :get_dependency_versions, [], opts)
    end

    @doc """
    Load saved DSPy model.

    This method is used to load a saved DSPy model with `save_program=True`, i.e., the model is saved with cloudpickle.

    ## Parameters

    - `path` - Path to the saved model. (type: `String.t()`)
    - `allow_pickle` - Whether to allow loading the model with pickle. This is dangerous and should only be used if you are sure you trust the source of the model. (type: `boolean()`)

    Parameters:
    - `path` (String.t())
    - `allow_pickle` (boolean() default: False)

    Returns:
    - `term()`
    """
    @spec load(String.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec load(String.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec load(String.t(), boolean()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec load(String.t(), boolean(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(path) do
      SnakeBridge.Runtime.call(__MODULE__, :load, [path], [])
    end

    def load(path, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :load, [path], opts)
    end

    def load(path, allow_pickle) do
      SnakeBridge.Runtime.call(__MODULE__, :load, [path, allow_pickle], [])
    end

    def load(path, allow_pickle, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :load, [path, allow_pickle], opts)
    end
  end

  defmodule Utils.Syncify do
    def __snakebridge_python_name__, do: "dspy.utils.syncify"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Run an async coroutine from a synchronous context.

    Parameters:
    - `coro` (term())

    Returns:
    - `term()`
    """
    @spec run_async(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def run_async(coro, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :run_async, [coro], opts)
    end

    @doc """
    Convert an async DSPy module to a sync program.

    There are two modes of this function:

    - `in_place=True` (recommended): Modify the module in place. But this may not work if you already have a `forward`
      method which does different things from `aforward`.
    - `in_place=False`: Return a wrapper module. This changes the module's architecture, but it's more robust.

    ## Parameters

    - `program` - The async program to convert, must have an `aforward` method implemented.
    - `in_place` - If True, modify the module in place. Otherwise, return a wrapper module.

    Parameters:
    - `program` (term())
    - `in_place` (boolean() default: True)

    Returns:
    - `term()`
    """
    @spec syncify(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec syncify(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec syncify(term(), boolean()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec syncify(term(), boolean(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def syncify(program) do
      SnakeBridge.Runtime.call(__MODULE__, :syncify, [program], [])
    end

    def syncify(program, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :syncify, [program], opts)
    end

    def syncify(program, in_place) do
      SnakeBridge.Runtime.call(__MODULE__, :syncify, [program, in_place], [])
    end

    def syncify(program, in_place, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call(__MODULE__, :syncify, [program, in_place], opts)
    end
  end

  defmodule Utils.UsageTracker do
    def __snakebridge_python_name__, do: "dspy.utils.usage_tracker"
    def __snakebridge_library__, do: "dspy"

    @doc """
    Context manager for tracking LM usage.

    Returns:
    - `term()`
    """
    @spec track_usage(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def track_usage(opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :track_usage, [], opts)
    end
  end

  defmodule Adapter do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Adapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end
  end

  defmodule Adapters.Adapter do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "Adapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end
  end

  defmodule Adapters.Audio do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "Audio"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec from_array(SnakeBridge.Ref.t(), term(), integer(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.Audio.Audio.t()} | {:error, Snakepit.Error.t()}
    def from_array(ref, array, sampling_rate, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :from_array,
        [array, sampling_rate] ++ List.wrap(args),
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec from_file(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Audio.Audio.t()} | {:error, Snakepit.Error.t()}
    def from_file(ref, file_path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_file, [file_path], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec from_url(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Audio.Audio.t()} | {:error, Snakepit.Error.t()}
    def from_url(ref, url, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_url, [url], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate_input(ref, values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [values], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.BAMLAdapter do
    def __snakebridge_python_name__, do: "dspy.adapters.baml_adapter"
    def __snakebridge_python_class__, do: "BAMLAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec _json_adapter_call_common(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _json_adapter_call_common(
          ref,
          lm,
          lm_kwargs,
          signature,
          demos,
          inputs,
          call_fn,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_json_adapter_call_common,
        [lm, lm_kwargs, signature, demos, inputs, call_fn],
        opts
      )
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            Dspy.Clients.LMClass.t(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_field_with_value(
            SnakeBridge.Ref.t(),
            %{optional(Dspy.Adapters.ChatAdapter.FieldInfoWithName.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_with_value(ref, fields_with_values, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_field_with_value,
        [fields_with_values] ++ List.wrap(args),
        opts
      )
    end

    @spec format_finetune_data(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, %{optional(String.t()) => list(term())}} | {:error, Snakepit.Error.t()}
    def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_finetune_data,
        [signature, demos, inputs, outputs],
        opts
      )
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end

    @spec user_message_output_requirements(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def user_message_output_requirements(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :user_message_output_requirements, [signature], opts)
    end
  end

  defmodule Adapters.Base.Adapter do
    def __snakebridge_python_name__, do: "dspy.adapters.base"
    def __snakebridge_python_class__, do: "Adapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end
  end

  defmodule Adapters.ChatAdapter do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "ChatAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            Dspy.Clients.LMClass.t(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_field_with_value(
            SnakeBridge.Ref.t(),
            %{optional(Dspy.Adapters.ChatAdapter.FieldInfoWithName.t()) => term()},
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_with_value(ref, fields_with_values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_with_value, [fields_with_values], opts)
    end

    @spec format_finetune_data(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, %{optional(String.t()) => list(term())}} | {:error, Snakepit.Error.t()}
    def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_finetune_data,
        [signature, demos, inputs, outputs],
        opts
      )
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end

    @spec user_message_output_requirements(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def user_message_output_requirements(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :user_message_output_requirements, [signature], opts)
    end
  end

  defmodule Adapters.ChatAdapter.FieldInfoWithName do
    def __snakebridge_python_name__, do: "dspy.adapters.chat_adapter"
    def __snakebridge_python_class__, do: "FieldInfoWithName"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _asdict(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _asdict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_asdict, [], opts)
    end

    @spec _make(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _make(ref, iterable, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_make, [iterable], opts)
    end

    @spec _replace(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _replace(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_replace, [], opts)
    end

    @spec count(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def count(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :count, [value], opts)
    end

    @spec index(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def index(ref, value, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :index, [value] ++ List.wrap(args), opts)
    end

    @spec _field_defaults(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _field_defaults(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_field_defaults)
    end

    @spec _fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_fields)
    end

    @spec info(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def info(ref) do
      SnakeBridge.Runtime.get_attr(ref, :info)
    end

    @spec name(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def name(ref) do
      SnakeBridge.Runtime.get_attr(ref, :name)
    end
  end

  defmodule Adapters.ChatAdapterClass do
    def __snakebridge_python_name__, do: "dspy.adapters.chat_adapter"
    def __snakebridge_python_class__, do: "ChatAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            Dspy.Clients.LMClass.t(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_field_with_value(
            SnakeBridge.Ref.t(),
            %{optional(Dspy.Adapters.ChatAdapter.FieldInfoWithName.t()) => term()},
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_with_value(ref, fields_with_values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_with_value, [fields_with_values], opts)
    end

    @spec format_finetune_data(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, %{optional(String.t()) => list(term())}} | {:error, Snakepit.Error.t()}
    def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_finetune_data,
        [signature, demos, inputs, outputs],
        opts
      )
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end

    @spec user_message_output_requirements(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def user_message_output_requirements(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :user_message_output_requirements, [signature], opts)
    end
  end

  defmodule Adapters.Code do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "Code"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec language(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def language(ref) do
      SnakeBridge.Runtime.get_attr(ref, :language)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.File do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "File"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec from_file_id(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.File.File.t()} | {:error, Snakepit.Error.t()}
    def from_file_id(ref, file_id, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_file_id, [file_id] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec from_bytes(SnakeBridge.Ref.t(), binary(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.File.File.t()} | {:error, Snakepit.Error.t()}
    def from_bytes(ref, file_bytes, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_bytes, [file_bytes] ++ List.wrap(args), opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec from_path(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.File.File.t()} | {:error, Snakepit.Error.t()}
    def from_path(ref, file_path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_path, [file_path] ++ List.wrap(args), opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate_input(ref, values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [values], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.History do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "History"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Image do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "Image"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec from_pil(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_pil(ref, pil_image, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "from_PIL", [pil_image], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec from_file(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_file(ref, file_path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_file, [file_path], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec from_url(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_url(ref, url, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_url, [url] ++ List.wrap(args), opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.JSONAdapter do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "JSONAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec _json_adapter_call_common(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _json_adapter_call_common(
          ref,
          lm,
          lm_kwargs,
          signature,
          demos,
          inputs,
          call_fn,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_json_adapter_call_common,
        [lm, lm_kwargs, signature, demos, inputs, call_fn],
        opts
      )
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            Dspy.Clients.LMClass.t(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_field_with_value(
            SnakeBridge.Ref.t(),
            %{optional(Dspy.Adapters.ChatAdapter.FieldInfoWithName.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_with_value(ref, fields_with_values, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_field_with_value,
        [fields_with_values] ++ List.wrap(args),
        opts
      )
    end

    @spec format_finetune_data(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, %{optional(String.t()) => list(term())}} | {:error, Snakepit.Error.t()}
    def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_finetune_data,
        [signature, demos, inputs, outputs],
        opts
      )
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end

    @spec user_message_output_requirements(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def user_message_output_requirements(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :user_message_output_requirements, [signature], opts)
    end
  end

  defmodule Adapters.JSONAdapterClass do
    def __snakebridge_python_name__, do: "dspy.adapters.json_adapter"
    def __snakebridge_python_class__, do: "JSONAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec _json_adapter_call_common(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _json_adapter_call_common(
          ref,
          lm,
          lm_kwargs,
          signature,
          demos,
          inputs,
          call_fn,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_json_adapter_call_common,
        [lm, lm_kwargs, signature, demos, inputs, call_fn],
        opts
      )
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            Dspy.Clients.LMClass.t(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_field_with_value(
            SnakeBridge.Ref.t(),
            %{optional(Dspy.Adapters.ChatAdapter.FieldInfoWithName.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_with_value(ref, fields_with_values, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_field_with_value,
        [fields_with_values] ++ List.wrap(args),
        opts
      )
    end

    @spec format_finetune_data(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, %{optional(String.t()) => list(term())}} | {:error, Snakepit.Error.t()}
    def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_finetune_data,
        [signature, demos, inputs, outputs],
        opts
      )
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end

    @spec user_message_output_requirements(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def user_message_output_requirements(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :user_message_output_requirements, [signature], opts)
    end
  end

  defmodule Adapters.Reasoning do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "Reasoning"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.ReasoningClass.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Tool do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "Tool"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(func, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [func] ++ List.wrap(args), opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec _run_async_in_sync(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _run_async_in_sync(ref, coroutine, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_run_async_in_sync, [coroutine], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec from_langchain(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_langchain(ref, tool, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_langchain, [tool], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec format_as_litellm_function_call(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_as_litellm_function_call(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_as_litellm_function_call, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _validate_and_parse_args(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _validate_and_parse_args(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_and_parse_args, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec from_mcp_tool(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_mcp_tool(ref, session, tool, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_mcp_tool, [session, tool], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec _parse_function(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_function(ref, func, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_parse_function, [func] ++ List.wrap(args), opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec acall(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def acall(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :acall, [], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.ToolCalls do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "ToolCalls"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec tool_call(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def tool_call(ref, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["name", "args"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, "ToolCall", [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec from_dict_list(SnakeBridge.Ref.t(), list(%{optional(String.t()) => term()}), keyword()) ::
            {:ok, Dspy.Adapters.Types.Tool.ToolCalls.t()} | {:error, Snakepit.Error.t()}
    def from_dict_list(ref, tool_calls_dicts, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_dict_list, [tool_calls_dicts], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.TwoStepAdapter do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "TwoStepAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(Dspy.Clients.LMClass.t(), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(extraction_model, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [extraction_model], opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _create_extractor_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _create_extractor_signature(ref, original_signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_create_extractor_signature,
        [original_signature],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            Dspy.Clients.LMClass.t(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(
            SnakeBridge.Ref.t(),
            Dspy.Signatures.Signature.Signature.t(),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(
            SnakeBridge.Ref.t(),
            Dspy.Signatures.Signature.Signature.t(),
            String.t(),
            keyword()
          ) :: {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end
  end

  defmodule Adapters.TwoStepAdapterClass do
    def __snakebridge_python_name__, do: "dspy.adapters.two_step_adapter"
    def __snakebridge_python_class__, do: "TwoStepAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(Dspy.Clients.LMClass.t(), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(extraction_model, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [extraction_model], opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _create_extractor_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _create_extractor_signature(ref, original_signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_create_extractor_signature,
        [original_signature],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            Dspy.Clients.LMClass.t(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(
            SnakeBridge.Ref.t(),
            Dspy.Signatures.Signature.Signature.t(),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(
            SnakeBridge.Ref.t(),
            Dspy.Signatures.Signature.Signature.t(),
            String.t(),
            keyword()
          ) :: {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end
  end

  defmodule Adapters.Type do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "Type"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.Audio.Audio do
    def __snakebridge_python_name__, do: "dspy.adapters.types.audio"
    def __snakebridge_python_class__, do: "Audio"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec from_array(SnakeBridge.Ref.t(), term(), integer(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.Audio.Audio.t()} | {:error, Snakepit.Error.t()}
    def from_array(ref, array, sampling_rate, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :from_array,
        [array, sampling_rate] ++ List.wrap(args),
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec from_file(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Audio.Audio.t()} | {:error, Snakepit.Error.t()}
    def from_file(ref, file_path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_file, [file_path], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec from_url(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Audio.Audio.t()} | {:error, Snakepit.Error.t()}
    def from_url(ref, url, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_url, [url], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate_input(ref, values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [values], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.AudioClass do
    def __snakebridge_python_name__, do: "dspy.adapters.types"
    def __snakebridge_python_class__, do: "Audio"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec from_array(SnakeBridge.Ref.t(), term(), integer(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.Audio.Audio.t()} | {:error, Snakepit.Error.t()}
    def from_array(ref, array, sampling_rate, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :from_array,
        [array, sampling_rate] ++ List.wrap(args),
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec from_file(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Audio.Audio.t()} | {:error, Snakepit.Error.t()}
    def from_file(ref, file_path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_file, [file_path], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec from_url(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Audio.Audio.t()} | {:error, Snakepit.Error.t()}
    def from_url(ref, url, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_url, [url], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate_input(ref, values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [values], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.BaseType.Type do
    def __snakebridge_python_name__, do: "dspy.adapters.types.base_type"
    def __snakebridge_python_class__, do: "Type"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.Citation.Citations do
    def __snakebridge_python_name__, do: "dspy.adapters.types.citation"
    def __snakebridge_python_class__, do: "Citations"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Citation.Citations.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Citation.Citations.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec citation(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def citation(ref, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)

      missing_kw =
        ["cited_text", "document_index", "start_char_index", "end_char_index"]
        |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, "Citation", [], opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec from_dict_list(SnakeBridge.Ref.t(), list(%{optional(String.t()) => term()}), keyword()) ::
            {:ok, Dspy.Adapters.Types.Citation.Citations.t()} | {:error, Snakepit.Error.t()}
    def from_dict_list(ref, citations_dicts, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_dict_list, [citations_dicts], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.Code do
    def __snakebridge_python_name__, do: "dspy.adapters.types"
    def __snakebridge_python_class__, do: "Code"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec language(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def language(ref) do
      SnakeBridge.Runtime.get_attr(ref, :language)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.CodeClass do
    def __snakebridge_python_name__, do: "dspy.adapters.types.code"
    def __snakebridge_python_class__, do: "Code"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec language(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def language(ref) do
      SnakeBridge.Runtime.get_attr(ref, :language)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.Document do
    def __snakebridge_python_name__, do: "dspy.adapters.types.document"
    def __snakebridge_python_class__, do: "Document"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.File.File do
    def __snakebridge_python_name__, do: "dspy.adapters.types.file"
    def __snakebridge_python_class__, do: "File"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec from_file_id(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.File.File.t()} | {:error, Snakepit.Error.t()}
    def from_file_id(ref, file_id, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_file_id, [file_id] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec from_bytes(SnakeBridge.Ref.t(), binary(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.File.File.t()} | {:error, Snakepit.Error.t()}
    def from_bytes(ref, file_bytes, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_bytes, [file_bytes] ++ List.wrap(args), opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec from_path(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.File.File.t()} | {:error, Snakepit.Error.t()}
    def from_path(ref, file_path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_path, [file_path] ++ List.wrap(args), opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate_input(ref, values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [values], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.FileClass do
    def __snakebridge_python_name__, do: "dspy.adapters.types"
    def __snakebridge_python_class__, do: "File"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec from_file_id(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.File.File.t()} | {:error, Snakepit.Error.t()}
    def from_file_id(ref, file_id, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_file_id, [file_id] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec from_bytes(SnakeBridge.Ref.t(), binary(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.File.File.t()} | {:error, Snakepit.Error.t()}
    def from_bytes(ref, file_bytes, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_bytes, [file_bytes] ++ List.wrap(args), opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec from_path(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.File.File.t()} | {:error, Snakepit.Error.t()}
    def from_path(ref, file_path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_path, [file_path] ++ List.wrap(args), opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate_input(ref, values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [values], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.History do
    def __snakebridge_python_name__, do: "dspy.adapters.types.history"
    def __snakebridge_python_class__, do: "History"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.HistoryClass do
    def __snakebridge_python_name__, do: "dspy.adapters.types"
    def __snakebridge_python_class__, do: "History"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.Image.Image do
    def __snakebridge_python_name__, do: "dspy.adapters.types.image"
    def __snakebridge_python_class__, do: "Image"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec from_pil(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_pil(ref, pil_image, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "from_PIL", [pil_image], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec from_file(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_file(ref, file_path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_file, [file_path], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec from_url(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_url(ref, url, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_url, [url] ++ List.wrap(args), opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.ImageClass do
    def __snakebridge_python_name__, do: "dspy.adapters.types"
    def __snakebridge_python_class__, do: "Image"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec from_pil(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_pil(ref, pil_image, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "from_PIL", [pil_image], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec from_file(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_file(ref, file_path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_file, [file_path], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec from_url(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_url(ref, url, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_url, [url] ++ List.wrap(args), opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.Reasoning do
    def __snakebridge_python_name__, do: "dspy.adapters.types"
    def __snakebridge_python_class__, do: "Reasoning"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.ReasoningClass.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.ReasoningClass do
    def __snakebridge_python_name__, do: "dspy.adapters.types.reasoning"
    def __snakebridge_python_class__, do: "Reasoning"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.ReasoningClass.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.Tool.Tool do
    def __snakebridge_python_name__, do: "dspy.adapters.types.tool"
    def __snakebridge_python_class__, do: "Tool"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(func, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [func] ++ List.wrap(args), opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec _run_async_in_sync(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _run_async_in_sync(ref, coroutine, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_run_async_in_sync, [coroutine], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec from_langchain(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_langchain(ref, tool, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_langchain, [tool], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec format_as_litellm_function_call(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_as_litellm_function_call(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_as_litellm_function_call, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _validate_and_parse_args(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _validate_and_parse_args(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_and_parse_args, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec from_mcp_tool(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_mcp_tool(ref, session, tool, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_mcp_tool, [session, tool], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec _parse_function(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_function(ref, func, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_parse_function, [func] ++ List.wrap(args), opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec acall(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def acall(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :acall, [], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.Tool.ToolCalls do
    def __snakebridge_python_name__, do: "dspy.adapters.types.tool"
    def __snakebridge_python_class__, do: "ToolCalls"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec tool_call(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def tool_call(ref, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["name", "args"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, "ToolCall", [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec from_dict_list(SnakeBridge.Ref.t(), list(%{optional(String.t()) => term()}), keyword()) ::
            {:ok, Dspy.Adapters.Types.Tool.ToolCalls.t()} | {:error, Snakepit.Error.t()}
    def from_dict_list(ref, tool_calls_dicts, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_dict_list, [tool_calls_dicts], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.ToolCalls do
    def __snakebridge_python_name__, do: "dspy.adapters.types"
    def __snakebridge_python_class__, do: "ToolCalls"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec tool_call(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def tool_call(ref, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["name", "args"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, "ToolCall", [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec from_dict_list(SnakeBridge.Ref.t(), list(%{optional(String.t()) => term()}), keyword()) ::
            {:ok, Dspy.Adapters.Types.Tool.ToolCalls.t()} | {:error, Snakepit.Error.t()}
    def from_dict_list(ref, tool_calls_dicts, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_dict_list, [tool_calls_dicts], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.ToolClass do
    def __snakebridge_python_name__, do: "dspy.adapters.types"
    def __snakebridge_python_class__, do: "Tool"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(func, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [func] ++ List.wrap(args), opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec _run_async_in_sync(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _run_async_in_sync(ref, coroutine, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_run_async_in_sync, [coroutine], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec from_langchain(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_langchain(ref, tool, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_langchain, [tool], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec format_as_litellm_function_call(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_as_litellm_function_call(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_as_litellm_function_call, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _validate_and_parse_args(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _validate_and_parse_args(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_and_parse_args, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec from_mcp_tool(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_mcp_tool(ref, session, tool, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_mcp_tool, [session, tool], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec _parse_function(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_function(ref, func, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_parse_function, [func] ++ List.wrap(args), opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec acall(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def acall(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :acall, [], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.Types.Type do
    def __snakebridge_python_name__, do: "dspy.adapters.types"
    def __snakebridge_python_class__, do: "Type"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Adapters.XMLAdapter do
    def __snakebridge_python_name__, do: "dspy.adapters"
    def __snakebridge_python_class__, do: "XMLAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec _parse_field_value(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_field_value(ref, field_info, raw, completion, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_parse_field_value,
        [field_info, raw, completion, signature],
        opts
      )
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            Dspy.Clients.LMClass.t(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_field_with_value(
            SnakeBridge.Ref.t(),
            %{optional(Dspy.Adapters.ChatAdapter.FieldInfoWithName.t()) => term()},
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_with_value(ref, fields_with_values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_with_value, [fields_with_values], opts)
    end

    @spec format_finetune_data(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, %{optional(String.t()) => list(term())}} | {:error, Snakepit.Error.t()}
    def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_finetune_data,
        [signature, demos, inputs, outputs],
        opts
      )
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end

    @spec user_message_output_requirements(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def user_message_output_requirements(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :user_message_output_requirements, [signature], opts)
    end
  end

  defmodule Adapters.XMLAdapterClass do
    def __snakebridge_python_name__, do: "dspy.adapters.xml_adapter"
    def __snakebridge_python_class__, do: "XMLAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec _parse_field_value(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_field_value(ref, field_info, raw, completion, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_parse_field_value,
        [field_info, raw, completion, signature],
        opts
      )
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            Dspy.Clients.LMClass.t(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_field_with_value(
            SnakeBridge.Ref.t(),
            %{optional(Dspy.Adapters.ChatAdapter.FieldInfoWithName.t()) => term()},
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_with_value(ref, fields_with_values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_with_value, [fields_with_values], opts)
    end

    @spec format_finetune_data(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, %{optional(String.t()) => list(term())}} | {:error, Snakepit.Error.t()}
    def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_finetune_data,
        [signature, demos, inputs, outputs],
        opts
      )
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end

    @spec user_message_output_requirements(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def user_message_output_requirements(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :user_message_output_requirements, [signature], opts)
    end
  end

  defmodule Audio do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Audio"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec from_array(SnakeBridge.Ref.t(), term(), integer(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.Audio.Audio.t()} | {:error, Snakepit.Error.t()}
    def from_array(ref, array, sampling_rate, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :from_array,
        [array, sampling_rate] ++ List.wrap(args),
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec from_file(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Audio.Audio.t()} | {:error, Snakepit.Error.t()}
    def from_file(ref, file_path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_file, [file_path], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec from_url(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Audio.Audio.t()} | {:error, Snakepit.Error.t()}
    def from_url(ref, url, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_url, [url], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate_input(ref, values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [values], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule AvatarOptimizer do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "AvatarOptimizer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec _get_pos_neg_results(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            keyword()
          ) ::
            {:ok,
             {float(), list(Dspy.Teleprompt.AvatarOptimizer.EvalResult.t()),
              list(Dspy.Teleprompt.AvatarOptimizer.EvalResult.t())}}
            | {:error, Snakepit.Error.t()}
    def _get_pos_neg_results(ref, actor, trainset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_pos_neg_results, [actor, trainset], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end

    @spec process_example(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def process_example(ref, actor, example, return_outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :process_example,
        [actor, example, return_outputs],
        opts
      )
    end

    @spec thread_safe_evaluator(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def thread_safe_evaluator(ref, devset, actor, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :thread_safe_evaluator,
        [devset, actor] ++ List.wrap(args),
        opts
      )
    end
  end

  defmodule BaseLM do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BaseLM"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [model] ++ List.wrap(args), opts)
    end

    @spec _extract_citations_from_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _extract_citations_from_response(ref, choice, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_extract_citations_from_response, [choice], opts)
    end

    @spec _process_completion(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_completion(ref, response, merged_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_completion, [response, merged_kwargs], opts)
    end

    @spec _process_lm_response(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_lm_response(ref, response, prompt, messages, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_lm_response,
        [response, prompt, messages],
        opts
      )
    end

    @spec _process_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_response, [response], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, list(term())} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :aforward, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [] ++ List.wrap(args), opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec update_history(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_history(ref, entry, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_history, [entry], opts)
    end
  end

  defmodule BaseModule do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BaseModule"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end
  end

  defmodule BestOfN do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BestOfN"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            Dspy.Primitives.Module.Module.t(),
            integer(),
            term(),
            float(),
            list(term()),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(module, n, reward_fn, threshold, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [module, n, reward_fn, threshold] ++ List.wrap(args),
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule BetterTogether do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BetterTogether"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec _compile_prompt_optimizer(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def _compile_prompt_optimizer(ref, student, trainset, valset_ratio, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_compile_prompt_optimizer,
        [student, trainset, valset_ratio],
        opts
      )
    end

    @spec _compile_weight_optimizer(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def _compile_weight_optimizer(ref, student, trainset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_compile_weight_optimizer, [student, trainset], opts)
    end

    @spec _run_strategies(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def _run_strategies(ref, parsed_strategy, student, trainset, valset_ratio, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_run_strategies,
        [parsed_strategy, student, trainset, valset_ratio],
        opts
      )
    end

    @spec compile(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            list(term()),
            keyword()
          ) :: {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, trainset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :compile, [student, trainset] ++ List.wrap(args), opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end

    @spec strat_sep(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def strat_sep(ref) do
      SnakeBridge.Runtime.get_attr(ref, :STRAT_SEP)
    end
  end

  defmodule BootstrapFewShot do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BootstrapFewShot"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _bootstrap(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_bootstrap, [], opts)
    end

    @spec _bootstrap_one_example(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap_one_example(ref, example, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_bootstrap_one_example,
        [example] ++ List.wrap(args),
        opts
      )
    end

    @spec _prepare_predictor_mappings(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_predictor_mappings(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_prepare_predictor_mappings, [], opts)
    end

    @spec _prepare_student_and_teacher(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_student_and_teacher(ref, student, teacher, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_prepare_student_and_teacher,
        [student, teacher],
        opts
      )
    end

    @spec _train(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _train(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_train, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule BootstrapFewShotWithOptuna do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BootstrapFewShotWithOptuna"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["max_demos", "trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end

    @spec objective(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def objective(ref, trial, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :objective, [trial], opts)
    end
  end

  defmodule BootstrapFewShotWithRandomSearch do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BootstrapFewShotWithRandomSearch"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule BootstrapFinetune do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BootstrapFinetune"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _prepare_finetune_data(
            SnakeBridge.Ref.t(),
            list(%{optional(String.t()) => term()}),
            Dspy.Clients.LMClass.t(),
            list(term()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_finetune_data(ref, trace_data, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_prepare_finetune_data,
        [trace_data, lm] ++ List.wrap(args),
        opts
      )
    end

    @spec compile(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            list(term()),
            keyword()
          ) :: {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, trainset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :compile, [student, trainset] ++ List.wrap(args), opts)
    end

    @spec convert_to_lm_dict(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, %{optional(Dspy.Clients.LMClass.t()) => term()}} | {:error, Snakepit.Error.t()}
    def convert_to_lm_dict(ref, arg, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :convert_to_lm_dict, [arg], opts)
    end

    @spec finetune_lms(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, %{optional(term()) => Dspy.Clients.LMClass.t()}} | {:error, Snakepit.Error.t()}
    def finetune_lms(ref, finetune_dict, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finetune_lms, [finetune_dict], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule BootstrapRS do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BootstrapRS"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule COPRO do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "COPRO"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _check_candidates_equal(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _check_candidates_equal(ref, candidate1, candidate2, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_check_candidates_equal,
        [candidate1, candidate2],
        opts
      )
    end

    @spec _drop_duplicates(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _drop_duplicates(ref, candidates, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_drop_duplicates, [candidates], opts)
    end

    @spec _get_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_signature(ref, predictor, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_signature, [predictor], opts)
    end

    @spec _print_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _print_signature(ref, predictor, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_print_signature, [predictor], opts)
    end

    @spec _set_signature(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_signature(ref, predictor, updated_signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_signature, [predictor, updated_signature], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset", "eval_kwargs"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule ChainOfThought do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "ChainOfThought"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule ChainOfThoughtWithHint do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "ChainOfThoughtWithHint"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule ChatAdapter do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "ChatAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            Dspy.Clients.LMClass.t(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_field_with_value(
            SnakeBridge.Ref.t(),
            %{optional(Dspy.Adapters.ChatAdapter.FieldInfoWithName.t()) => term()},
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_with_value(ref, fields_with_values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_with_value, [fields_with_values], opts)
    end

    @spec format_finetune_data(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, %{optional(String.t()) => list(term())}} | {:error, Snakepit.Error.t()}
    def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_finetune_data,
        [signature, demos, inputs, outputs],
        opts
      )
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end

    @spec user_message_output_requirements(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def user_message_output_requirements(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :user_message_output_requirements, [signature], opts)
    end
  end

  defmodule Clients.BaseLM do
    def __snakebridge_python_name__, do: "dspy.clients"
    def __snakebridge_python_class__, do: "BaseLM"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [model] ++ List.wrap(args), opts)
    end

    @spec _extract_citations_from_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _extract_citations_from_response(ref, choice, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_extract_citations_from_response, [choice], opts)
    end

    @spec _process_completion(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_completion(ref, response, merged_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_completion, [response, merged_kwargs], opts)
    end

    @spec _process_lm_response(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_lm_response(ref, response, prompt, messages, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_lm_response,
        [response, prompt, messages],
        opts
      )
    end

    @spec _process_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_response, [response], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, list(term())} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :aforward, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [] ++ List.wrap(args), opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec update_history(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_history(ref, entry, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_history, [entry], opts)
    end
  end

  defmodule Clients.BaseLMClass do
    def __snakebridge_python_name__, do: "dspy.clients.base_lm"
    def __snakebridge_python_class__, do: "BaseLM"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [model] ++ List.wrap(args), opts)
    end

    @spec _extract_citations_from_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _extract_citations_from_response(ref, choice, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_extract_citations_from_response, [choice], opts)
    end

    @spec _process_completion(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_completion(ref, response, merged_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_completion, [response, merged_kwargs], opts)
    end

    @spec _process_lm_response(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_lm_response(ref, response, prompt, messages, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_lm_response,
        [response, prompt, messages],
        opts
      )
    end

    @spec _process_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_response, [response], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, list(term())} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :aforward, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [] ++ List.wrap(args), opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec update_history(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_history(ref, entry, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_history, [entry], opts)
    end
  end

  defmodule Clients.Cache.Cache do
    def __snakebridge_python_name__, do: "dspy.clients.cache"
    def __snakebridge_python_class__, do: "Cache"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(boolean(), boolean(), String.t(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(enable_disk_cache, enable_memory_cache, disk_cache_dir, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [enable_disk_cache, enable_memory_cache, disk_cache_dir] ++ List.wrap(args),
        opts
      )
    end

    @spec cache_key(
            SnakeBridge.Ref.t(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def cache_key(ref, request, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :cache_key, [request] ++ List.wrap(args), opts)
    end

    @spec get(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, request, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [request] ++ List.wrap(args), opts)
    end

    @spec load_memory_cache(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def load_memory_cache(ref, filepath, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :load_memory_cache,
        [filepath] ++ List.wrap(args),
        opts
      )
    end

    @spec put(
            SnakeBridge.Ref.t(),
            %{optional(String.t()) => term()},
            term(),
            list(term()),
            keyword()
          ) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def put(ref, request, value, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :put, [request, value] ++ List.wrap(args), opts)
    end

    @spec reset_memory_cache(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def reset_memory_cache(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_memory_cache, [], opts)
    end

    @spec save_memory_cache(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def save_memory_cache(ref, filepath, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :save_memory_cache, [filepath], opts)
    end
  end

  defmodule Clients.Databricks.DatabricksProvider do
    def __snakebridge_python_name__, do: "dspy.clients.databricks"
    def __snakebridge_python_class__, do: "DatabricksProvider"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec deploy_finetuned_model(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def deploy_finetuned_model(ref, model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :deploy_finetuned_model,
        [model] ++ List.wrap(args),
        opts
      )
    end

    @spec finetune(
            SnakeBridge.Ref.t(),
            Dspy.Clients.Databricks.TrainingJobDatabricks.t(),
            String.t(),
            list(%{optional(String.t()) => term()}),
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def finetune(ref, job, model, train_data, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :finetune,
        [job, model, train_data] ++ List.wrap(args),
        opts
      )
    end

    @spec is_provider_model(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_provider_model(ref, model, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_provider_model, [model], opts)
    end

    @spec kill(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :kill, [lm] ++ List.wrap(args), opts)
    end

    @spec launch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :launch, [lm] ++ List.wrap(args), opts)
    end

    @spec training_job(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def training_job(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, "TrainingJob", [] ++ List.wrap(args), opts)
    end

    @spec upload_data(
            SnakeBridge.Ref.t(),
            list(%{optional(String.t()) => term()}),
            String.t(),
            Dspy.Clients.UtilsFinetune.TrainDataFormat.t(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def upload_data(ref, train_data, databricks_unity_catalog_path, data_format, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :upload_data,
        [train_data, databricks_unity_catalog_path, data_format],
        opts
      )
    end

    @spec finetunable(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def finetunable(ref) do
      SnakeBridge.Runtime.get_attr(ref, :finetunable)
    end
  end

  defmodule Clients.Databricks.TrainingJobDatabricks do
    def __snakebridge_python_name__, do: "dspy.clients.databricks"
    def __snakebridge_python_class__, do: "TrainingJobDatabricks"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec __future__get_result(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def __future__get_result(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "_Future__get_result", [], opts)
    end

    @spec _invoke_callbacks(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _invoke_callbacks(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_invoke_callbacks, [], opts)
    end

    @spec add_done_callback(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def add_done_callback(ref, py_fn, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :add_done_callback, [py_fn], opts)
    end

    @spec cancel(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancel(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cancel, [], opts)
    end

    @spec cancelled(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancelled(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cancelled, [], opts)
    end

    @spec done(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def done(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :done, [], opts)
    end

    @spec exception(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def exception(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :exception, [] ++ List.wrap(args), opts)
    end

    @spec result(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def result(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :result, [] ++ List.wrap(args), opts)
    end

    @spec running(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def running(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :running, [], opts)
    end

    @spec set_exception(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_exception(ref, exception, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_exception, [exception], opts)
    end

    @spec set_result(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_result(ref, result, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_result, [result], opts)
    end

    @spec set_running_or_notify_cancel(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_running_or_notify_cancel(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_running_or_notify_cancel, [], opts)
    end

    @spec status(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def status(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :status, [], opts)
    end
  end

  defmodule Clients.Embedder do
    def __snakebridge_python_name__, do: "dspy.clients"
    def __snakebridge_python_class__, do: "Embedder"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t() | term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [model] ++ List.wrap(args), opts)
    end

    @spec _postprocess(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _postprocess(ref, embeddings_list, is_single_input, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_postprocess,
        [embeddings_list, is_single_input],
        opts
      )
    end

    @spec _preprocess(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _preprocess(ref, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_preprocess, [inputs] ++ List.wrap(args), opts)
    end

    @spec acall(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def acall(ref, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [inputs] ++ List.wrap(args), opts)
    end
  end

  defmodule Clients.Embedding.Embedder do
    def __snakebridge_python_name__, do: "dspy.clients.embedding"
    def __snakebridge_python_class__, do: "Embedder"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t() | term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [model] ++ List.wrap(args), opts)
    end

    @spec _postprocess(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _postprocess(ref, embeddings_list, is_single_input, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_postprocess,
        [embeddings_list, is_single_input],
        opts
      )
    end

    @spec _preprocess(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _preprocess(ref, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_preprocess, [inputs] ++ List.wrap(args), opts)
    end

    @spec acall(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def acall(ref, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [inputs] ++ List.wrap(args), opts)
    end
  end

  defmodule Clients.LM do
    def __snakebridge_python_name__, do: "dspy.clients"
    def __snakebridge_python_class__, do: "LM"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [model] ++ List.wrap(args), opts)
    end

    @spec _check_truncation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _check_truncation(ref, results, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_check_truncation, [results], opts)
    end

    @spec _extract_citations_from_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _extract_citations_from_response(ref, choice, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_extract_citations_from_response, [choice], opts)
    end

    @spec _get_cached_completion_fn(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_cached_completion_fn(ref, completion_fn, cache, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_get_cached_completion_fn,
        [completion_fn, cache],
        opts
      )
    end

    @spec _process_completion(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_completion(ref, response, merged_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_completion, [response, merged_kwargs], opts)
    end

    @spec _process_lm_response(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_lm_response(ref, response, prompt, messages, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_lm_response,
        [response, prompt, messages],
        opts
      )
    end

    @spec _process_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_response, [response], opts)
    end

    @spec _run_finetune_job(SnakeBridge.Ref.t(), Dspy.Clients.Provider.TrainingJob.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _run_finetune_job(ref, job, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_run_finetune_job, [job], opts)
    end

    @spec _warn_zero_temp_rollout(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _warn_zero_temp_rollout(ref, temperature, rollout_id, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_warn_zero_temp_rollout,
        [temperature, rollout_id],
        opts
      )
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, list(term())} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :aforward, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec finetune(
            SnakeBridge.Ref.t(),
            list(%{optional(String.t()) => term()}),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, Dspy.Clients.Provider.TrainingJob.t()} | {:error, Snakepit.Error.t()}
    def finetune(ref, train_data, train_data_format, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :finetune,
        [train_data, train_data_format] ++ List.wrap(args),
        opts
      )
    end

    @spec forward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [] ++ List.wrap(args), opts)
    end

    @spec infer_provider(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, Dspy.Clients.ProviderClass.t()} | {:error, Snakepit.Error.t()}
    def infer_provider(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :infer_provider, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec kill(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :kill, [] ++ List.wrap(args), opts)
    end

    @spec launch(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :launch, [] ++ List.wrap(args), opts)
    end

    @spec reinforce(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Clients.Provider.ReinforceJob.t()} | {:error, Snakepit.Error.t()}
    def reinforce(ref, train_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reinforce, [train_kwargs], opts)
    end

    @spec update_history(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_history(ref, entry, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_history, [entry], opts)
    end
  end

  defmodule Clients.LMClass do
    def __snakebridge_python_name__, do: "dspy.clients.lm"
    def __snakebridge_python_class__, do: "LM"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [model] ++ List.wrap(args), opts)
    end

    @spec _check_truncation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _check_truncation(ref, results, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_check_truncation, [results], opts)
    end

    @spec _extract_citations_from_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _extract_citations_from_response(ref, choice, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_extract_citations_from_response, [choice], opts)
    end

    @spec _get_cached_completion_fn(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_cached_completion_fn(ref, completion_fn, cache, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_get_cached_completion_fn,
        [completion_fn, cache],
        opts
      )
    end

    @spec _process_completion(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_completion(ref, response, merged_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_completion, [response, merged_kwargs], opts)
    end

    @spec _process_lm_response(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_lm_response(ref, response, prompt, messages, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_lm_response,
        [response, prompt, messages],
        opts
      )
    end

    @spec _process_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_response, [response], opts)
    end

    @spec _run_finetune_job(SnakeBridge.Ref.t(), Dspy.Clients.Provider.TrainingJob.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _run_finetune_job(ref, job, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_run_finetune_job, [job], opts)
    end

    @spec _warn_zero_temp_rollout(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _warn_zero_temp_rollout(ref, temperature, rollout_id, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_warn_zero_temp_rollout,
        [temperature, rollout_id],
        opts
      )
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, list(term())} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :aforward, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec finetune(
            SnakeBridge.Ref.t(),
            list(%{optional(String.t()) => term()}),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, Dspy.Clients.Provider.TrainingJob.t()} | {:error, Snakepit.Error.t()}
    def finetune(ref, train_data, train_data_format, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :finetune,
        [train_data, train_data_format] ++ List.wrap(args),
        opts
      )
    end

    @spec forward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [] ++ List.wrap(args), opts)
    end

    @spec infer_provider(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, Dspy.Clients.ProviderClass.t()} | {:error, Snakepit.Error.t()}
    def infer_provider(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :infer_provider, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec kill(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :kill, [] ++ List.wrap(args), opts)
    end

    @spec launch(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :launch, [] ++ List.wrap(args), opts)
    end

    @spec reinforce(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Clients.Provider.ReinforceJob.t()} | {:error, Snakepit.Error.t()}
    def reinforce(ref, train_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reinforce, [train_kwargs], opts)
    end

    @spec update_history(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_history(ref, entry, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_history, [entry], opts)
    end
  end

  defmodule Clients.LmLocal.LocalProvider do
    def __snakebridge_python_name__, do: "dspy.clients.lm_local"
    def __snakebridge_python_class__, do: "LocalProvider"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finetune(
            SnakeBridge.Ref.t(),
            Dspy.Clients.Provider.TrainingJob.t(),
            String.t(),
            list(%{optional(String.t()) => term()}),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def finetune(ref, job, model, train_data, train_data_format, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :finetune,
        [job, model, train_data, train_data_format] ++ List.wrap(args),
        opts
      )
    end

    @spec is_provider_model(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_provider_model(ref, model, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_provider_model, [model], opts)
    end

    @spec kill(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :kill, [lm] ++ List.wrap(args), opts)
    end

    @spec launch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :launch, [lm] ++ List.wrap(args), opts)
    end
  end

  defmodule Clients.Openai.OpenAIProvider do
    def __snakebridge_python_name__, do: "dspy.clients.openai"
    def __snakebridge_python_class__, do: "OpenAIProvider"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _remove_provider_prefix(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _remove_provider_prefix(ref, model, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_remove_provider_prefix, [model], opts)
    end

    @spec _start_remote_training(
            SnakeBridge.Ref.t(),
            String.t(),
            String.t(),
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _start_remote_training(ref, train_file_id, model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_start_remote_training,
        [train_file_id, model] ++ List.wrap(args),
        opts
      )
    end

    @spec does_file_exist(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def does_file_exist(ref, file_id, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :does_file_exist, [file_id], opts)
    end

    @spec does_job_exist(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def does_job_exist(ref, job_id, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :does_job_exist, [job_id], opts)
    end

    @spec finetune(
            SnakeBridge.Ref.t(),
            Dspy.Clients.Openai.TrainingJobOpenAI.t(),
            String.t(),
            list(%{optional(String.t()) => term()}),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def finetune(ref, job, model, train_data, train_data_format, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :finetune,
        [job, model, train_data, train_data_format] ++ List.wrap(args),
        opts
      )
    end

    @spec get_trained_model(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_trained_model(ref, job, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_trained_model, [job], opts)
    end

    @spec get_training_status(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, Dspy.Clients.UtilsFinetune.TrainingStatus.t()} | {:error, Snakepit.Error.t()}
    def get_training_status(ref, job_id, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_training_status, [job_id], opts)
    end

    @spec is_provider_model(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_provider_model(ref, model, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_provider_model, [model], opts)
    end

    @spec is_terminal_training_status(
            SnakeBridge.Ref.t(),
            Dspy.Clients.UtilsFinetune.TrainingStatus.t(),
            keyword()
          ) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_terminal_training_status(ref, status, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_terminal_training_status, [status], opts)
    end

    @spec kill(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :kill, [lm] ++ List.wrap(args), opts)
    end

    @spec launch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :launch, [lm] ++ List.wrap(args), opts)
    end

    @spec upload_data(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def upload_data(ref, data_path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :upload_data, [data_path], opts)
    end

    @spec validate_data_format(
            SnakeBridge.Ref.t(),
            Dspy.Clients.UtilsFinetune.TrainDataFormat.t(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate_data_format(ref, data_format, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_data_format, [data_format], opts)
    end

    @spec wait_for_job(
            SnakeBridge.Ref.t(),
            Dspy.Clients.Openai.TrainingJobOpenAI.t(),
            list(term()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def wait_for_job(ref, job, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :wait_for_job, [job] ++ List.wrap(args), opts)
    end
  end

  defmodule Clients.Openai.TrainingJobOpenAI do
    def __snakebridge_python_name__, do: "dspy.clients.openai"
    def __snakebridge_python_class__, do: "TrainingJobOpenAI"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec __future__get_result(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def __future__get_result(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "_Future__get_result", [], opts)
    end

    @spec _invoke_callbacks(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _invoke_callbacks(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_invoke_callbacks, [], opts)
    end

    @spec add_done_callback(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def add_done_callback(ref, py_fn, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :add_done_callback, [py_fn], opts)
    end

    @spec cancel(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancel(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cancel, [], opts)
    end

    @spec cancelled(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancelled(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cancelled, [], opts)
    end

    @spec done(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def done(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :done, [], opts)
    end

    @spec exception(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def exception(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :exception, [] ++ List.wrap(args), opts)
    end

    @spec result(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def result(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :result, [] ++ List.wrap(args), opts)
    end

    @spec running(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def running(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :running, [], opts)
    end

    @spec set_exception(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_exception(ref, exception, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_exception, [exception], opts)
    end

    @spec set_result(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_result(ref, result, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_result, [result], opts)
    end

    @spec set_running_or_notify_cancel(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_running_or_notify_cancel(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_running_or_notify_cancel, [], opts)
    end

    @spec status(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, Dspy.Clients.UtilsFinetune.TrainingStatus.t()} | {:error, Snakepit.Error.t()}
    def status(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :status, [], opts)
    end
  end

  defmodule Clients.Provider do
    def __snakebridge_python_name__, do: "dspy.clients"
    def __snakebridge_python_class__, do: "Provider"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finetune(
            SnakeBridge.Ref.t(),
            Dspy.Clients.Provider.TrainingJob.t(),
            String.t(),
            list(%{optional(String.t()) => term()}),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def finetune(ref, job, model, train_data, train_data_format, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :finetune,
        [job, model, train_data, train_data_format] ++ List.wrap(args),
        opts
      )
    end

    @spec is_provider_model(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_provider_model(ref, model, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_provider_model, [model], opts)
    end

    @spec kill(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :kill, [lm] ++ List.wrap(args), opts)
    end

    @spec launch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :launch, [lm] ++ List.wrap(args), opts)
    end
  end

  defmodule Clients.Provider.ReinforceJob do
    def __snakebridge_python_name__, do: "dspy.clients.provider"
    def __snakebridge_python_class__, do: "ReinforceJob"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [lm] ++ List.wrap(args), opts)
    end

    @spec cancel(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancel(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cancel, [], opts)
    end

    @spec initialize(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def initialize(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :initialize, [], opts)
    end

    @spec save_checkpoint(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save_checkpoint(ref, checkpoint_name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :save_checkpoint, [checkpoint_name], opts)
    end

    @spec status(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def status(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :status, [], opts)
    end

    @spec step(
            SnakeBridge.Ref.t(),
            list(%{optional(String.t()) => term()}),
            list(term()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def step(ref, train_data, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :step, [train_data] ++ List.wrap(args), opts)
    end

    @spec terminate(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def terminate(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :terminate, [], opts)
    end
  end

  defmodule Clients.Provider.TrainingJob do
    def __snakebridge_python_name__, do: "dspy.clients.provider"
    def __snakebridge_python_class__, do: "TrainingJob"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec __future__get_result(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def __future__get_result(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "_Future__get_result", [], opts)
    end

    @spec _invoke_callbacks(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _invoke_callbacks(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_invoke_callbacks, [], opts)
    end

    @spec add_done_callback(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def add_done_callback(ref, py_fn, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :add_done_callback, [py_fn], opts)
    end

    @spec cancel(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancel(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cancel, [], opts)
    end

    @spec cancelled(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancelled(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cancelled, [], opts)
    end

    @spec done(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def done(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :done, [], opts)
    end

    @spec exception(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def exception(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :exception, [] ++ List.wrap(args), opts)
    end

    @spec result(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def result(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :result, [] ++ List.wrap(args), opts)
    end

    @spec running(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def running(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :running, [], opts)
    end

    @spec set_exception(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_exception(ref, exception, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_exception, [exception], opts)
    end

    @spec set_result(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_result(ref, result, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_result, [result], opts)
    end

    @spec set_running_or_notify_cancel(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_running_or_notify_cancel(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_running_or_notify_cancel, [], opts)
    end

    @spec status(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def status(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :status, [], opts)
    end
  end

  defmodule Clients.ProviderClass do
    def __snakebridge_python_name__, do: "dspy.clients.provider"
    def __snakebridge_python_class__, do: "Provider"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finetune(
            SnakeBridge.Ref.t(),
            Dspy.Clients.Provider.TrainingJob.t(),
            String.t(),
            list(%{optional(String.t()) => term()}),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def finetune(ref, job, model, train_data, train_data_format, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :finetune,
        [job, model, train_data, train_data_format] ++ List.wrap(args),
        opts
      )
    end

    @spec is_provider_model(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_provider_model(ref, model, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_provider_model, [model], opts)
    end

    @spec kill(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :kill, [lm] ++ List.wrap(args), opts)
    end

    @spec launch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :launch, [lm] ++ List.wrap(args), opts)
    end
  end

  defmodule Clients.TrainingJob do
    def __snakebridge_python_name__, do: "dspy.clients"
    def __snakebridge_python_class__, do: "TrainingJob"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec __future__get_result(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def __future__get_result(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "_Future__get_result", [], opts)
    end

    @spec _invoke_callbacks(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _invoke_callbacks(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_invoke_callbacks, [], opts)
    end

    @spec add_done_callback(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def add_done_callback(ref, py_fn, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :add_done_callback, [py_fn], opts)
    end

    @spec cancel(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancel(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cancel, [], opts)
    end

    @spec cancelled(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancelled(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cancelled, [], opts)
    end

    @spec done(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def done(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :done, [], opts)
    end

    @spec exception(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def exception(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :exception, [] ++ List.wrap(args), opts)
    end

    @spec result(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def result(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :result, [] ++ List.wrap(args), opts)
    end

    @spec running(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def running(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :running, [], opts)
    end

    @spec set_exception(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_exception(ref, exception, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_exception, [exception], opts)
    end

    @spec set_result(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_result(ref, result, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_result, [result], opts)
    end

    @spec set_running_or_notify_cancel(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_running_or_notify_cancel(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_running_or_notify_cancel, [], opts)
    end

    @spec status(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def status(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :status, [], opts)
    end
  end

  defmodule Clients.UtilsFinetune.GRPOChatData do
    def __snakebridge_python_name__, do: "dspy.clients.utils_finetune"
    def __snakebridge_python_class__, do: "GRPOChatData"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec clear(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def clear(ref) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], [])
    end

    def clear(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
    end

    def clear(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], [])
    end

    def clear(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], opts)
    end

    def clear(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], [])
    end

    def clear(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], opts)
    end

    def clear(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], [])
    end

    def clear(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec copy(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], [])
    end

    def copy(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    def copy(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], [])
    end

    def copy(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], opts)
    end

    def copy(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], [])
    end

    def copy(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], opts)
    end

    def copy(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], [])
    end

    def copy(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec fromkeys(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def fromkeys(ref, iterable, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :fromkeys, [iterable] ++ List.wrap(args), opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec items(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref) do
      SnakeBridge.Runtime.call_method(ref, :items, [], [])
    end

    def items(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end

    def items(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], [])
    end

    def items(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], opts)
    end

    def items(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], [])
    end

    def items(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], opts)
    end

    def items(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], [])
    end

    def items(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec keys(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], [])
    end

    def keys(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], opts)
    end

    def keys(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], [])
    end

    def keys(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], opts)
    end

    def keys(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], [])
    end

    def keys(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], opts)
    end

    def keys(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], [])
    end

    def keys(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec pop(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pop(ref) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], [])
    end

    def pop(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], opts)
    end

    def pop(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], [])
    end

    def pop(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], opts)
    end

    def pop(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], [])
    end

    def pop(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], opts)
    end

    def pop(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], [])
    end

    def pop(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec popitem(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def popitem(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :popitem, [], opts)
    end

    @spec setdefault(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def setdefault(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :setdefault, [key] ++ List.wrap(args), opts)
    end

    @spec update(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def update(ref) do
      SnakeBridge.Runtime.call_method(ref, :update, [], [])
    end

    def update(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [], opts)
    end

    def update(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], [])
    end

    def update(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], opts)
    end

    def update(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], [])
    end

    def update(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], opts)
    end

    def update(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], [])
    end

    def update(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec values(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref) do
      SnakeBridge.Runtime.call_method(ref, :values, [], [])
    end

    def values(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [], opts)
    end

    def values(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], [])
    end

    def values(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], opts)
    end

    def values(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], [])
    end

    def values(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], opts)
    end

    def values(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], [])
    end

    def values(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end
  end

  defmodule Clients.UtilsFinetune.GRPOGroup do
    def __snakebridge_python_name__, do: "dspy.clients.utils_finetune"
    def __snakebridge_python_class__, do: "GRPOGroup"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec clear(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def clear(ref) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], [])
    end

    def clear(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
    end

    def clear(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], [])
    end

    def clear(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], opts)
    end

    def clear(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], [])
    end

    def clear(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], opts)
    end

    def clear(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], [])
    end

    def clear(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec copy(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], [])
    end

    def copy(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    def copy(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], [])
    end

    def copy(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], opts)
    end

    def copy(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], [])
    end

    def copy(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], opts)
    end

    def copy(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], [])
    end

    def copy(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec fromkeys(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def fromkeys(ref, iterable, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :fromkeys, [iterable] ++ List.wrap(args), opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec items(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref) do
      SnakeBridge.Runtime.call_method(ref, :items, [], [])
    end

    def items(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end

    def items(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], [])
    end

    def items(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], opts)
    end

    def items(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], [])
    end

    def items(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], opts)
    end

    def items(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], [])
    end

    def items(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec keys(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], [])
    end

    def keys(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], opts)
    end

    def keys(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], [])
    end

    def keys(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], opts)
    end

    def keys(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], [])
    end

    def keys(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], opts)
    end

    def keys(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], [])
    end

    def keys(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec pop(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pop(ref) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], [])
    end

    def pop(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], opts)
    end

    def pop(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], [])
    end

    def pop(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], opts)
    end

    def pop(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], [])
    end

    def pop(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], opts)
    end

    def pop(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], [])
    end

    def pop(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec popitem(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def popitem(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :popitem, [], opts)
    end

    @spec setdefault(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def setdefault(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :setdefault, [key] ++ List.wrap(args), opts)
    end

    @spec update(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def update(ref) do
      SnakeBridge.Runtime.call_method(ref, :update, [], [])
    end

    def update(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [], opts)
    end

    def update(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], [])
    end

    def update(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], opts)
    end

    def update(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], [])
    end

    def update(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], opts)
    end

    def update(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], [])
    end

    def update(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec values(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref) do
      SnakeBridge.Runtime.call_method(ref, :values, [], [])
    end

    def values(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [], opts)
    end

    def values(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], [])
    end

    def values(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], opts)
    end

    def values(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], [])
    end

    def values(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], opts)
    end

    def values(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], [])
    end

    def values(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end
  end

  defmodule Clients.UtilsFinetune.GRPOStatus do
    def __snakebridge_python_name__, do: "dspy.clients.utils_finetune"
    def __snakebridge_python_class__, do: "GRPOStatus"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec clear(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def clear(ref) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], [])
    end

    def clear(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
    end

    def clear(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], [])
    end

    def clear(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], opts)
    end

    def clear(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], [])
    end

    def clear(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], opts)
    end

    def clear(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], [])
    end

    def clear(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec copy(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], [])
    end

    def copy(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    def copy(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], [])
    end

    def copy(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], opts)
    end

    def copy(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], [])
    end

    def copy(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], opts)
    end

    def copy(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], [])
    end

    def copy(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec fromkeys(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def fromkeys(ref, iterable, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :fromkeys, [iterable] ++ List.wrap(args), opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec items(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref) do
      SnakeBridge.Runtime.call_method(ref, :items, [], [])
    end

    def items(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end

    def items(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], [])
    end

    def items(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], opts)
    end

    def items(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], [])
    end

    def items(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], opts)
    end

    def items(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], [])
    end

    def items(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec keys(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], [])
    end

    def keys(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], opts)
    end

    def keys(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], [])
    end

    def keys(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], opts)
    end

    def keys(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], [])
    end

    def keys(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], opts)
    end

    def keys(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], [])
    end

    def keys(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec pop(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pop(ref) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], [])
    end

    def pop(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], opts)
    end

    def pop(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], [])
    end

    def pop(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], opts)
    end

    def pop(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], [])
    end

    def pop(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], opts)
    end

    def pop(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], [])
    end

    def pop(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec popitem(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def popitem(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :popitem, [], opts)
    end

    @spec setdefault(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def setdefault(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :setdefault, [key] ++ List.wrap(args), opts)
    end

    @spec update(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def update(ref) do
      SnakeBridge.Runtime.call_method(ref, :update, [], [])
    end

    def update(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [], opts)
    end

    def update(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], [])
    end

    def update(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], opts)
    end

    def update(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], [])
    end

    def update(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], opts)
    end

    def update(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], [])
    end

    def update(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec values(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref) do
      SnakeBridge.Runtime.call_method(ref, :values, [], [])
    end

    def values(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [], opts)
    end

    def values(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], [])
    end

    def values(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], opts)
    end

    def values(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], [])
    end

    def values(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], opts)
    end

    def values(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], [])
    end

    def values(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec last_checkpoint(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def last_checkpoint(ref) do
      SnakeBridge.Runtime.get_attr(ref, :last_checkpoint)
    end

    @spec pending_batch_ids(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pending_batch_ids(ref) do
      SnakeBridge.Runtime.get_attr(ref, :pending_batch_ids)
    end

    @spec status(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def status(ref) do
      SnakeBridge.Runtime.get_attr(ref, :status)
    end
  end

  defmodule Clients.UtilsFinetune.Message do
    def __snakebridge_python_name__, do: "dspy.clients.utils_finetune"
    def __snakebridge_python_class__, do: "Message"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec clear(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def clear(ref) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], [])
    end

    def clear(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
    end

    def clear(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], [])
    end

    def clear(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], opts)
    end

    def clear(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], [])
    end

    def clear(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], opts)
    end

    def clear(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], [])
    end

    def clear(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec copy(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], [])
    end

    def copy(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    def copy(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], [])
    end

    def copy(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], opts)
    end

    def copy(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], [])
    end

    def copy(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], opts)
    end

    def copy(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], [])
    end

    def copy(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec fromkeys(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def fromkeys(ref, iterable, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :fromkeys, [iterable] ++ List.wrap(args), opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec items(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref) do
      SnakeBridge.Runtime.call_method(ref, :items, [], [])
    end

    def items(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end

    def items(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], [])
    end

    def items(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], opts)
    end

    def items(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], [])
    end

    def items(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], opts)
    end

    def items(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], [])
    end

    def items(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec keys(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], [])
    end

    def keys(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], opts)
    end

    def keys(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], [])
    end

    def keys(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], opts)
    end

    def keys(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], [])
    end

    def keys(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], opts)
    end

    def keys(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], [])
    end

    def keys(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec pop(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pop(ref) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], [])
    end

    def pop(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], opts)
    end

    def pop(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], [])
    end

    def pop(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], opts)
    end

    def pop(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], [])
    end

    def pop(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], opts)
    end

    def pop(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], [])
    end

    def pop(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec popitem(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def popitem(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :popitem, [], opts)
    end

    @spec setdefault(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def setdefault(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :setdefault, [key] ++ List.wrap(args), opts)
    end

    @spec update(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def update(ref) do
      SnakeBridge.Runtime.call_method(ref, :update, [], [])
    end

    def update(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [], opts)
    end

    def update(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], [])
    end

    def update(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], opts)
    end

    def update(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], [])
    end

    def update(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], opts)
    end

    def update(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], [])
    end

    def update(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec values(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref) do
      SnakeBridge.Runtime.call_method(ref, :values, [], [])
    end

    def values(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [], opts)
    end

    def values(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], [])
    end

    def values(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], opts)
    end

    def values(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], [])
    end

    def values(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], opts)
    end

    def values(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], [])
    end

    def values(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end
  end

  defmodule Clients.UtilsFinetune.MessageAssistant do
    def __snakebridge_python_name__, do: "dspy.clients.utils_finetune"
    def __snakebridge_python_class__, do: "MessageAssistant"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec clear(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def clear(ref) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], [])
    end

    def clear(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
    end

    def clear(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], [])
    end

    def clear(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], opts)
    end

    def clear(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], [])
    end

    def clear(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], opts)
    end

    def clear(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], [])
    end

    def clear(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec copy(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], [])
    end

    def copy(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    def copy(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], [])
    end

    def copy(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], opts)
    end

    def copy(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], [])
    end

    def copy(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], opts)
    end

    def copy(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], [])
    end

    def copy(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec fromkeys(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def fromkeys(ref, iterable, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :fromkeys, [iterable] ++ List.wrap(args), opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec items(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref) do
      SnakeBridge.Runtime.call_method(ref, :items, [], [])
    end

    def items(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end

    def items(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], [])
    end

    def items(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], opts)
    end

    def items(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], [])
    end

    def items(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], opts)
    end

    def items(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], [])
    end

    def items(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec keys(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], [])
    end

    def keys(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], opts)
    end

    def keys(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], [])
    end

    def keys(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], opts)
    end

    def keys(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], [])
    end

    def keys(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], opts)
    end

    def keys(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], [])
    end

    def keys(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec pop(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pop(ref) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], [])
    end

    def pop(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], opts)
    end

    def pop(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], [])
    end

    def pop(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], opts)
    end

    def pop(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], [])
    end

    def pop(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], opts)
    end

    def pop(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], [])
    end

    def pop(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec popitem(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def popitem(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :popitem, [], opts)
    end

    @spec setdefault(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def setdefault(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :setdefault, [key] ++ List.wrap(args), opts)
    end

    @spec update(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def update(ref) do
      SnakeBridge.Runtime.call_method(ref, :update, [], [])
    end

    def update(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [], opts)
    end

    def update(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], [])
    end

    def update(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], opts)
    end

    def update(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], [])
    end

    def update(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], opts)
    end

    def update(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], [])
    end

    def update(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec values(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref) do
      SnakeBridge.Runtime.call_method(ref, :values, [], [])
    end

    def values(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [], opts)
    end

    def values(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], [])
    end

    def values(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], opts)
    end

    def values(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], [])
    end

    def values(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], opts)
    end

    def values(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], [])
    end

    def values(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end
  end

  defmodule Clients.UtilsFinetune.TrainDataFormat do
    def __snakebridge_python_name__, do: "dspy.clients.utils_finetune"
    def __snakebridge_python_class__, do: "TrainDataFormat"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec format_map(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_map(ref) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [], [])
    end

    def format_map(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [], opts)
    end

    def format_map(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1], [])
    end

    def format_map(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1], opts)
    end

    def format_map(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2], [])
    end

    def format_map(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2], opts)
    end

    def format_map(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3], [])
    end

    def format_map(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3], opts)
    end

    def format_map(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4], [])
    end

    def format_map(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4], opts)
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_map,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        opts
      )
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_map,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_map,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_map,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_map,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec isascii(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def isascii(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isascii, [], opts)
    end

    @spec rsplit(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def rsplit(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :rsplit, [] ++ List.wrap(args), opts)
    end

    @spec title(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def title(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :title, [], opts)
    end

    @spec upper(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def upper(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :upper, [], opts)
    end

    @spec maketrans(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def maketrans(ref) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [], [])
    end

    def maketrans(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [], opts)
    end

    def maketrans(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1], [])
    end

    def maketrans(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1], opts)
    end

    def maketrans(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2], [])
    end

    def maketrans(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2], opts)
    end

    def maketrans(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3], [])
    end

    def maketrans(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3], opts)
    end

    def maketrans(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4], [])
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4], opts)
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :maketrans,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :maketrans,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :maketrans,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :maketrans,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec count(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def count(ref) do
      SnakeBridge.Runtime.call_method(ref, :count, [], [])
    end

    def count(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [], opts)
    end

    def count(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1], [])
    end

    def count(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1], opts)
    end

    def count(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2], [])
    end

    def count(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2], opts)
    end

    def count(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3], [])
    end

    def count(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3], opts)
    end

    def count(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4], [])
    end

    def count(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4], opts)
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :count,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :count,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :count,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec encode(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def encode(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :encode, [] ++ List.wrap(args), opts)
    end

    @spec isalpha(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def isalpha(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isalpha, [], opts)
    end

    @spec casefold(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def casefold(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :casefold, [], opts)
    end

    @spec rfind(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def rfind(ref) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [], [])
    end

    def rfind(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [], opts)
    end

    def rfind(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1], [])
    end

    def rfind(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1], opts)
    end

    def rfind(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2], [])
    end

    def rfind(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2], opts)
    end

    def rfind(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3], [])
    end

    def rfind(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3], opts)
    end

    def rfind(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4], [])
    end

    def rfind(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4], opts)
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rfind,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rfind,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rfind,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec translate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def translate(ref, table, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :translate, [table], opts)
    end

    @spec startswith(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def startswith(ref) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [], [])
    end

    def startswith(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [], opts)
    end

    def startswith(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1], [])
    end

    def startswith(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1], opts)
    end

    def startswith(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2], [])
    end

    def startswith(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2], opts)
    end

    def startswith(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3], [])
    end

    def startswith(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3], opts)
    end

    def startswith(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4], [])
    end

    def startswith(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4], opts)
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :startswith,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        opts
      )
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :startswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :startswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :startswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :startswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec isalnum(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def isalnum(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isalnum, [], opts)
    end

    @spec isdecimal(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def isdecimal(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isdecimal, [], opts)
    end

    @spec isprintable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def isprintable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isprintable, [], opts)
    end

    @spec rstrip(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def rstrip(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :rstrip, [] ++ List.wrap(args), opts)
    end

    @spec removeprefix(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def removeprefix(ref, prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :removeprefix, [prefix], opts)
    end

    @spec split(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def split(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :split, [] ++ List.wrap(args), opts)
    end

    @spec rindex(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def rindex(ref) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [], [])
    end

    def rindex(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [], opts)
    end

    def rindex(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1], [])
    end

    def rindex(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1], opts)
    end

    def rindex(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2], [])
    end

    def rindex(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2], opts)
    end

    def rindex(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3], [])
    end

    def rindex(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3], opts)
    end

    def rindex(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4], [])
    end

    def rindex(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4], opts)
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rindex,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rindex,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rindex,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rindex,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec lower(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lower(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :lower, [], opts)
    end

    @spec isspace(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def isspace(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isspace, [], opts)
    end

    @spec expandtabs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def expandtabs(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :expandtabs, [] ++ List.wrap(args), opts)
    end

    @spec strip(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def strip(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :strip, [] ++ List.wrap(args), opts)
    end

    @spec format(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref) do
      SnakeBridge.Runtime.call_method(ref, :format, [], [])
    end

    def format(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    def format(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1], [])
    end

    def format(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1], opts)
    end

    def format(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2], [])
    end

    def format(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2], opts)
    end

    def format(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3], [])
    end

    def format(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3], opts)
    end

    def format(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4], [])
    end

    def format(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4], opts)
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec removesuffix(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def removesuffix(ref, suffix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :removesuffix, [suffix], opts)
    end

    @spec center(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def center(ref, width, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :center, [width] ++ List.wrap(args), opts)
    end

    @spec find(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def find(ref) do
      SnakeBridge.Runtime.call_method(ref, :find, [], [])
    end

    def find(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [], opts)
    end

    def find(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1], [])
    end

    def find(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1], opts)
    end

    def find(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2], [])
    end

    def find(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2], opts)
    end

    def find(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3], [])
    end

    def find(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3], opts)
    end

    def find(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4], [])
    end

    def find(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4], opts)
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :find,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :find,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :find,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec replace(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def replace(ref, old, new, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :replace, [old, new] ++ List.wrap(args), opts)
    end

    @spec ljust(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def ljust(ref, width, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :ljust, [width] ++ List.wrap(args), opts)
    end

    @spec istitle(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def istitle(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :istitle, [], opts)
    end

    @spec partition(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def partition(ref, sep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :partition, [sep], opts)
    end

    @spec isupper(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def isupper(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isupper, [], opts)
    end

    @spec endswith(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def endswith(ref) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [], [])
    end

    def endswith(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [], opts)
    end

    def endswith(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1], [])
    end

    def endswith(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1], opts)
    end

    def endswith(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2], [])
    end

    def endswith(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2], opts)
    end

    def endswith(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3], [])
    end

    def endswith(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3], opts)
    end

    def endswith(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4], [])
    end

    def endswith(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4], opts)
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :endswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :endswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :endswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :endswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec rpartition(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def rpartition(ref, sep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :rpartition, [sep], opts)
    end

    @spec swapcase(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def swapcase(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :swapcase, [], opts)
    end

    @spec join(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def join(ref, iterable, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :join, [iterable], opts)
    end

    @spec isdigit(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def isdigit(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isdigit, [], opts)
    end

    @spec index(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def index(ref) do
      SnakeBridge.Runtime.call_method(ref, :index, [], [])
    end

    def index(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [], opts)
    end

    def index(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1], [])
    end

    def index(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1], opts)
    end

    def index(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2], [])
    end

    def index(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2], opts)
    end

    def index(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3], [])
    end

    def index(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3], opts)
    end

    def index(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4], [])
    end

    def index(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4], opts)
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :index,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :index,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :index,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec lstrip(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def lstrip(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :lstrip, [] ++ List.wrap(args), opts)
    end

    @spec splitlines(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def splitlines(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :splitlines, [] ++ List.wrap(args), opts)
    end

    @spec zfill(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def zfill(ref, width, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :zfill, [width], opts)
    end

    @spec islower(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def islower(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :islower, [], opts)
    end

    @spec capitalize(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def capitalize(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :capitalize, [], opts)
    end

    @spec isnumeric(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def isnumeric(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isnumeric, [], opts)
    end

    @spec rjust(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def rjust(ref, width, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :rjust, [width] ++ List.wrap(args), opts)
    end

    @spec isidentifier(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def isidentifier(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isidentifier, [], opts)
    end

    @spec chat(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def chat(ref) do
      SnakeBridge.Runtime.get_attr(ref, :CHAT)
    end

    @spec completion(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def completion(ref) do
      SnakeBridge.Runtime.get_attr(ref, :COMPLETION)
    end

    @spec grpo_chat(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def grpo_chat(ref) do
      SnakeBridge.Runtime.get_attr(ref, :GRPO_CHAT)
    end

    @spec name(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def name(ref) do
      SnakeBridge.Runtime.get_attr(ref, :name)
    end

    @spec value(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def value(ref) do
      SnakeBridge.Runtime.get_attr(ref, :value)
    end
  end

  defmodule Clients.UtilsFinetune.TrainingStatus do
    def __snakebridge_python_name__, do: "dspy.clients.utils_finetune"
    def __snakebridge_python_class__, do: "TrainingStatus"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec format_map(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format_map(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_map(ref) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [], [])
    end

    def format_map(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [], opts)
    end

    def format_map(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1], [])
    end

    def format_map(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1], opts)
    end

    def format_map(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2], [])
    end

    def format_map(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2], opts)
    end

    def format_map(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3], [])
    end

    def format_map(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3], opts)
    end

    def format_map(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4], [])
    end

    def format_map(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4], opts)
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_map,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        opts
      )
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_map,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_map,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_map,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_map,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec isascii(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def isascii(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isascii, [], opts)
    end

    @spec rsplit(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def rsplit(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :rsplit, [] ++ List.wrap(args), opts)
    end

    @spec title(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def title(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :title, [], opts)
    end

    @spec upper(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def upper(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :upper, [], opts)
    end

    @spec maketrans(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec maketrans(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def maketrans(ref) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [], [])
    end

    def maketrans(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [], opts)
    end

    def maketrans(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1], [])
    end

    def maketrans(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1], opts)
    end

    def maketrans(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2], [])
    end

    def maketrans(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2], opts)
    end

    def maketrans(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3], [])
    end

    def maketrans(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3], opts)
    end

    def maketrans(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4], [])
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4], opts)
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :maketrans,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :maketrans,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :maketrans,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :maketrans,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec count(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec count(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def count(ref) do
      SnakeBridge.Runtime.call_method(ref, :count, [], [])
    end

    def count(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [], opts)
    end

    def count(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1], [])
    end

    def count(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1], opts)
    end

    def count(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2], [])
    end

    def count(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2], opts)
    end

    def count(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3], [])
    end

    def count(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3], opts)
    end

    def count(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4], [])
    end

    def count(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4], opts)
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :count,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :count,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :count,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec encode(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def encode(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :encode, [] ++ List.wrap(args), opts)
    end

    @spec isalpha(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def isalpha(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isalpha, [], opts)
    end

    @spec casefold(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def casefold(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :casefold, [], opts)
    end

    @spec rfind(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rfind(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def rfind(ref) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [], [])
    end

    def rfind(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [], opts)
    end

    def rfind(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1], [])
    end

    def rfind(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1], opts)
    end

    def rfind(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2], [])
    end

    def rfind(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2], opts)
    end

    def rfind(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3], [])
    end

    def rfind(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3], opts)
    end

    def rfind(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4], [])
    end

    def rfind(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4], opts)
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rfind,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rfind,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rfind,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec translate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def translate(ref, table, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :translate, [table], opts)
    end

    @spec startswith(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec startswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def startswith(ref) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [], [])
    end

    def startswith(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [], opts)
    end

    def startswith(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1], [])
    end

    def startswith(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1], opts)
    end

    def startswith(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2], [])
    end

    def startswith(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2], opts)
    end

    def startswith(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3], [])
    end

    def startswith(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3], opts)
    end

    def startswith(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4], [])
    end

    def startswith(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4], opts)
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :startswith,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        opts
      )
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :startswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :startswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :startswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :startswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec isalnum(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def isalnum(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isalnum, [], opts)
    end

    @spec isdecimal(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def isdecimal(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isdecimal, [], opts)
    end

    @spec isprintable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def isprintable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isprintable, [], opts)
    end

    @spec rstrip(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def rstrip(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :rstrip, [] ++ List.wrap(args), opts)
    end

    @spec removeprefix(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def removeprefix(ref, prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :removeprefix, [prefix], opts)
    end

    @spec split(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def split(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :split, [] ++ List.wrap(args), opts)
    end

    @spec rindex(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec rindex(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def rindex(ref) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [], [])
    end

    def rindex(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [], opts)
    end

    def rindex(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1], [])
    end

    def rindex(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1], opts)
    end

    def rindex(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2], [])
    end

    def rindex(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2], opts)
    end

    def rindex(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3], [])
    end

    def rindex(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3], opts)
    end

    def rindex(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4], [])
    end

    def rindex(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4], opts)
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rindex,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rindex,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rindex,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :rindex,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec lower(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lower(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :lower, [], opts)
    end

    @spec isspace(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def isspace(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isspace, [], opts)
    end

    @spec expandtabs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def expandtabs(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :expandtabs, [] ++ List.wrap(args), opts)
    end

    @spec strip(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def strip(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :strip, [] ++ List.wrap(args), opts)
    end

    @spec format(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref) do
      SnakeBridge.Runtime.call_method(ref, :format, [], [])
    end

    def format(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    def format(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1], [])
    end

    def format(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1], opts)
    end

    def format(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2], [])
    end

    def format(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2], opts)
    end

    def format(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3], [])
    end

    def format(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3], opts)
    end

    def format(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4], [])
    end

    def format(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4], opts)
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec removesuffix(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def removesuffix(ref, suffix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :removesuffix, [suffix], opts)
    end

    @spec center(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def center(ref, width, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :center, [width] ++ List.wrap(args), opts)
    end

    @spec find(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec find(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def find(ref) do
      SnakeBridge.Runtime.call_method(ref, :find, [], [])
    end

    def find(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [], opts)
    end

    def find(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1], [])
    end

    def find(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1], opts)
    end

    def find(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2], [])
    end

    def find(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2], opts)
    end

    def find(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3], [])
    end

    def find(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3], opts)
    end

    def find(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4], [])
    end

    def find(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4], opts)
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :find,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :find,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :find,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec replace(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def replace(ref, old, new, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :replace, [old, new] ++ List.wrap(args), opts)
    end

    @spec ljust(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def ljust(ref, width, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :ljust, [width] ++ List.wrap(args), opts)
    end

    @spec istitle(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def istitle(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :istitle, [], opts)
    end

    @spec partition(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def partition(ref, sep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :partition, [sep], opts)
    end

    @spec isupper(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def isupper(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isupper, [], opts)
    end

    @spec endswith(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec endswith(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def endswith(ref) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [], [])
    end

    def endswith(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [], opts)
    end

    def endswith(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1], [])
    end

    def endswith(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1], opts)
    end

    def endswith(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2], [])
    end

    def endswith(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2], opts)
    end

    def endswith(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3], [])
    end

    def endswith(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3], opts)
    end

    def endswith(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4], [])
    end

    def endswith(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4], opts)
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :endswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :endswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :endswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :endswith,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec rpartition(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def rpartition(ref, sep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :rpartition, [sep], opts)
    end

    @spec swapcase(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def swapcase(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :swapcase, [], opts)
    end

    @spec join(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def join(ref, iterable, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :join, [iterable], opts)
    end

    @spec isdigit(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def isdigit(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isdigit, [], opts)
    end

    @spec index(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec index(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def index(ref) do
      SnakeBridge.Runtime.call_method(ref, :index, [], [])
    end

    def index(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [], opts)
    end

    def index(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1], [])
    end

    def index(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1], opts)
    end

    def index(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2], [])
    end

    def index(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2], opts)
    end

    def index(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3], [])
    end

    def index(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3], opts)
    end

    def index(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4], [])
    end

    def index(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4], opts)
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :index,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :index,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :index,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec lstrip(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def lstrip(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :lstrip, [] ++ List.wrap(args), opts)
    end

    @spec splitlines(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def splitlines(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :splitlines, [] ++ List.wrap(args), opts)
    end

    @spec zfill(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def zfill(ref, width, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :zfill, [width], opts)
    end

    @spec islower(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def islower(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :islower, [], opts)
    end

    @spec capitalize(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def capitalize(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :capitalize, [], opts)
    end

    @spec isnumeric(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def isnumeric(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isnumeric, [], opts)
    end

    @spec rjust(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def rjust(ref, width, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :rjust, [width] ++ List.wrap(args), opts)
    end

    @spec isidentifier(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def isidentifier(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :isidentifier, [], opts)
    end

    @spec cancelled(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancelled(ref) do
      SnakeBridge.Runtime.get_attr(ref, :cancelled)
    end

    @spec failed(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def failed(ref) do
      SnakeBridge.Runtime.get_attr(ref, :failed)
    end

    @spec name(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def name(ref) do
      SnakeBridge.Runtime.get_attr(ref, :name)
    end

    @spec not_started(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def not_started(ref) do
      SnakeBridge.Runtime.get_attr(ref, :not_started)
    end

    @spec pending(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pending(ref) do
      SnakeBridge.Runtime.get_attr(ref, :pending)
    end

    @spec running(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def running(ref) do
      SnakeBridge.Runtime.get_attr(ref, :running)
    end

    @spec succeeded(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def succeeded(ref) do
      SnakeBridge.Runtime.get_attr(ref, :succeeded)
    end

    @spec value(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def value(ref) do
      SnakeBridge.Runtime.get_attr(ref, :value)
    end
  end

  defmodule Code do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Code"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec language(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def language(ref) do
      SnakeBridge.Runtime.get_attr(ref, :language)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule CodeAct do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "CodeAct"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, tools, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [signature, tools] ++ List.wrap(args),
        opts
      )
    end

    @spec _async_call_with_potential_trajectory_truncation(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _async_call_with_potential_trajectory_truncation(ref, module, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_async_call_with_potential_trajectory_truncation,
        [module, trajectory],
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _build_instructions(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _build_instructions(ref, signature, tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_instructions, [signature, tools], opts)
    end

    @spec _call_with_potential_trajectory_truncation(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_with_potential_trajectory_truncation(ref, module, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_with_potential_trajectory_truncation,
        [module, trajectory],
        opts
      )
    end

    @spec _execute_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _execute_code(ref, code, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_execute_code, [code], opts)
    end

    @spec _format_trajectory(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _format_trajectory(ref, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_trajectory, [trajectory], opts)
    end

    @spec _generate_instruction(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _generate_instruction(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_generate_instruction, [mode], opts)
    end

    @spec _generate_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _generate_signature(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_generate_signature, [mode], opts)
    end

    @spec _parse_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_code(ref, code_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_parse_code, [code_data], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec truncate_trajectory(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def truncate_trajectory(ref, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :truncate_trajectory, [trajectory], opts)
    end
  end

  defmodule CodeInterpreter do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "CodeInterpreter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec execute(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def execute(ref, code, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :execute, [code] ++ List.wrap(args), opts)
    end

    @spec shutdown(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def shutdown(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :shutdown, [], opts)
    end

    @spec start(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def start(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :start, [], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec _is_protocol(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_protocol)
    end

    @spec _is_runtime_protocol(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_runtime_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_runtime_protocol)
    end

    @spec tools(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def tools(ref) do
      SnakeBridge.Runtime.get_attr(ref, :tools)
    end
  end

  defmodule CodeInterpreterError do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "CodeInterpreterError"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec add_note(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def add_note(ref) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [], [])
    end

    def add_note(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [], opts)
    end

    def add_note(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], [])
    end

    def add_note(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], opts)
    end

    def add_note(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], [])
    end

    def add_note(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], opts)
    end

    def add_note(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], [])
    end

    def add_note(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec with_traceback(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_traceback(ref) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [], [])
    end

    def with_traceback(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [], opts)
    end

    def with_traceback(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], [])
    end

    def with_traceback(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], opts)
    end

    def with_traceback(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], [])
    end

    def with_traceback(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        opts
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec args(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def args(ref) do
      SnakeBridge.Runtime.get_attr(ref, :args)
    end
  end

  defmodule ColBERTv2 do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "ColBERTv2"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end
  end

  defmodule Completions do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Completions"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(list_or_dict, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [list_or_dict] ++ List.wrap(args),
        opts
      )
    end

    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end
  end

  defmodule Datasets.Alfworld.AlfWorld do
    def __snakebridge_python_name__, do: "dspy.datasets.alfworld"
    def __snakebridge_python_class__, do: "AlfWorld"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end
  end

  defmodule Datasets.Alfworld.Alfworld.AlfWorld do
    def __snakebridge_python_name__, do: "dspy.datasets.alfworld.alfworld"
    def __snakebridge_python_class__, do: "AlfWorld"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end
  end

  defmodule Datasets.Alfworld.Alfworld.EnvPool do
    def __snakebridge_python_name__, do: "dspy.datasets.alfworld.alfworld"
    def __snakebridge_python_class__, do: "EnvPool"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _acquire(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _acquire(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_acquire, [], opts)
    end

    @spec _release(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _release(ref, wid, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_release, [wid], opts)
    end

    @spec close_all(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def close_all(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :close_all, [], opts)
    end

    @spec session(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def session(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :session, [], opts)
    end
  end

  defmodule Datasets.Colors do
    def __snakebridge_python_name__, do: "dspy.datasets"
    def __snakebridge_python_class__, do: "Colors"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _shuffle_and_sample(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def _shuffle_and_sample(ref, split, data, size, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_shuffle_and_sample,
        [split, data, size] ++ List.wrap(args),
        opts
      )
    end

    @spec prepare_by_seed(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepare_by_seed(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepare_by_seed, [] ++ List.wrap(args), opts)
    end

    @spec reset_seeds(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def reset_seeds(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :reset_seeds, [] ++ List.wrap(args), opts)
    end

    @spec sorted_by_suffix(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def sorted_by_suffix(ref, colors, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :sorted_by_suffix, [colors], opts)
    end

    @spec dev(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dev(ref) do
      SnakeBridge.Runtime.get_attr(ref, :dev)
    end

    @spec test(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def test(ref) do
      SnakeBridge.Runtime.get_attr(ref, :test)
    end

    @spec train(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def train(ref) do
      SnakeBridge.Runtime.get_attr(ref, :train)
    end
  end

  defmodule Datasets.ColorsClass do
    def __snakebridge_python_name__, do: "dspy.datasets.colors"
    def __snakebridge_python_class__, do: "Colors"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _shuffle_and_sample(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def _shuffle_and_sample(ref, split, data, size, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_shuffle_and_sample,
        [split, data, size] ++ List.wrap(args),
        opts
      )
    end

    @spec prepare_by_seed(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepare_by_seed(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepare_by_seed, [] ++ List.wrap(args), opts)
    end

    @spec reset_seeds(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def reset_seeds(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :reset_seeds, [] ++ List.wrap(args), opts)
    end

    @spec sorted_by_suffix(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def sorted_by_suffix(ref, colors, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :sorted_by_suffix, [colors], opts)
    end

    @spec dev(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dev(ref) do
      SnakeBridge.Runtime.get_attr(ref, :dev)
    end

    @spec test(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def test(ref) do
      SnakeBridge.Runtime.get_attr(ref, :test)
    end

    @spec train(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def train(ref) do
      SnakeBridge.Runtime.get_attr(ref, :train)
    end
  end

  defmodule Datasets.DataLoader do
    def __snakebridge_python_name__, do: "dspy.datasets"
    def __snakebridge_python_class__, do: "DataLoader"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _shuffle_and_sample(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def _shuffle_and_sample(ref, split, data, size, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_shuffle_and_sample,
        [split, data, size] ++ List.wrap(args),
        opts
      )
    end

    @spec from_csv(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def from_csv(ref, file_path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_csv, [file_path] ++ List.wrap(args), opts)
    end

    @spec from_huggingface(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_huggingface(ref, dataset_name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :from_huggingface,
        [dataset_name] ++ List.wrap(args),
        opts
      )
    end

    @spec from_json(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def from_json(ref, file_path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_json, [file_path] ++ List.wrap(args), opts)
    end

    @spec from_pandas(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def from_pandas(ref, df, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_pandas, [df] ++ List.wrap(args), opts)
    end

    @spec from_parquet(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def from_parquet(ref, file_path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_parquet, [file_path] ++ List.wrap(args), opts)
    end

    @spec from_rm(SnakeBridge.Ref.t(), integer(), list(String.t()), list(String.t()), keyword()) ::
            {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def from_rm(ref, num_samples, fields, input_keys, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_rm, [num_samples, fields, input_keys], opts)
    end

    @spec prepare_by_seed(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepare_by_seed(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepare_by_seed, [] ++ List.wrap(args), opts)
    end

    @spec reset_seeds(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def reset_seeds(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :reset_seeds, [] ++ List.wrap(args), opts)
    end

    @spec sample(
            SnakeBridge.Ref.t(),
            list(Dspy.Primitives.Example.t()),
            integer(),
            list(term()),
            keyword()
          ) :: {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def sample(ref, dataset, n, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :sample, [dataset, n] ++ List.wrap(args), opts)
    end

    @spec train_test_split(
            SnakeBridge.Ref.t(),
            list(Dspy.Primitives.Example.t()),
            list(term()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def train_test_split(ref, dataset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :train_test_split, [dataset] ++ List.wrap(args), opts)
    end

    @spec dev(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dev(ref) do
      SnakeBridge.Runtime.get_attr(ref, :dev)
    end

    @spec test(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def test(ref) do
      SnakeBridge.Runtime.get_attr(ref, :test)
    end

    @spec train(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def train(ref) do
      SnakeBridge.Runtime.get_attr(ref, :train)
    end
  end

  defmodule Datasets.Dataloader.DataLoader do
    def __snakebridge_python_name__, do: "dspy.datasets.dataloader"
    def __snakebridge_python_class__, do: "DataLoader"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _shuffle_and_sample(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def _shuffle_and_sample(ref, split, data, size, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_shuffle_and_sample,
        [split, data, size] ++ List.wrap(args),
        opts
      )
    end

    @spec from_csv(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def from_csv(ref, file_path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_csv, [file_path] ++ List.wrap(args), opts)
    end

    @spec from_huggingface(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_huggingface(ref, dataset_name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :from_huggingface,
        [dataset_name] ++ List.wrap(args),
        opts
      )
    end

    @spec from_json(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def from_json(ref, file_path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_json, [file_path] ++ List.wrap(args), opts)
    end

    @spec from_pandas(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def from_pandas(ref, df, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_pandas, [df] ++ List.wrap(args), opts)
    end

    @spec from_parquet(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def from_parquet(ref, file_path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_parquet, [file_path] ++ List.wrap(args), opts)
    end

    @spec from_rm(SnakeBridge.Ref.t(), integer(), list(String.t()), list(String.t()), keyword()) ::
            {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def from_rm(ref, num_samples, fields, input_keys, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_rm, [num_samples, fields, input_keys], opts)
    end

    @spec prepare_by_seed(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepare_by_seed(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepare_by_seed, [] ++ List.wrap(args), opts)
    end

    @spec reset_seeds(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def reset_seeds(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :reset_seeds, [] ++ List.wrap(args), opts)
    end

    @spec sample(
            SnakeBridge.Ref.t(),
            list(Dspy.Primitives.Example.t()),
            integer(),
            list(term()),
            keyword()
          ) :: {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def sample(ref, dataset, n, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :sample, [dataset, n] ++ List.wrap(args), opts)
    end

    @spec train_test_split(
            SnakeBridge.Ref.t(),
            list(Dspy.Primitives.Example.t()),
            list(term()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def train_test_split(ref, dataset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :train_test_split, [dataset] ++ List.wrap(args), opts)
    end

    @spec dev(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dev(ref) do
      SnakeBridge.Runtime.get_attr(ref, :dev)
    end

    @spec test(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def test(ref) do
      SnakeBridge.Runtime.get_attr(ref, :test)
    end

    @spec train(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def train(ref) do
      SnakeBridge.Runtime.get_attr(ref, :train)
    end
  end

  defmodule Datasets.Dataset do
    def __snakebridge_python_name__, do: "dspy.datasets.dataset"
    def __snakebridge_python_class__, do: "Dataset"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _shuffle_and_sample(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def _shuffle_and_sample(ref, split, data, size, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_shuffle_and_sample,
        [split, data, size] ++ List.wrap(args),
        opts
      )
    end

    @spec prepare_by_seed(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepare_by_seed(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepare_by_seed, [] ++ List.wrap(args), opts)
    end

    @spec reset_seeds(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def reset_seeds(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :reset_seeds, [] ++ List.wrap(args), opts)
    end

    @spec dev(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dev(ref) do
      SnakeBridge.Runtime.get_attr(ref, :dev)
    end

    @spec test(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def test(ref) do
      SnakeBridge.Runtime.get_attr(ref, :test)
    end

    @spec train(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def train(ref) do
      SnakeBridge.Runtime.get_attr(ref, :train)
    end
  end

  defmodule Datasets.DatasetClass do
    def __snakebridge_python_name__, do: "dspy.datasets"
    def __snakebridge_python_class__, do: "Dataset"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _shuffle_and_sample(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def _shuffle_and_sample(ref, split, data, size, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_shuffle_and_sample,
        [split, data, size] ++ List.wrap(args),
        opts
      )
    end

    @spec prepare_by_seed(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepare_by_seed(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepare_by_seed, [] ++ List.wrap(args), opts)
    end

    @spec reset_seeds(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def reset_seeds(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :reset_seeds, [] ++ List.wrap(args), opts)
    end

    @spec dev(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dev(ref) do
      SnakeBridge.Runtime.get_attr(ref, :dev)
    end

    @spec test(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def test(ref) do
      SnakeBridge.Runtime.get_attr(ref, :test)
    end

    @spec train(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def train(ref) do
      SnakeBridge.Runtime.get_attr(ref, :train)
    end
  end

  defmodule Datasets.Gsm8k.GSM8K do
    def __snakebridge_python_name__, do: "dspy.datasets.gsm8k"
    def __snakebridge_python_class__, do: "GSM8K"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end
  end

  defmodule Datasets.HotPotQA do
    def __snakebridge_python_name__, do: "dspy.datasets"
    def __snakebridge_python_class__, do: "HotPotQA"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _shuffle_and_sample(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def _shuffle_and_sample(ref, split, data, size, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_shuffle_and_sample,
        [split, data, size] ++ List.wrap(args),
        opts
      )
    end

    @spec prepare_by_seed(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepare_by_seed(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepare_by_seed, [] ++ List.wrap(args), opts)
    end

    @spec reset_seeds(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def reset_seeds(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :reset_seeds, [] ++ List.wrap(args), opts)
    end

    @spec dev(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dev(ref) do
      SnakeBridge.Runtime.get_attr(ref, :dev)
    end

    @spec test(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def test(ref) do
      SnakeBridge.Runtime.get_attr(ref, :test)
    end

    @spec train(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def train(ref) do
      SnakeBridge.Runtime.get_attr(ref, :train)
    end
  end

  defmodule Datasets.Hotpotqa.HotPotQA do
    def __snakebridge_python_name__, do: "dspy.datasets.hotpotqa"
    def __snakebridge_python_class__, do: "HotPotQA"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _shuffle_and_sample(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def _shuffle_and_sample(ref, split, data, size, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_shuffle_and_sample,
        [split, data, size] ++ List.wrap(args),
        opts
      )
    end

    @spec prepare_by_seed(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepare_by_seed(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepare_by_seed, [] ++ List.wrap(args), opts)
    end

    @spec reset_seeds(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def reset_seeds(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :reset_seeds, [] ++ List.wrap(args), opts)
    end

    @spec dev(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dev(ref) do
      SnakeBridge.Runtime.get_attr(ref, :dev)
    end

    @spec test(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def test(ref) do
      SnakeBridge.Runtime.get_attr(ref, :test)
    end

    @spec train(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def train(ref) do
      SnakeBridge.Runtime.get_attr(ref, :train)
    end
  end

  defmodule Datasets.MATH do
    def __snakebridge_python_name__, do: "dspy.datasets"
    def __snakebridge_python_class__, do: "MATH"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(subset, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [subset], opts)
    end

    @spec metric(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def metric(ref, example, pred, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :metric, [example, pred] ++ List.wrap(args), opts)
    end
  end

  defmodule Datasets.MATHClass do
    def __snakebridge_python_name__, do: "dspy.datasets.math"
    def __snakebridge_python_class__, do: "MATH"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(subset, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [subset], opts)
    end

    @spec metric(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def metric(ref, example, pred, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :metric, [example, pred] ++ List.wrap(args), opts)
    end
  end

  defmodule Dsp.Colbertv2.ColBERTv2 do
    def __snakebridge_python_name__, do: "dspy.dsp.colbertv2"
    def __snakebridge_python_class__, do: "ColBERTv2"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end
  end

  defmodule Dsp.Colbertv2.ColBERTv2RerankerLocal do
    def __snakebridge_python_name__, do: "dspy.dsp.colbertv2"
    def __snakebridge_python_class__, do: "ColBERTv2RerankerLocal"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, query, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [query] ++ List.wrap(args), opts)
    end
  end

  defmodule Dsp.Colbertv2.ColBERTv2RetrieverLocal do
    def __snakebridge_python_name__, do: "dspy.dsp.colbertv2"
    def __snakebridge_python_class__, do: "ColBERTv2RetrieverLocal"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(String.t()), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(passages, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [passages] ++ List.wrap(args), opts)
    end

    @spec build_index(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def build_index(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :build_index, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, query, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [query] ++ List.wrap(args), opts)
    end

    @spec get_index(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_index(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_index, [], opts)
    end
  end

  defmodule Dsp.Utils.Dotdict do
    def __snakebridge_python_name__, do: "dspy.dsp.utils"
    def __snakebridge_python_class__, do: "dotdict"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec clear(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def clear(ref) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], [])
    end

    def clear(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
    end

    def clear(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], [])
    end

    def clear(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], opts)
    end

    def clear(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], [])
    end

    def clear(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], opts)
    end

    def clear(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], [])
    end

    def clear(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec copy(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], [])
    end

    def copy(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    def copy(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], [])
    end

    def copy(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], opts)
    end

    def copy(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], [])
    end

    def copy(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], opts)
    end

    def copy(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], [])
    end

    def copy(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec fromkeys(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def fromkeys(ref, iterable, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :fromkeys, [iterable] ++ List.wrap(args), opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec items(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref) do
      SnakeBridge.Runtime.call_method(ref, :items, [], [])
    end

    def items(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end

    def items(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], [])
    end

    def items(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], opts)
    end

    def items(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], [])
    end

    def items(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], opts)
    end

    def items(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], [])
    end

    def items(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec keys(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], [])
    end

    def keys(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], opts)
    end

    def keys(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], [])
    end

    def keys(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], opts)
    end

    def keys(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], [])
    end

    def keys(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], opts)
    end

    def keys(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], [])
    end

    def keys(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec pop(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pop(ref) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], [])
    end

    def pop(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], opts)
    end

    def pop(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], [])
    end

    def pop(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], opts)
    end

    def pop(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], [])
    end

    def pop(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], opts)
    end

    def pop(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], [])
    end

    def pop(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec popitem(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def popitem(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :popitem, [], opts)
    end

    @spec setdefault(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def setdefault(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :setdefault, [key] ++ List.wrap(args), opts)
    end

    @spec update(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def update(ref) do
      SnakeBridge.Runtime.call_method(ref, :update, [], [])
    end

    def update(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [], opts)
    end

    def update(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], [])
    end

    def update(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], opts)
    end

    def update(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], [])
    end

    def update(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], opts)
    end

    def update(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], [])
    end

    def update(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec values(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref) do
      SnakeBridge.Runtime.call_method(ref, :values, [], [])
    end

    def values(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [], opts)
    end

    def values(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], [])
    end

    def values(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], opts)
    end

    def values(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], [])
    end

    def values(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], opts)
    end

    def values(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], [])
    end

    def values(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end
  end

  defmodule Dsp.Utils.DotdictLax do
    def __snakebridge_python_name__, do: "dspy.dsp.utils"
    def __snakebridge_python_class__, do: "dotdict_lax"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec clear(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def clear(ref) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], [])
    end

    def clear(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
    end

    def clear(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], [])
    end

    def clear(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], opts)
    end

    def clear(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], [])
    end

    def clear(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], opts)
    end

    def clear(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], [])
    end

    def clear(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec copy(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], [])
    end

    def copy(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    def copy(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], [])
    end

    def copy(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], opts)
    end

    def copy(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], [])
    end

    def copy(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], opts)
    end

    def copy(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], [])
    end

    def copy(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec fromkeys(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def fromkeys(ref, iterable, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :fromkeys, [iterable] ++ List.wrap(args), opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec items(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref) do
      SnakeBridge.Runtime.call_method(ref, :items, [], [])
    end

    def items(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end

    def items(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], [])
    end

    def items(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], opts)
    end

    def items(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], [])
    end

    def items(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], opts)
    end

    def items(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], [])
    end

    def items(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec keys(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], [])
    end

    def keys(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], opts)
    end

    def keys(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], [])
    end

    def keys(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], opts)
    end

    def keys(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], [])
    end

    def keys(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], opts)
    end

    def keys(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], [])
    end

    def keys(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec pop(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pop(ref) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], [])
    end

    def pop(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], opts)
    end

    def pop(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], [])
    end

    def pop(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], opts)
    end

    def pop(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], [])
    end

    def pop(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], opts)
    end

    def pop(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], [])
    end

    def pop(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec popitem(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def popitem(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :popitem, [], opts)
    end

    @spec setdefault(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def setdefault(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :setdefault, [key] ++ List.wrap(args), opts)
    end

    @spec update(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def update(ref) do
      SnakeBridge.Runtime.call_method(ref, :update, [], [])
    end

    def update(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [], opts)
    end

    def update(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], [])
    end

    def update(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], opts)
    end

    def update(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], [])
    end

    def update(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], opts)
    end

    def update(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], [])
    end

    def update(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec values(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref) do
      SnakeBridge.Runtime.call_method(ref, :values, [], [])
    end

    def values(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [], opts)
    end

    def values(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], [])
    end

    def values(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], opts)
    end

    def values(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], [])
    end

    def values(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], opts)
    end

    def values(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], [])
    end

    def values(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end
  end

  defmodule Dsp.Utils.Dpr.SimpleTokenizer do
    def __snakebridge_python_name__, do: "dspy.dsp.utils.dpr"
    def __snakebridge_python_class__, do: "SimpleTokenizer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec shutdown(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def shutdown(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :shutdown, [], opts)
    end

    @spec tokenize(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def tokenize(ref, text, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :tokenize, [text], opts)
    end

    @spec alpha_num(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def alpha_num(ref) do
      SnakeBridge.Runtime.get_attr(ref, :ALPHA_NUM)
    end

    @spec non_ws(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def non_ws(ref) do
      SnakeBridge.Runtime.get_attr(ref, :NON_WS)
    end
  end

  defmodule Dsp.Utils.Dpr.Tokenizer do
    def __snakebridge_python_name__, do: "dspy.dsp.utils.dpr"
    def __snakebridge_python_class__, do: "Tokenizer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec shutdown(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def shutdown(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :shutdown, [], opts)
    end

    @spec tokenize(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def tokenize(ref, text, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :tokenize, [text], opts)
    end
  end

  defmodule Dsp.Utils.Dpr.Tokens do
    def __snakebridge_python_name__, do: "dspy.dsp.utils.dpr"
    def __snakebridge_python_class__, do: "Tokens"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(data, annotators, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [data, annotators] ++ List.wrap(args),
        opts
      )
    end

    @spec entities(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def entities(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :entities, [], opts)
    end

    @spec entity_groups(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def entity_groups(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :entity_groups, [], opts)
    end

    @spec lemmas(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lemmas(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :lemmas, [], opts)
    end

    @spec ngrams(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def ngrams(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :ngrams, [] ++ List.wrap(args), opts)
    end

    @spec offsets(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def offsets(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :offsets, [], opts)
    end

    @spec pos(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pos(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :pos, [], opts)
    end

    @spec slice(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def slice(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :slice, [] ++ List.wrap(args), opts)
    end

    @spec untokenize(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def untokenize(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :untokenize, [], opts)
    end

    @spec words(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def words(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :words, [] ++ List.wrap(args), opts)
    end

    @spec lemma(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lemma(ref) do
      SnakeBridge.Runtime.get_attr(ref, :LEMMA)
    end

    @spec ner(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def ner(ref) do
      SnakeBridge.Runtime.get_attr(ref, :NER)
    end

    @spec pos_attr(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pos_attr(ref) do
      SnakeBridge.Runtime.get_attr(ref, :POS)
    end

    @spec span(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def span(ref) do
      SnakeBridge.Runtime.get_attr(ref, :SPAN)
    end

    @spec text(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def text(ref) do
      SnakeBridge.Runtime.get_attr(ref, :TEXT)
    end

    @spec text_ws(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def text_ws(ref) do
      SnakeBridge.Runtime.get_attr(ref, :TEXT_WS)
    end
  end

  defmodule Dsp.Utils.NullContextManager do
    def __snakebridge_python_name__, do: "dspy.dsp.utils"
    def __snakebridge_python_class__, do: "NullContextManager"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end
  end

  defmodule Dsp.Utils.Settings.Settings do
    def __snakebridge_python_name__, do: "dspy.dsp.utils.settings"
    def __snakebridge_python_class__, do: "Settings"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _ensure_configure_allowed(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _ensure_configure_allowed(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_ensure_configure_allowed, [], opts)
    end

    @spec configure(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def configure(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :configure, [], opts)
    end

    @spec context(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def context(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :context, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def load(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path], opts)
    end

    @spec save(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec _instance(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _instance(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_instance)
    end

    @spec config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :config)
    end

    @spec lock(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lock(ref) do
      SnakeBridge.Runtime.get_attr(ref, :lock)
    end
  end

  defmodule Dsp.Utils.SettingsClass do
    def __snakebridge_python_name__, do: "dspy.dsp.utils"
    def __snakebridge_python_class__, do: "Settings"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _ensure_configure_allowed(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _ensure_configure_allowed(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_ensure_configure_allowed, [], opts)
    end

    @spec configure(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def configure(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :configure, [], opts)
    end

    @spec context(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def context(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :context, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def load(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path], opts)
    end

    @spec save(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec _instance(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _instance(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_instance)
    end

    @spec config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :config)
    end

    @spec lock(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lock(ref) do
      SnakeBridge.Runtime.get_attr(ref, :lock)
    end
  end

  defmodule Dsp.Utils.SimpleTokenizer do
    def __snakebridge_python_name__, do: "dspy.dsp.utils"
    def __snakebridge_python_class__, do: "SimpleTokenizer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec shutdown(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def shutdown(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :shutdown, [], opts)
    end

    @spec tokenize(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def tokenize(ref, text, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :tokenize, [text], opts)
    end

    @spec alpha_num(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def alpha_num(ref) do
      SnakeBridge.Runtime.get_attr(ref, :ALPHA_NUM)
    end

    @spec non_ws(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def non_ws(ref) do
      SnakeBridge.Runtime.get_attr(ref, :NON_WS)
    end
  end

  defmodule Dsp.Utils.Tokenizer do
    def __snakebridge_python_name__, do: "dspy.dsp.utils"
    def __snakebridge_python_class__, do: "Tokenizer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec shutdown(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def shutdown(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :shutdown, [], opts)
    end

    @spec tokenize(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def tokenize(ref, text, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :tokenize, [text], opts)
    end
  end

  defmodule Dsp.Utils.Tokens do
    def __snakebridge_python_name__, do: "dspy.dsp.utils"
    def __snakebridge_python_class__, do: "Tokens"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(data, annotators, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [data, annotators] ++ List.wrap(args),
        opts
      )
    end

    @spec entities(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def entities(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :entities, [], opts)
    end

    @spec entity_groups(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def entity_groups(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :entity_groups, [], opts)
    end

    @spec lemmas(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lemmas(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :lemmas, [], opts)
    end

    @spec ngrams(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def ngrams(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :ngrams, [] ++ List.wrap(args), opts)
    end

    @spec offsets(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def offsets(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :offsets, [], opts)
    end

    @spec pos(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pos(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :pos, [], opts)
    end

    @spec slice(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def slice(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :slice, [] ++ List.wrap(args), opts)
    end

    @spec untokenize(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def untokenize(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :untokenize, [], opts)
    end

    @spec words(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def words(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :words, [] ++ List.wrap(args), opts)
    end

    @spec lemma(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lemma(ref) do
      SnakeBridge.Runtime.get_attr(ref, :LEMMA)
    end

    @spec ner(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def ner(ref) do
      SnakeBridge.Runtime.get_attr(ref, :NER)
    end

    @spec pos_attr(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pos_attr(ref) do
      SnakeBridge.Runtime.get_attr(ref, :POS)
    end

    @spec span(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def span(ref) do
      SnakeBridge.Runtime.get_attr(ref, :SPAN)
    end

    @spec text(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def text(ref) do
      SnakeBridge.Runtime.get_attr(ref, :TEXT)
    end

    @spec text_ws(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def text_ws(ref) do
      SnakeBridge.Runtime.get_attr(ref, :TEXT_WS)
    end
  end

  defmodule Dsp.Utils.Utils.Dotdict do
    def __snakebridge_python_name__, do: "dspy.dsp.utils.utils"
    def __snakebridge_python_class__, do: "dotdict"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec clear(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def clear(ref) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], [])
    end

    def clear(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
    end

    def clear(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], [])
    end

    def clear(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], opts)
    end

    def clear(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], [])
    end

    def clear(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], opts)
    end

    def clear(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], [])
    end

    def clear(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec copy(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], [])
    end

    def copy(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    def copy(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], [])
    end

    def copy(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], opts)
    end

    def copy(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], [])
    end

    def copy(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], opts)
    end

    def copy(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], [])
    end

    def copy(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec fromkeys(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def fromkeys(ref, iterable, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :fromkeys, [iterable] ++ List.wrap(args), opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec items(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref) do
      SnakeBridge.Runtime.call_method(ref, :items, [], [])
    end

    def items(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end

    def items(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], [])
    end

    def items(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], opts)
    end

    def items(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], [])
    end

    def items(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], opts)
    end

    def items(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], [])
    end

    def items(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec keys(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], [])
    end

    def keys(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], opts)
    end

    def keys(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], [])
    end

    def keys(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], opts)
    end

    def keys(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], [])
    end

    def keys(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], opts)
    end

    def keys(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], [])
    end

    def keys(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec pop(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pop(ref) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], [])
    end

    def pop(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], opts)
    end

    def pop(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], [])
    end

    def pop(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], opts)
    end

    def pop(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], [])
    end

    def pop(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], opts)
    end

    def pop(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], [])
    end

    def pop(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec popitem(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def popitem(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :popitem, [], opts)
    end

    @spec setdefault(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def setdefault(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :setdefault, [key] ++ List.wrap(args), opts)
    end

    @spec update(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def update(ref) do
      SnakeBridge.Runtime.call_method(ref, :update, [], [])
    end

    def update(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [], opts)
    end

    def update(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], [])
    end

    def update(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], opts)
    end

    def update(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], [])
    end

    def update(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], opts)
    end

    def update(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], [])
    end

    def update(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec values(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref) do
      SnakeBridge.Runtime.call_method(ref, :values, [], [])
    end

    def values(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [], opts)
    end

    def values(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], [])
    end

    def values(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], opts)
    end

    def values(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], [])
    end

    def values(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], opts)
    end

    def values(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], [])
    end

    def values(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end
  end

  defmodule Dsp.Utils.Utils.DotdictLax do
    def __snakebridge_python_name__, do: "dspy.dsp.utils.utils"
    def __snakebridge_python_class__, do: "dotdict_lax"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec clear(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def clear(ref) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], [])
    end

    def clear(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
    end

    def clear(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], [])
    end

    def clear(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], opts)
    end

    def clear(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], [])
    end

    def clear(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], opts)
    end

    def clear(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], [])
    end

    def clear(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec copy(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], [])
    end

    def copy(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    def copy(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], [])
    end

    def copy(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], opts)
    end

    def copy(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], [])
    end

    def copy(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], opts)
    end

    def copy(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], [])
    end

    def copy(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec fromkeys(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def fromkeys(ref, iterable, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :fromkeys, [iterable] ++ List.wrap(args), opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec items(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref) do
      SnakeBridge.Runtime.call_method(ref, :items, [], [])
    end

    def items(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end

    def items(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], [])
    end

    def items(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], opts)
    end

    def items(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], [])
    end

    def items(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], opts)
    end

    def items(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], [])
    end

    def items(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec keys(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], [])
    end

    def keys(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], opts)
    end

    def keys(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], [])
    end

    def keys(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], opts)
    end

    def keys(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], [])
    end

    def keys(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], opts)
    end

    def keys(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], [])
    end

    def keys(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec pop(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pop(ref) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], [])
    end

    def pop(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], opts)
    end

    def pop(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], [])
    end

    def pop(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], opts)
    end

    def pop(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], [])
    end

    def pop(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], opts)
    end

    def pop(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], [])
    end

    def pop(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec popitem(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def popitem(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :popitem, [], opts)
    end

    @spec setdefault(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def setdefault(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :setdefault, [key] ++ List.wrap(args), opts)
    end

    @spec update(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def update(ref) do
      SnakeBridge.Runtime.call_method(ref, :update, [], [])
    end

    def update(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [], opts)
    end

    def update(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], [])
    end

    def update(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], opts)
    end

    def update(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], [])
    end

    def update(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], opts)
    end

    def update(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], [])
    end

    def update(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec values(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref) do
      SnakeBridge.Runtime.call_method(ref, :values, [], [])
    end

    def values(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [], opts)
    end

    def values(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], [])
    end

    def values(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], opts)
    end

    def values(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], [])
    end

    def values(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], opts)
    end

    def values(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], [])
    end

    def values(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end
  end

  defmodule Dsp.Utils.Utils.NullContextManager do
    def __snakebridge_python_name__, do: "dspy.dsp.utils.utils"
    def __snakebridge_python_class__, do: "NullContextManager"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end
  end

  defmodule Embedder do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Embedder"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t() | term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [model] ++ List.wrap(args), opts)
    end

    @spec _postprocess(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _postprocess(ref, embeddings_list, is_single_input, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_postprocess,
        [embeddings_list, is_single_input],
        opts
      )
    end

    @spec _preprocess(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _preprocess(ref, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_preprocess, [inputs] ++ List.wrap(args), opts)
    end

    @spec acall(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def acall(ref, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [inputs] ++ List.wrap(args), opts)
    end
  end

  defmodule Embeddings do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Embeddings"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(String.t()), term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(corpus, embedder, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [corpus, embedder] ++ List.wrap(args),
        opts
      )
    end

    @spec _batch_forward(SnakeBridge.Ref.t(), list(String.t()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _batch_forward(ref, queries, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_batch_forward, [queries], opts)
    end

    @spec _build_faiss(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _build_faiss(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_faiss, [], opts)
    end

    @spec _faiss_search(SnakeBridge.Ref.t(), term(), integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _faiss_search(ref, query_embeddings, num_candidates, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_faiss_search,
        [query_embeddings, num_candidates],
        opts
      )
    end

    @spec _normalize(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _normalize(ref, embeddings, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_normalize, [embeddings], opts)
    end

    @spec _rerank_and_predict(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _rerank_and_predict(ref, q_embeds, candidate_indices, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_rerank_and_predict,
        [q_embeds, candidate_indices],
        opts
      )
    end

    @spec forward(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, query, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [query], opts)
    end

    @spec from_saved(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_saved(ref, path, embedder, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_saved, [path, embedder], opts)
    end

    @spec load(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, embedder, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path, embedder], opts)
    end

    @spec save(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :save, [path], opts)
    end
  end

  defmodule Ensemble do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Ensemble"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, programs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :compile, [programs], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Evaluate.AutoEvaluation.AnswerCompleteness do
    def __snakebridge_python_name__, do: "dspy.evaluate.auto_evaluation"
    def __snakebridge_python_class__, do: "AnswerCompleteness"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Evaluate.AutoEvaluation.AnswerGroundedness do
    def __snakebridge_python_name__, do: "dspy.evaluate.auto_evaluation"
    def __snakebridge_python_class__, do: "AnswerGroundedness"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Evaluate.AutoEvaluation.CompleteAndGrounded do
    def __snakebridge_python_name__, do: "dspy.evaluate.auto_evaluation"
    def __snakebridge_python_class__, do: "CompleteAndGrounded"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, example, pred, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [example, pred] ++ List.wrap(args), opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Evaluate.AutoEvaluation.DecompositionalSemanticRecallPrecision do
    def __snakebridge_python_name__, do: "dspy.evaluate.auto_evaluation"
    def __snakebridge_python_class__, do: "DecompositionalSemanticRecallPrecision"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Evaluate.AutoEvaluation.SemanticF1 do
    def __snakebridge_python_name__, do: "dspy.evaluate.auto_evaluation"
    def __snakebridge_python_class__, do: "SemanticF1"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, example, pred, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [example, pred] ++ List.wrap(args), opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Evaluate.AutoEvaluation.SemanticRecallPrecision do
    def __snakebridge_python_name__, do: "dspy.evaluate.auto_evaluation"
    def __snakebridge_python_class__, do: "SemanticRecallPrecision"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Evaluate.CompleteAndGrounded do
    def __snakebridge_python_name__, do: "dspy.evaluate"
    def __snakebridge_python_class__, do: "CompleteAndGrounded"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, example, pred, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [example, pred] ++ List.wrap(args), opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Evaluate.Evaluate.Evaluate do
    def __snakebridge_python_name__, do: "dspy.evaluate.evaluate"
    def __snakebridge_python_class__, do: "Evaluate"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["devset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _construct_result_table(
            SnakeBridge.Ref.t(),
            list({term(), term(), term()}),
            String.t(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _construct_result_table(ref, results, metric_name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_construct_result_table, [results, metric_name], opts)
    end

    @spec _display_result_table(SnakeBridge.Ref.t(), term(), term(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _display_result_table(ref, result_df, display_table, metric_name, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_display_result_table,
        [result_df, display_table, metric_name],
        opts
      )
    end

    @spec _prepare_results_output(
            SnakeBridge.Ref.t(),
            list({Dspy.Primitives.Example.t(), Dspy.Primitives.Example.t(), term()}),
            String.t(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_results_output(ref, results, metric_name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_prepare_results_output, [results, metric_name], opts)
    end
  end

  defmodule Evaluate.Evaluate.EvaluationResult do
    def __snakebridge_python_name__, do: "dspy.evaluate.evaluate"
    def __snakebridge_python_class__, do: "EvaluationResult"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            float(),
            list({Dspy.Primitives.Example.t(), Dspy.Primitives.Example.t(), term()}),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(score, results, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [score, results], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec from_completions(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_completions(ref, list_or_dict, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :from_completions,
        [list_or_dict] ++ List.wrap(args),
        opts
      )
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec get_lm_usage(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm_usage(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm_usage, [], opts)
    end

    @spec inputs(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inputs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :inputs, [], opts)
    end

    @spec items(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :items, [] ++ List.wrap(args), opts)
    end

    @spec keys(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :keys, [] ++ List.wrap(args), opts)
    end

    @spec labels(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def labels(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :labels, [], opts)
    end

    @spec set_lm_usage(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm_usage(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm_usage, [value], opts)
    end

    @spec to_dict(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "toDict", [], opts)
    end

    @spec values(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :values, [] ++ List.wrap(args), opts)
    end

    @spec with_inputs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_inputs(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_inputs, [] ++ List.wrap(args), opts)
    end

    @spec without(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def without(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :without, [] ++ List.wrap(args), opts)
    end

    @spec completions(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def completions(ref) do
      SnakeBridge.Runtime.get_attr(ref, :completions)
    end
  end

  defmodule Evaluate.EvaluateClass3 do
    def __snakebridge_python_name__, do: "dspy.evaluate"
    def __snakebridge_python_class__, do: "Evaluate"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["devset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _construct_result_table(
            SnakeBridge.Ref.t(),
            list({term(), term(), term()}),
            String.t(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _construct_result_table(ref, results, metric_name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_construct_result_table, [results, metric_name], opts)
    end

    @spec _display_result_table(SnakeBridge.Ref.t(), term(), term(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _display_result_table(ref, result_df, display_table, metric_name, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_display_result_table,
        [result_df, display_table, metric_name],
        opts
      )
    end

    @spec _prepare_results_output(
            SnakeBridge.Ref.t(),
            list({Dspy.Primitives.Example.t(), Dspy.Primitives.Example.t(), term()}),
            String.t(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_results_output(ref, results, metric_name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_prepare_results_output, [results, metric_name], opts)
    end
  end

  defmodule Evaluate.EvaluationResult do
    def __snakebridge_python_name__, do: "dspy.evaluate"
    def __snakebridge_python_class__, do: "EvaluationResult"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            float(),
            list({Dspy.Primitives.Example.t(), Dspy.Primitives.Example.t(), term()}),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(score, results, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [score, results], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec from_completions(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_completions(ref, list_or_dict, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :from_completions,
        [list_or_dict] ++ List.wrap(args),
        opts
      )
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec get_lm_usage(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm_usage(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm_usage, [], opts)
    end

    @spec inputs(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inputs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :inputs, [], opts)
    end

    @spec items(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :items, [] ++ List.wrap(args), opts)
    end

    @spec keys(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :keys, [] ++ List.wrap(args), opts)
    end

    @spec labels(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def labels(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :labels, [], opts)
    end

    @spec set_lm_usage(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm_usage(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm_usage, [value], opts)
    end

    @spec to_dict(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "toDict", [], opts)
    end

    @spec values(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :values, [] ++ List.wrap(args), opts)
    end

    @spec with_inputs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_inputs(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_inputs, [] ++ List.wrap(args), opts)
    end

    @spec without(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def without(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :without, [] ++ List.wrap(args), opts)
    end

    @spec completions(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def completions(ref) do
      SnakeBridge.Runtime.get_attr(ref, :completions)
    end
  end

  defmodule Evaluate.SemanticF1 do
    def __snakebridge_python_name__, do: "dspy.evaluate"
    def __snakebridge_python_class__, do: "SemanticF1"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, example, pred, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [example, pred] ++ List.wrap(args), opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule EvaluateClass do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Evaluate"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["devset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _construct_result_table(
            SnakeBridge.Ref.t(),
            list({term(), term(), term()}),
            String.t(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _construct_result_table(ref, results, metric_name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_construct_result_table, [results, metric_name], opts)
    end

    @spec _display_result_table(SnakeBridge.Ref.t(), term(), term(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _display_result_table(ref, result_df, display_table, metric_name, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_display_result_table,
        [result_df, display_table, metric_name],
        opts
      )
    end

    @spec _prepare_results_output(
            SnakeBridge.Ref.t(),
            list({Dspy.Primitives.Example.t(), Dspy.Primitives.Example.t(), term()}),
            String.t(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_results_output(ref, results, metric_name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_prepare_results_output, [results, metric_name], opts)
    end
  end

  defmodule Example do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Example"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec inputs(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inputs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :inputs, [], opts)
    end

    @spec items(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :items, [] ++ List.wrap(args), opts)
    end

    @spec keys(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :keys, [] ++ List.wrap(args), opts)
    end

    @spec labels(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def labels(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :labels, [], opts)
    end

    @spec to_dict(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "toDict", [], opts)
    end

    @spec values(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :values, [] ++ List.wrap(args), opts)
    end

    @spec with_inputs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_inputs(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_inputs, [] ++ List.wrap(args), opts)
    end

    @spec without(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def without(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :without, [] ++ List.wrap(args), opts)
    end
  end

  defmodule Experimental.Citations do
    def __snakebridge_python_name__, do: "dspy.experimental"
    def __snakebridge_python_class__, do: "Citations"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Citation.Citations.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.Citation.Citations.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec citation(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def citation(ref, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)

      missing_kw =
        ["cited_text", "document_index", "start_char_index", "end_char_index"]
        |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, "Citation", [], opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec from_dict_list(SnakeBridge.Ref.t(), list(%{optional(String.t()) => term()}), keyword()) ::
            {:ok, Dspy.Adapters.Types.Citation.Citations.t()} | {:error, Snakepit.Error.t()}
    def from_dict_list(ref, citations_dicts, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_dict_list, [citations_dicts], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Experimental.Document do
    def __snakebridge_python_name__, do: "dspy.experimental"
    def __snakebridge_python_class__, do: "Document"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule File do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "File"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec from_file_id(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.File.File.t()} | {:error, Snakepit.Error.t()}
    def from_file_id(ref, file_id, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_file_id, [file_id] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec from_bytes(SnakeBridge.Ref.t(), binary(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.File.File.t()} | {:error, Snakepit.Error.t()}
    def from_bytes(ref, file_bytes, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_bytes, [file_bytes] ++ List.wrap(args), opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec from_path(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, Dspy.Adapters.Types.File.File.t()} | {:error, Snakepit.Error.t()}
    def from_path(ref, file_path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_path, [file_path] ++ List.wrap(args), opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate_input(ref, values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [values], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule FinalOutput do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "FinalOutput"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(output, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [output], opts)
    end
  end

  defmodule GEPA do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "GEPA"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(Dspy.Teleprompt.Gepa.Gepa.GEPAFeedbackMetric.t(), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric], opts)
    end

    @spec _build_seed_candidate(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, %{optional(String.t()) => String.t()}} | {:error, Snakepit.Error.t()}
    def _build_seed_candidate(ref, student, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_seed_candidate, [student], opts)
    end

    @spec auto_budget(SnakeBridge.Ref.t(), term(), term(), integer(), list(term()), keyword()) ::
            {:ok, integer()} | {:error, Snakepit.Error.t()}
    def auto_budget(ref, num_preds, num_candidates, valset_size, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :auto_budget,
        [num_preds, num_candidates, valset_size] ++ List.wrap(args),
        opts
      )
    end

    @spec compile(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule History do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "History"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Image do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Image"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec from_pil(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_pil(ref, pil_image, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "from_PIL", [pil_image], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec from_file(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_file(ref, file_path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_file, [file_path], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec from_url(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_url(ref, url, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :from_url, [url] ++ List.wrap(args), opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule InferRules do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "InferRules"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _bootstrap(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_bootstrap, [], opts)
    end

    @spec _bootstrap_one_example(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap_one_example(ref, example, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_bootstrap_one_example,
        [example] ++ List.wrap(args),
        opts
      )
    end

    @spec _prepare_predictor_mappings(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_predictor_mappings(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_prepare_predictor_mappings, [], opts)
    end

    @spec _prepare_student_and_teacher(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_student_and_teacher(ref, student, teacher, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_prepare_student_and_teacher,
        [student, teacher],
        opts
      )
    end

    @spec _train(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _train(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_train, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec evaluate_program(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def evaluate_program(ref, program, dataset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :evaluate_program, [program, dataset], opts)
    end

    @spec format_examples(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_examples(ref, demos, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_examples, [demos, signature], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end

    @spec get_predictor_demos(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_predictor_demos(ref, trainset, predictor, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_predictor_demos, [trainset, predictor], opts)
    end

    @spec induce_natural_language_rules(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def induce_natural_language_rules(ref, predictor, trainset, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :induce_natural_language_rules,
        [predictor, trainset],
        opts
      )
    end

    @spec update_program_instructions(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_program_instructions(ref, predictor, natural_language_rules, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update_program_instructions,
        [predictor, natural_language_rules],
        opts
      )
    end
  end

  defmodule JSONAdapter do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "JSONAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec _json_adapter_call_common(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _json_adapter_call_common(
          ref,
          lm,
          lm_kwargs,
          signature,
          demos,
          inputs,
          call_fn,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_json_adapter_call_common,
        [lm, lm_kwargs, signature, demos, inputs, call_fn],
        opts
      )
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            Dspy.Clients.LMClass.t(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_field_with_value(
            SnakeBridge.Ref.t(),
            %{optional(Dspy.Adapters.ChatAdapter.FieldInfoWithName.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_with_value(ref, fields_with_values, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_field_with_value,
        [fields_with_values] ++ List.wrap(args),
        opts
      )
    end

    @spec format_finetune_data(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, %{optional(String.t()) => list(term())}} | {:error, Snakepit.Error.t()}
    def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_finetune_data,
        [signature, demos, inputs, outputs],
        opts
      )
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end

    @spec user_message_output_requirements(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def user_message_output_requirements(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :user_message_output_requirements, [signature], opts)
    end
  end

  defmodule KNN do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "KNN"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            integer(),
            list(Dspy.Primitives.Example.t()),
            Dspy.Clients.Embedding.Embedder.t(),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(k, trainset, vectorizer, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [k, trainset, vectorizer], opts)
    end
  end

  defmodule KNNFewShot do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "KNNFewShot"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            integer(),
            list(Dspy.Primitives.Example.t()),
            Dspy.Clients.Embedding.Embedder.t(),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(k, trainset, vectorizer, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [k, trainset, vectorizer], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule LM do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "LM"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [model] ++ List.wrap(args), opts)
    end

    @spec _check_truncation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _check_truncation(ref, results, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_check_truncation, [results], opts)
    end

    @spec _extract_citations_from_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _extract_citations_from_response(ref, choice, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_extract_citations_from_response, [choice], opts)
    end

    @spec _get_cached_completion_fn(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_cached_completion_fn(ref, completion_fn, cache, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_get_cached_completion_fn,
        [completion_fn, cache],
        opts
      )
    end

    @spec _process_completion(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_completion(ref, response, merged_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_completion, [response, merged_kwargs], opts)
    end

    @spec _process_lm_response(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_lm_response(ref, response, prompt, messages, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_lm_response,
        [response, prompt, messages],
        opts
      )
    end

    @spec _process_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_response, [response], opts)
    end

    @spec _run_finetune_job(SnakeBridge.Ref.t(), Dspy.Clients.Provider.TrainingJob.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _run_finetune_job(ref, job, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_run_finetune_job, [job], opts)
    end

    @spec _warn_zero_temp_rollout(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _warn_zero_temp_rollout(ref, temperature, rollout_id, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_warn_zero_temp_rollout,
        [temperature, rollout_id],
        opts
      )
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, list(term())} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :aforward, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec finetune(
            SnakeBridge.Ref.t(),
            list(%{optional(String.t()) => term()}),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, Dspy.Clients.Provider.TrainingJob.t()} | {:error, Snakepit.Error.t()}
    def finetune(ref, train_data, train_data_format, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :finetune,
        [train_data, train_data_format] ++ List.wrap(args),
        opts
      )
    end

    @spec forward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [] ++ List.wrap(args), opts)
    end

    @spec infer_provider(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, Dspy.Clients.ProviderClass.t()} | {:error, Snakepit.Error.t()}
    def infer_provider(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :infer_provider, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec kill(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :kill, [] ++ List.wrap(args), opts)
    end

    @spec launch(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :launch, [] ++ List.wrap(args), opts)
    end

    @spec reinforce(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Clients.Provider.ReinforceJob.t()} | {:error, Snakepit.Error.t()}
    def reinforce(ref, train_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reinforce, [train_kwargs], opts)
    end

    @spec update_history(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_history(ref, entry, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_history, [entry], opts)
    end
  end

  defmodule LabeledFewShot do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "LabeledFewShot"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule MIPROv2 do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "MIPROv2"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec _bootstrap_fewshot_examples(
            SnakeBridge.Ref.t(),
            term(),
            list(term()),
            integer(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap_fewshot_examples(ref, program, trainset, seed, teacher, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)

      missing_kw =
        [
          "num_fewshot_candidates",
          "max_bootstrapped_demos",
          "max_labeled_demos",
          "max_errors",
          "metric_threshold"
        ]
        |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(
        ref,
        :_bootstrap_fewshot_examples,
        [program, trainset, seed, teacher],
        opts
      )
    end

    @spec _estimate_lm_calls(
            SnakeBridge.Ref.t(),
            term(),
            integer(),
            boolean(),
            integer(),
            integer(),
            list(term()),
            boolean(),
            integer(),
            keyword()
          ) :: {:ok, {String.t(), String.t()}} | {:error, Snakepit.Error.t()}
    def _estimate_lm_calls(
          ref,
          program,
          num_trials,
          minibatch,
          minibatch_size,
          minibatch_full_eval_steps,
          valset,
          program_aware_proposer,
          num_instruct_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_estimate_lm_calls,
        [
          program,
          num_trials,
          minibatch,
          minibatch_size,
          minibatch_full_eval_steps,
          valset,
          program_aware_proposer,
          num_instruct_candidates
        ],
        opts
      )
    end

    @spec _get_param_distributions(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_param_distributions(
          ref,
          program,
          instruction_candidates,
          demo_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_get_param_distributions,
        [program, instruction_candidates, demo_candidates],
        opts
      )
    end

    @spec _log_minibatch_eval(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _log_minibatch_eval(
          ref,
          score,
          best_score,
          batch_size,
          chosen_params,
          score_data,
          trial,
          adjusted_num_trials,
          trial_logs,
          trial_num,
          candidate_program,
          total_eval_calls,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_log_minibatch_eval,
        [
          score,
          best_score,
          batch_size,
          chosen_params,
          score_data,
          trial,
          adjusted_num_trials,
          trial_logs,
          trial_num,
          candidate_program,
          total_eval_calls
        ],
        opts
      )
    end

    @spec _log_normal_eval(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _log_normal_eval(
          ref,
          score,
          best_score,
          chosen_params,
          score_data,
          trial,
          num_trials,
          trial_logs,
          trial_num,
          valset,
          batch_size,
          candidate_program,
          total_eval_calls,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_log_normal_eval,
        [
          score,
          best_score,
          chosen_params,
          score_data,
          trial,
          num_trials,
          trial_logs,
          trial_num,
          valset,
          batch_size,
          candidate_program,
          total_eval_calls
        ],
        opts
      )
    end

    @spec _optimize_prompt_parameters(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(integer()) => list(String.t())},
            term(),
            Dspy.Evaluate.Evaluate.Evaluate.t(),
            list(term()),
            integer(),
            boolean(),
            integer(),
            integer(),
            integer(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _optimize_prompt_parameters(
          ref,
          program,
          instruction_candidates,
          demo_candidates,
          evaluate,
          valset,
          num_trials,
          minibatch,
          minibatch_size,
          minibatch_full_eval_steps,
          seed,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_optimize_prompt_parameters,
        [
          program,
          instruction_candidates,
          demo_candidates,
          evaluate,
          valset,
          num_trials,
          minibatch,
          minibatch_size,
          minibatch_full_eval_steps,
          seed
        ],
        opts
      )
    end

    @spec _perform_full_evaluation(
            SnakeBridge.Ref.t(),
            integer(),
            integer(),
            %{optional(term()) => term()},
            %{optional(term()) => term()},
            Dspy.Evaluate.Evaluate.Evaluate.t(),
            list(term()),
            %{optional(term()) => term()},
            integer(),
            term(),
            float(),
            term(),
            term(),
            list(term()),
            list(term()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _perform_full_evaluation(
          ref,
          trial_num,
          adjusted_num_trials,
          param_score_dict,
          fully_evaled_param_combos,
          evaluate,
          valset,
          trial_logs,
          total_eval_calls,
          score_data,
          best_score,
          best_program,
          study,
          instruction_candidates,
          demo_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_perform_full_evaluation,
        [
          trial_num,
          adjusted_num_trials,
          param_score_dict,
          fully_evaled_param_combos,
          evaluate,
          valset,
          trial_logs,
          total_eval_calls,
          score_data,
          best_score,
          best_program,
          study,
          instruction_candidates,
          demo_candidates
        ],
        opts
      )
    end

    @spec _print_auto_run_settings(
            SnakeBridge.Ref.t(),
            integer(),
            boolean(),
            list(term()),
            integer(),
            integer(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _print_auto_run_settings(
          ref,
          num_trials,
          minibatch,
          valset,
          num_fewshot_candidates,
          num_instruct_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_print_auto_run_settings,
        [num_trials, minibatch, valset, num_fewshot_candidates, num_instruct_candidates],
        opts
      )
    end

    @spec _propose_instructions(
            SnakeBridge.Ref.t(),
            term(),
            list(term()),
            term(),
            integer(),
            boolean(),
            boolean(),
            boolean(),
            boolean(),
            integer(),
            keyword()
          ) :: {:ok, %{optional(integer()) => list(String.t())}} | {:error, Snakepit.Error.t()}
    def _propose_instructions(
          ref,
          program,
          trainset,
          demo_candidates,
          view_data_batch_size,
          program_aware_proposer,
          data_aware_proposer,
          tip_aware_proposer,
          fewshot_aware_proposer,
          num_instruct_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_propose_instructions,
        [
          program,
          trainset,
          demo_candidates,
          view_data_batch_size,
          program_aware_proposer,
          data_aware_proposer,
          tip_aware_proposer,
          fewshot_aware_proposer,
          num_instruct_candidates
        ],
        opts
      )
    end

    @spec _select_and_insert_instructions_and_demos(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(integer()) => list(String.t())},
            term(),
            term(),
            %{optional(term()) => term()},
            integer(),
            keyword()
          ) :: {:ok, list(String.t())} | {:error, Snakepit.Error.t()}
    def _select_and_insert_instructions_and_demos(
          ref,
          candidate_program,
          instruction_candidates,
          demo_candidates,
          trial,
          trial_logs,
          trial_num,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_select_and_insert_instructions_and_demos,
        [
          candidate_program,
          instruction_candidates,
          demo_candidates,
          trial,
          trial_logs,
          trial_num
        ],
        opts
      )
    end

    @spec _set_and_validate_datasets(SnakeBridge.Ref.t(), list(term()), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_and_validate_datasets(ref, trainset, valset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_and_validate_datasets, [trainset, valset], opts)
    end

    @spec _set_hyperparams_from_run_mode(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            boolean(),
            boolean(),
            list(term()),
            term(),
            term(),
            keyword()
          ) ::
            {:ok, {integer(), list(term()), boolean(), integer(), integer()}}
            | {:error, Snakepit.Error.t()}
    def _set_hyperparams_from_run_mode(
          ref,
          program,
          num_trials,
          minibatch,
          zeroshot_opt,
          valset,
          num_instruct_candidates,
          num_fewshot_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_set_hyperparams_from_run_mode,
        [
          program,
          num_trials,
          minibatch,
          zeroshot_opt,
          valset,
          num_instruct_candidates,
          num_fewshot_candidates
        ],
        opts
      )
    end

    @spec _set_num_trials_from_num_candidates(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_num_trials_from_num_candidates(
          ref,
          program,
          zeroshot_opt,
          num_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_set_num_trials_from_num_candidates,
        [program, zeroshot_opt, num_candidates],
        opts
      )
    end

    @spec _set_random_seeds(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_random_seeds(ref, seed, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_random_seeds, [seed], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Module do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Module"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule MultiChainComparison do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "MultiChainComparison"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, completions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [completions], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule OldField do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "OldField"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["input"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finalize(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, key, inferred_prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [key, inferred_prefix], opts)
    end
  end

  defmodule OldInputField do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "OldInputField"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finalize(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, key, inferred_prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [key, inferred_prefix], opts)
    end
  end

  defmodule OldOutputField do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "OldOutputField"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finalize(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, key, inferred_prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [key, inferred_prefix], opts)
    end
  end

  defmodule Parallel do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Parallel"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec forward(
            SnakeBridge.Ref.t(),
            list({term(), Dspy.Primitives.Example.t()}),
            list(term()),
            keyword()
          ) :: {:ok, list(term())} | {:error, Snakepit.Error.t()}
    def forward(ref, exec_pairs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [exec_pairs] ++ List.wrap(args), opts)
    end
  end

  defmodule Predict.Avatar.Action do
    def __snakebridge_python_name__, do: "dspy.predict.avatar"
    def __snakebridge_python_class__, do: "Action"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Predict.Avatar.ActionOutput do
    def __snakebridge_python_name__, do: "dspy.predict.avatar"
    def __snakebridge_python_class__, do: "ActionOutput"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Predict.Avatar.Actor do
    def __snakebridge_python_name__, do: "dspy.predict.avatar"
    def __snakebridge_python_class__, do: "Actor"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Predict.Avatar.Avatar.Avatar do
    def __snakebridge_python_name__, do: "dspy.predict.avatar.avatar"
    def __snakebridge_python_class__, do: "Avatar"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, tools, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [signature, tools] ++ List.wrap(args),
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _call_tool(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _call_tool(ref, tool_name, tool_input_query, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_call_tool, [tool_name, tool_input_query], opts)
    end

    @spec _get_field(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_field(ref, field_info, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_field, [field_info], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec _update_signature(SnakeBridge.Ref.t(), integer(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _update_signature(ref, idx, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_update_signature, [idx] ++ List.wrap(args), opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Predict.Avatar.AvatarClass do
    def __snakebridge_python_name__, do: "dspy.predict.avatar"
    def __snakebridge_python_class__, do: "Avatar"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, tools, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [signature, tools] ++ List.wrap(args),
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _call_tool(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _call_tool(ref, tool_name, tool_input_query, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_call_tool, [tool_name, tool_input_query], opts)
    end

    @spec _get_field(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_field(ref, field_info, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_field, [field_info], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec _update_signature(SnakeBridge.Ref.t(), integer(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _update_signature(ref, idx, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_update_signature, [idx] ++ List.wrap(args), opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Predict.Avatar.Models.Action do
    def __snakebridge_python_name__, do: "dspy.predict.avatar.models"
    def __snakebridge_python_class__, do: "Action"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Predict.Avatar.Models.ActionOutput do
    def __snakebridge_python_name__, do: "dspy.predict.avatar.models"
    def __snakebridge_python_class__, do: "ActionOutput"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Predict.Avatar.Models.Tool do
    def __snakebridge_python_name__, do: "dspy.predict.avatar.models"
    def __snakebridge_python_class__, do: "Tool"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Predict.Avatar.Signatures.Actor do
    def __snakebridge_python_name__, do: "dspy.predict.avatar.signatures"
    def __snakebridge_python_class__, do: "Actor"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Predict.Avatar.Tool do
    def __snakebridge_python_name__, do: "dspy.predict.avatar"
    def __snakebridge_python_class__, do: "Tool"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Predict.BestOfN do
    def __snakebridge_python_name__, do: "dspy.predict.best_of_n"
    def __snakebridge_python_class__, do: "BestOfN"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            Dspy.Primitives.Module.Module.t(),
            integer(),
            term(),
            float(),
            list(term()),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(module, n, reward_fn, threshold, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [module, n, reward_fn, threshold] ++ List.wrap(args),
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Predict.BestOfNClass do
    def __snakebridge_python_name__, do: "dspy.predict"
    def __snakebridge_python_class__, do: "BestOfN"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            Dspy.Primitives.Module.Module.t(),
            integer(),
            term(),
            float(),
            list(term()),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(module, n, reward_fn, threshold, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [module, n, reward_fn, threshold] ++ List.wrap(args),
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Predict.ChainOfThought do
    def __snakebridge_python_name__, do: "dspy.predict.chain_of_thought"
    def __snakebridge_python_class__, do: "ChainOfThought"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Predict.ChainOfThoughtClass do
    def __snakebridge_python_name__, do: "dspy.predict"
    def __snakebridge_python_class__, do: "ChainOfThought"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Predict.CodeAct do
    def __snakebridge_python_name__, do: "dspy.predict"
    def __snakebridge_python_class__, do: "CodeAct"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, tools, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [signature, tools] ++ List.wrap(args),
        opts
      )
    end

    @spec _async_call_with_potential_trajectory_truncation(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _async_call_with_potential_trajectory_truncation(ref, module, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_async_call_with_potential_trajectory_truncation,
        [module, trajectory],
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _build_instructions(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _build_instructions(ref, signature, tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_instructions, [signature, tools], opts)
    end

    @spec _call_with_potential_trajectory_truncation(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_with_potential_trajectory_truncation(ref, module, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_with_potential_trajectory_truncation,
        [module, trajectory],
        opts
      )
    end

    @spec _execute_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _execute_code(ref, code, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_execute_code, [code], opts)
    end

    @spec _format_trajectory(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _format_trajectory(ref, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_trajectory, [trajectory], opts)
    end

    @spec _generate_instruction(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _generate_instruction(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_generate_instruction, [mode], opts)
    end

    @spec _generate_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _generate_signature(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_generate_signature, [mode], opts)
    end

    @spec _parse_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_code(ref, code_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_parse_code, [code_data], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec truncate_trajectory(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def truncate_trajectory(ref, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :truncate_trajectory, [trajectory], opts)
    end
  end

  defmodule Predict.CodeActClass do
    def __snakebridge_python_name__, do: "dspy.predict.code_act"
    def __snakebridge_python_class__, do: "CodeAct"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, tools, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [signature, tools] ++ List.wrap(args),
        opts
      )
    end

    @spec _async_call_with_potential_trajectory_truncation(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _async_call_with_potential_trajectory_truncation(ref, module, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_async_call_with_potential_trajectory_truncation,
        [module, trajectory],
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _build_instructions(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _build_instructions(ref, signature, tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_instructions, [signature, tools], opts)
    end

    @spec _call_with_potential_trajectory_truncation(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_with_potential_trajectory_truncation(ref, module, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_with_potential_trajectory_truncation,
        [module, trajectory],
        opts
      )
    end

    @spec _execute_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _execute_code(ref, code, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_execute_code, [code], opts)
    end

    @spec _format_trajectory(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _format_trajectory(ref, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_trajectory, [trajectory], opts)
    end

    @spec _generate_instruction(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _generate_instruction(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_generate_instruction, [mode], opts)
    end

    @spec _generate_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _generate_signature(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_generate_signature, [mode], opts)
    end

    @spec _parse_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_code(ref, code_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_parse_code, [code_data], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec truncate_trajectory(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def truncate_trajectory(ref, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :truncate_trajectory, [trajectory], opts)
    end
  end

  defmodule Predict.KNN do
    def __snakebridge_python_name__, do: "dspy.predict"
    def __snakebridge_python_class__, do: "KNN"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            integer(),
            list(Dspy.Primitives.Example.t()),
            Dspy.Clients.Embedding.Embedder.t(),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(k, trainset, vectorizer, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [k, trainset, vectorizer], opts)
    end
  end

  defmodule Predict.KNNClass do
    def __snakebridge_python_name__, do: "dspy.predict.knn"
    def __snakebridge_python_class__, do: "KNN"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            integer(),
            list(Dspy.Primitives.Example.t()),
            Dspy.Clients.Embedding.Embedder.t(),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(k, trainset, vectorizer, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [k, trainset, vectorizer], opts)
    end
  end

  defmodule Predict.MultiChainComparison do
    def __snakebridge_python_name__, do: "dspy.predict"
    def __snakebridge_python_class__, do: "MultiChainComparison"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, completions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [completions], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Predict.MultiChainComparisonClass do
    def __snakebridge_python_name__, do: "dspy.predict.multi_chain_comparison"
    def __snakebridge_python_class__, do: "MultiChainComparison"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, completions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [completions], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Predict.Parallel do
    def __snakebridge_python_name__, do: "dspy.predict.parallel"
    def __snakebridge_python_class__, do: "Parallel"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec forward(
            SnakeBridge.Ref.t(),
            list({term(), Dspy.Primitives.Example.t()}),
            list(term()),
            keyword()
          ) :: {:ok, list(term())} | {:error, Snakepit.Error.t()}
    def forward(ref, exec_pairs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [exec_pairs] ++ List.wrap(args), opts)
    end
  end

  defmodule Predict.ParallelClass do
    def __snakebridge_python_name__, do: "dspy.predict"
    def __snakebridge_python_class__, do: "Parallel"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec forward(
            SnakeBridge.Ref.t(),
            list({term(), Dspy.Primitives.Example.t()}),
            list(term()),
            keyword()
          ) :: {:ok, list(term())} | {:error, Snakepit.Error.t()}
    def forward(ref, exec_pairs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [exec_pairs] ++ List.wrap(args), opts)
    end
  end

  defmodule Predict.Parameter do
    def __snakebridge_python_name__, do: "dspy.predict.parameter"
    def __snakebridge_python_class__, do: "Parameter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end
  end

  defmodule Predict.Predict.Predict do
    def __snakebridge_python_name__, do: "dspy.predict.predict"
    def __snakebridge_python_class__, do: "Predict"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _forward_postprocess(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _forward_postprocess(ref, completions, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_forward_postprocess, [completions, signature], opts)
    end

    @spec _forward_preprocess(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _forward_preprocess(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_forward_preprocess, [], opts)
    end

    @spec _get_positional_args_error_message(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_positional_args_error_message(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_positional_args_error_message, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec _should_stream(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _should_stream(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_should_stream, [], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_config(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_config(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_config, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), %{optional(term()) => term()}, keyword()) ::
            {:ok, Dspy.Predict.Predict.Predict.t()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec update_config(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_config(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_config, [], opts)
    end
  end

  defmodule Predict.PredictClass3 do
    def __snakebridge_python_name__, do: "dspy.predict"
    def __snakebridge_python_class__, do: "Predict"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _forward_postprocess(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _forward_postprocess(ref, completions, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_forward_postprocess, [completions, signature], opts)
    end

    @spec _forward_preprocess(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _forward_preprocess(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_forward_preprocess, [], opts)
    end

    @spec _get_positional_args_error_message(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_positional_args_error_message(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_positional_args_error_message, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec _should_stream(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _should_stream(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_should_stream, [], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_config(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_config(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_config, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), %{optional(term()) => term()}, keyword()) ::
            {:ok, Dspy.Predict.Predict.Predict.t()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec update_config(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_config(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_config, [], opts)
    end
  end

  defmodule Predict.ProgramOfThought do
    def __snakebridge_python_name__, do: "dspy.predict.program_of_thought"
    def __snakebridge_python_class__, do: "ProgramOfThought"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _execute_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _execute_code(ref, code, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_execute_code, [code], opts)
    end

    @spec _generate_instruction(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _generate_instruction(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_generate_instruction, [mode], opts)
    end

    @spec _generate_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _generate_signature(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_generate_signature, [mode], opts)
    end

    @spec _parse_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_code(ref, code_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_parse_code, [code_data], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Predict.ProgramOfThoughtClass do
    def __snakebridge_python_name__, do: "dspy.predict"
    def __snakebridge_python_class__, do: "ProgramOfThought"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _execute_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _execute_code(ref, code, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_execute_code, [code], opts)
    end

    @spec _generate_instruction(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _generate_instruction(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_generate_instruction, [mode], opts)
    end

    @spec _generate_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _generate_signature(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_generate_signature, [mode], opts)
    end

    @spec _parse_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_code(ref, code_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_parse_code, [code_data], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Predict.RLM do
    def __snakebridge_python_name__, do: "dspy.predict.rlm"
    def __snakebridge_python_class__, do: "RLM"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), term(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(
          signature,
          max_iterations,
          max_llm_calls,
          max_output_chars,
          verbose,
          tools,
          sub_lm,
          interpreter,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [
          signature,
          max_iterations,
          max_llm_calls,
          max_output_chars,
          verbose,
          tools,
          sub_lm,
          interpreter
        ],
        opts
      )
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec _build_variables(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(Dspy.Primitives.ReplTypes.REPLVariable.t())} | {:error, Snakepit.Error.t()}
    def _build_variables(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_variables, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec _get_output_fields_info(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(term()) => term()})} | {:error, Snakepit.Error.t()}
    def _get_output_fields_info(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_output_fields_info, [], opts)
    end

    @spec _validate_tools(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _validate_tools(ref, tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_tools, [tools], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec _process_execution_result(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            list(String.t()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_execution_result(ref, pred, result, history, output_field_names, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_execution_result,
        [pred, result, history, output_field_names],
        opts
      )
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec _prepare_execution_tools(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def _prepare_execution_tools(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_prepare_execution_tools, [], opts)
    end

    @spec _format_tool_docs(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _format_tool_docs(ref, tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_tool_docs, [tools], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec _validate_inputs(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _validate_inputs(ref, input_args, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_inputs, [input_args], opts)
    end

    @spec _aexecute_iteration(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.CodeInterpreter.t(),
            list(Dspy.Primitives.ReplTypes.REPLVariable.t()),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            integer(),
            %{optional(String.t()) => term()},
            list(String.t()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _aexecute_iteration(
          ref,
          repl,
          variables,
          history,
          iteration,
          input_args,
          output_field_names,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_aexecute_iteration,
        [repl, variables, history, iteration, input_args, output_field_names],
        opts
      )
    end

    @spec _inject_execution_context(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.CodeInterpreter.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def _inject_execution_context(ref, interpreter, execution_tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_inject_execution_context,
        [interpreter, execution_tools],
        opts
      )
    end

    @spec _make_llm_tools(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def _make_llm_tools(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_make_llm_tools, [] ++ List.wrap(args), opts)
    end

    @spec _interpreter_context(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _interpreter_context(ref, execution_tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_interpreter_context, [execution_tools], opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec _format_output(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _format_output(ref, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_output, [output], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec _extract_fallback(
            SnakeBridge.Ref.t(),
            list(Dspy.Primitives.ReplTypes.REPLVariable.t()),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            list(String.t()),
            keyword()
          ) :: {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def _extract_fallback(ref, variables, history, output_field_names, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_extract_fallback,
        [variables, history, output_field_names],
        opts
      )
    end

    @spec _build_signatures(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _build_signatures(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_signatures, [], opts)
    end

    @spec _execute_iteration(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.CodeInterpreter.t(),
            list(Dspy.Primitives.ReplTypes.REPLVariable.t()),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            integer(),
            %{optional(String.t()) => term()},
            list(String.t()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _execute_iteration(
          ref,
          repl,
          variables,
          history,
          iteration,
          input_args,
          output_field_names,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_execute_iteration,
        [repl, variables, history, iteration, input_args, output_field_names],
        opts
      )
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec _aextract_fallback(
            SnakeBridge.Ref.t(),
            list(Dspy.Primitives.ReplTypes.REPLVariable.t()),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            list(String.t()),
            keyword()
          ) :: {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def _aextract_fallback(ref, variables, history, output_field_names, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_aextract_fallback,
        [variables, history, output_field_names],
        opts
      )
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec _process_final_output(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.CodeInterpreter.FinalOutput.t(),
            list(String.t()),
            keyword()
          ) :: {:ok, {term(), term()}} | {:error, Snakepit.Error.t()}
    def _process_final_output(ref, result, output_field_names, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_final_output,
        [result, output_field_names],
        opts
      )
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec _reserved_tool_names(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _reserved_tool_names(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_RESERVED_TOOL_NAMES)
    end

    @spec tools(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def tools(ref) do
      SnakeBridge.Runtime.get_attr(ref, :tools)
    end
  end

  defmodule Predict.RLMClass do
    def __snakebridge_python_name__, do: "dspy.predict"
    def __snakebridge_python_class__, do: "RLM"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), term(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(
          signature,
          max_iterations,
          max_llm_calls,
          max_output_chars,
          verbose,
          tools,
          sub_lm,
          interpreter,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [
          signature,
          max_iterations,
          max_llm_calls,
          max_output_chars,
          verbose,
          tools,
          sub_lm,
          interpreter
        ],
        opts
      )
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec _build_variables(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(Dspy.Primitives.ReplTypes.REPLVariable.t())} | {:error, Snakepit.Error.t()}
    def _build_variables(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_variables, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec _get_output_fields_info(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(term()) => term()})} | {:error, Snakepit.Error.t()}
    def _get_output_fields_info(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_output_fields_info, [], opts)
    end

    @spec _validate_tools(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _validate_tools(ref, tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_tools, [tools], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec _process_execution_result(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            list(String.t()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_execution_result(ref, pred, result, history, output_field_names, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_execution_result,
        [pred, result, history, output_field_names],
        opts
      )
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec _prepare_execution_tools(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def _prepare_execution_tools(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_prepare_execution_tools, [], opts)
    end

    @spec _format_tool_docs(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _format_tool_docs(ref, tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_tool_docs, [tools], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec _validate_inputs(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _validate_inputs(ref, input_args, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_inputs, [input_args], opts)
    end

    @spec _aexecute_iteration(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.CodeInterpreter.t(),
            list(Dspy.Primitives.ReplTypes.REPLVariable.t()),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            integer(),
            %{optional(String.t()) => term()},
            list(String.t()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _aexecute_iteration(
          ref,
          repl,
          variables,
          history,
          iteration,
          input_args,
          output_field_names,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_aexecute_iteration,
        [repl, variables, history, iteration, input_args, output_field_names],
        opts
      )
    end

    @spec _inject_execution_context(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.CodeInterpreter.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def _inject_execution_context(ref, interpreter, execution_tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_inject_execution_context,
        [interpreter, execution_tools],
        opts
      )
    end

    @spec _make_llm_tools(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def _make_llm_tools(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_make_llm_tools, [] ++ List.wrap(args), opts)
    end

    @spec _interpreter_context(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _interpreter_context(ref, execution_tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_interpreter_context, [execution_tools], opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec _format_output(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _format_output(ref, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_output, [output], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec _extract_fallback(
            SnakeBridge.Ref.t(),
            list(Dspy.Primitives.ReplTypes.REPLVariable.t()),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            list(String.t()),
            keyword()
          ) :: {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def _extract_fallback(ref, variables, history, output_field_names, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_extract_fallback,
        [variables, history, output_field_names],
        opts
      )
    end

    @spec _build_signatures(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _build_signatures(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_signatures, [], opts)
    end

    @spec _execute_iteration(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.CodeInterpreter.t(),
            list(Dspy.Primitives.ReplTypes.REPLVariable.t()),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            integer(),
            %{optional(String.t()) => term()},
            list(String.t()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _execute_iteration(
          ref,
          repl,
          variables,
          history,
          iteration,
          input_args,
          output_field_names,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_execute_iteration,
        [repl, variables, history, iteration, input_args, output_field_names],
        opts
      )
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec _aextract_fallback(
            SnakeBridge.Ref.t(),
            list(Dspy.Primitives.ReplTypes.REPLVariable.t()),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            list(String.t()),
            keyword()
          ) :: {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def _aextract_fallback(ref, variables, history, output_field_names, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_aextract_fallback,
        [variables, history, output_field_names],
        opts
      )
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec _process_final_output(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.CodeInterpreter.FinalOutput.t(),
            list(String.t()),
            keyword()
          ) :: {:ok, {term(), term()}} | {:error, Snakepit.Error.t()}
    def _process_final_output(ref, result, output_field_names, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_final_output,
        [result, output_field_names],
        opts
      )
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec _reserved_tool_names(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _reserved_tool_names(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_RESERVED_TOOL_NAMES)
    end

    @spec tools(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def tools(ref) do
      SnakeBridge.Runtime.get_attr(ref, :tools)
    end
  end

  defmodule Predict.ReAct do
    def __snakebridge_python_name__, do: "dspy.predict"
    def __snakebridge_python_class__, do: "ReAct"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, tools, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [signature, tools] ++ List.wrap(args),
        opts
      )
    end

    @spec _async_call_with_potential_trajectory_truncation(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _async_call_with_potential_trajectory_truncation(ref, module, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_async_call_with_potential_trajectory_truncation,
        [module, trajectory],
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _call_with_potential_trajectory_truncation(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_with_potential_trajectory_truncation(ref, module, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_with_potential_trajectory_truncation,
        [module, trajectory],
        opts
      )
    end

    @spec _format_trajectory(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _format_trajectory(ref, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_trajectory, [trajectory], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec truncate_trajectory(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def truncate_trajectory(ref, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :truncate_trajectory, [trajectory], opts)
    end
  end

  defmodule Predict.React.ReAct do
    def __snakebridge_python_name__, do: "dspy.predict.react"
    def __snakebridge_python_class__, do: "ReAct"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, tools, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [signature, tools] ++ List.wrap(args),
        opts
      )
    end

    @spec _async_call_with_potential_trajectory_truncation(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _async_call_with_potential_trajectory_truncation(ref, module, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_async_call_with_potential_trajectory_truncation,
        [module, trajectory],
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _call_with_potential_trajectory_truncation(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_with_potential_trajectory_truncation(ref, module, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_with_potential_trajectory_truncation,
        [module, trajectory],
        opts
      )
    end

    @spec _format_trajectory(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _format_trajectory(ref, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_trajectory, [trajectory], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec truncate_trajectory(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def truncate_trajectory(ref, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :truncate_trajectory, [trajectory], opts)
    end
  end

  defmodule Predict.Refine.OfferFeedback do
    def __snakebridge_python_name__, do: "dspy.predict.refine"
    def __snakebridge_python_class__, do: "OfferFeedback"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Predict.Refine.Refine do
    def __snakebridge_python_name__, do: "dspy.predict.refine"
    def __snakebridge_python_class__, do: "Refine"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            Dspy.Primitives.Module.Module.t(),
            integer(),
            term(),
            float(),
            list(term()),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(module, n, reward_fn, threshold, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [module, n, reward_fn, threshold] ++ List.wrap(args),
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Predict.RefineClass do
    def __snakebridge_python_name__, do: "dspy.predict"
    def __snakebridge_python_class__, do: "Refine"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            Dspy.Primitives.Module.Module.t(),
            integer(),
            term(),
            float(),
            list(term()),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(module, n, reward_fn, threshold, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [module, n, reward_fn, threshold] ++ List.wrap(args),
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Predict.Tool do
    def __snakebridge_python_name__, do: "dspy.predict"
    def __snakebridge_python_class__, do: "Tool"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(func, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [func] ++ List.wrap(args), opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec _run_async_in_sync(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _run_async_in_sync(ref, coroutine, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_run_async_in_sync, [coroutine], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec from_langchain(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_langchain(ref, tool, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_langchain, [tool], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec format_as_litellm_function_call(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_as_litellm_function_call(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_as_litellm_function_call, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _validate_and_parse_args(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _validate_and_parse_args(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_and_parse_args, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec from_mcp_tool(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_mcp_tool(ref, session, tool, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_mcp_tool, [session, tool], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec _parse_function(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_function(ref, func, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_parse_function, [func] ++ List.wrap(args), opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec acall(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def acall(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :acall, [], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule PredictClass do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Predict"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _forward_postprocess(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _forward_postprocess(ref, completions, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_forward_postprocess, [completions, signature], opts)
    end

    @spec _forward_preprocess(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _forward_preprocess(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_forward_preprocess, [], opts)
    end

    @spec _get_positional_args_error_message(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_positional_args_error_message(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_positional_args_error_message, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec _should_stream(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _should_stream(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_should_stream, [], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_config(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_config(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_config, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), %{optional(term()) => term()}, keyword()) ::
            {:ok, Dspy.Predict.Predict.Predict.t()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec update_config(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_config(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_config, [], opts)
    end
  end

  defmodule Prediction do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Prediction"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec from_completions(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_completions(ref, list_or_dict, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :from_completions,
        [list_or_dict] ++ List.wrap(args),
        opts
      )
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec get_lm_usage(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm_usage(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm_usage, [], opts)
    end

    @spec inputs(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inputs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :inputs, [], opts)
    end

    @spec items(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :items, [] ++ List.wrap(args), opts)
    end

    @spec keys(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :keys, [] ++ List.wrap(args), opts)
    end

    @spec labels(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def labels(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :labels, [], opts)
    end

    @spec set_lm_usage(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm_usage(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm_usage, [value], opts)
    end

    @spec to_dict(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "toDict", [], opts)
    end

    @spec values(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :values, [] ++ List.wrap(args), opts)
    end

    @spec with_inputs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_inputs(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_inputs, [] ++ List.wrap(args), opts)
    end

    @spec without(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def without(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :without, [] ++ List.wrap(args), opts)
    end

    @spec completions(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def completions(ref) do
      SnakeBridge.Runtime.get_attr(ref, :completions)
    end
  end

  defmodule Primitives.BaseModule do
    def __snakebridge_python_name__, do: "dspy.primitives.base_module"
    def __snakebridge_python_class__, do: "BaseModule"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end
  end

  defmodule Primitives.BaseModuleClass do
    def __snakebridge_python_name__, do: "dspy.primitives"
    def __snakebridge_python_class__, do: "BaseModule"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end
  end

  defmodule Primitives.CodeInterpreter do
    def __snakebridge_python_name__, do: "dspy.primitives.code_interpreter"
    def __snakebridge_python_class__, do: "CodeInterpreter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec execute(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def execute(ref, code, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :execute, [code] ++ List.wrap(args), opts)
    end

    @spec shutdown(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def shutdown(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :shutdown, [], opts)
    end

    @spec start(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def start(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :start, [], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec _is_protocol(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_protocol)
    end

    @spec _is_runtime_protocol(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_runtime_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_runtime_protocol)
    end

    @spec tools(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def tools(ref) do
      SnakeBridge.Runtime.get_attr(ref, :tools)
    end
  end

  defmodule Primitives.CodeInterpreter.CodeInterpreterError do
    def __snakebridge_python_name__, do: "dspy.primitives.code_interpreter"
    def __snakebridge_python_class__, do: "CodeInterpreterError"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec add_note(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def add_note(ref) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [], [])
    end

    def add_note(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [], opts)
    end

    def add_note(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], [])
    end

    def add_note(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], opts)
    end

    def add_note(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], [])
    end

    def add_note(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], opts)
    end

    def add_note(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], [])
    end

    def add_note(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec with_traceback(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_traceback(ref) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [], [])
    end

    def with_traceback(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [], opts)
    end

    def with_traceback(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], [])
    end

    def with_traceback(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], opts)
    end

    def with_traceback(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], [])
    end

    def with_traceback(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        opts
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec args(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def args(ref) do
      SnakeBridge.Runtime.get_attr(ref, :args)
    end
  end

  defmodule Primitives.CodeInterpreter.FinalOutput do
    def __snakebridge_python_name__, do: "dspy.primitives.code_interpreter"
    def __snakebridge_python_class__, do: "FinalOutput"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(output, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [output], opts)
    end
  end

  defmodule Primitives.CodeInterpreterClass do
    def __snakebridge_python_name__, do: "dspy.primitives"
    def __snakebridge_python_class__, do: "CodeInterpreter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec execute(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def execute(ref, code, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :execute, [code] ++ List.wrap(args), opts)
    end

    @spec shutdown(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def shutdown(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :shutdown, [], opts)
    end

    @spec start(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def start(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :start, [], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec _is_protocol(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_protocol)
    end

    @spec _is_runtime_protocol(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_runtime_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_runtime_protocol)
    end

    @spec tools(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def tools(ref) do
      SnakeBridge.Runtime.get_attr(ref, :tools)
    end
  end

  defmodule Primitives.CodeInterpreterError do
    def __snakebridge_python_name__, do: "dspy.primitives"
    def __snakebridge_python_class__, do: "CodeInterpreterError"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec add_note(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def add_note(ref) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [], [])
    end

    def add_note(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [], opts)
    end

    def add_note(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], [])
    end

    def add_note(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], opts)
    end

    def add_note(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], [])
    end

    def add_note(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], opts)
    end

    def add_note(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], [])
    end

    def add_note(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec with_traceback(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_traceback(ref) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [], [])
    end

    def with_traceback(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [], opts)
    end

    def with_traceback(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], [])
    end

    def with_traceback(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], opts)
    end

    def with_traceback(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], [])
    end

    def with_traceback(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        opts
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec args(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def args(ref) do
      SnakeBridge.Runtime.get_attr(ref, :args)
    end
  end

  defmodule Primitives.Completions do
    def __snakebridge_python_name__, do: "dspy.primitives"
    def __snakebridge_python_class__, do: "Completions"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(list_or_dict, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [list_or_dict] ++ List.wrap(args),
        opts
      )
    end

    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end
  end

  defmodule Primitives.Example do
    def __snakebridge_python_name__, do: "dspy.primitives.example"
    def __snakebridge_python_class__, do: "Example"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec inputs(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inputs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :inputs, [], opts)
    end

    @spec items(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :items, [] ++ List.wrap(args), opts)
    end

    @spec keys(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :keys, [] ++ List.wrap(args), opts)
    end

    @spec labels(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def labels(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :labels, [], opts)
    end

    @spec to_dict(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "toDict", [], opts)
    end

    @spec values(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :values, [] ++ List.wrap(args), opts)
    end

    @spec with_inputs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_inputs(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_inputs, [] ++ List.wrap(args), opts)
    end

    @spec without(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def without(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :without, [] ++ List.wrap(args), opts)
    end
  end

  defmodule Primitives.ExampleClass do
    def __snakebridge_python_name__, do: "dspy.primitives"
    def __snakebridge_python_class__, do: "Example"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec inputs(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inputs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :inputs, [], opts)
    end

    @spec items(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :items, [] ++ List.wrap(args), opts)
    end

    @spec keys(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :keys, [] ++ List.wrap(args), opts)
    end

    @spec labels(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def labels(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :labels, [], opts)
    end

    @spec to_dict(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "toDict", [], opts)
    end

    @spec values(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :values, [] ++ List.wrap(args), opts)
    end

    @spec with_inputs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_inputs(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_inputs, [] ++ List.wrap(args), opts)
    end

    @spec without(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def without(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :without, [] ++ List.wrap(args), opts)
    end
  end

  defmodule Primitives.FinalOutput do
    def __snakebridge_python_name__, do: "dspy.primitives"
    def __snakebridge_python_class__, do: "FinalOutput"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(output, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [output], opts)
    end
  end

  defmodule Primitives.Module.Module do
    def __snakebridge_python_name__, do: "dspy.primitives.module"
    def __snakebridge_python_class__, do: "Module"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Primitives.Module.ProgramMeta do
    def __snakebridge_python_name__, do: "dspy.primitives.module"
    def __snakebridge_python_class__, do: "ProgramMeta"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec mro(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def mro(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :mro, [], opts)
    end
  end

  defmodule Primitives.ModuleClass do
    def __snakebridge_python_name__, do: "dspy.primitives"
    def __snakebridge_python_class__, do: "Module"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Primitives.Prediction do
    def __snakebridge_python_name__, do: "dspy.primitives.prediction"
    def __snakebridge_python_class__, do: "Prediction"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec from_completions(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_completions(ref, list_or_dict, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :from_completions,
        [list_or_dict] ++ List.wrap(args),
        opts
      )
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec get_lm_usage(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm_usage(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm_usage, [], opts)
    end

    @spec inputs(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inputs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :inputs, [], opts)
    end

    @spec items(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :items, [] ++ List.wrap(args), opts)
    end

    @spec keys(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :keys, [] ++ List.wrap(args), opts)
    end

    @spec labels(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def labels(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :labels, [], opts)
    end

    @spec set_lm_usage(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm_usage(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm_usage, [value], opts)
    end

    @spec to_dict(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "toDict", [], opts)
    end

    @spec values(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :values, [] ++ List.wrap(args), opts)
    end

    @spec with_inputs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_inputs(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_inputs, [] ++ List.wrap(args), opts)
    end

    @spec without(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def without(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :without, [] ++ List.wrap(args), opts)
    end

    @spec completions(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def completions(ref) do
      SnakeBridge.Runtime.get_attr(ref, :completions)
    end
  end

  defmodule Primitives.Prediction.Completions do
    def __snakebridge_python_name__, do: "dspy.primitives.prediction"
    def __snakebridge_python_class__, do: "Completions"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(list_or_dict, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [list_or_dict] ++ List.wrap(args),
        opts
      )
    end

    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end
  end

  defmodule Primitives.PredictionClass do
    def __snakebridge_python_name__, do: "dspy.primitives"
    def __snakebridge_python_class__, do: "Prediction"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec from_completions(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_completions(ref, list_or_dict, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :from_completions,
        [list_or_dict] ++ List.wrap(args),
        opts
      )
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec get_lm_usage(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm_usage(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm_usage, [], opts)
    end

    @spec inputs(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inputs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :inputs, [], opts)
    end

    @spec items(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :items, [] ++ List.wrap(args), opts)
    end

    @spec keys(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :keys, [] ++ List.wrap(args), opts)
    end

    @spec labels(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def labels(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :labels, [], opts)
    end

    @spec set_lm_usage(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm_usage(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm_usage, [value], opts)
    end

    @spec to_dict(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "toDict", [], opts)
    end

    @spec values(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :values, [] ++ List.wrap(args), opts)
    end

    @spec with_inputs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_inputs(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_inputs, [] ++ List.wrap(args), opts)
    end

    @spec without(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def without(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :without, [] ++ List.wrap(args), opts)
    end

    @spec completions(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def completions(ref) do
      SnakeBridge.Runtime.get_attr(ref, :completions)
    end
  end

  defmodule Primitives.PythonInterpreter do
    def __snakebridge_python_name__, do: "dspy.primitives.python_interpreter"
    def __snakebridge_python_class__, do: "PythonInterpreter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _ensure_deno_process(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _ensure_deno_process(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_ensure_deno_process, [], opts)
    end

    @spec _extract_parameters(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, list(%{optional(term()) => term()})} | {:error, Snakepit.Error.t()}
    def _extract_parameters(ref, py_fn, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_extract_parameters, [py_fn], opts)
    end

    @spec _get_deno_dir(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_deno_dir(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_deno_dir, [], opts)
    end

    @spec _get_runner_path(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _get_runner_path(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_runner_path, [], opts)
    end

    @spec _handle_tool_call(SnakeBridge.Ref.t(), %{optional(term()) => term()}, keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _handle_tool_call(ref, request, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_handle_tool_call, [request], opts)
    end

    @spec _inject_variables(
            SnakeBridge.Ref.t(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _inject_variables(ref, code, variables, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_inject_variables, [code, variables], opts)
    end

    @spec _mount_files(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _mount_files(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_mount_files, [], opts)
    end

    @spec _register_tools(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _register_tools(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_register_tools, [], opts)
    end

    @spec _serialize_value(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _serialize_value(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_serialize_value, [value], opts)
    end

    @spec _sync_files(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _sync_files(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_sync_files, [], opts)
    end

    @spec execute(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def execute(ref, code, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :execute, [code] ++ List.wrap(args), opts)
    end

    @spec shutdown(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def shutdown(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :shutdown, [], opts)
    end

    @spec start(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def start(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :start, [], opts)
    end
  end

  defmodule Primitives.PythonInterpreter.CodeInterpreterError do
    def __snakebridge_python_name__, do: "dspy.primitives.python_interpreter"
    def __snakebridge_python_class__, do: "CodeInterpreterError"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec add_note(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def add_note(ref) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [], [])
    end

    def add_note(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [], opts)
    end

    def add_note(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], [])
    end

    def add_note(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], opts)
    end

    def add_note(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], [])
    end

    def add_note(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], opts)
    end

    def add_note(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], [])
    end

    def add_note(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec with_traceback(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_traceback(ref) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [], [])
    end

    def with_traceback(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [], opts)
    end

    def with_traceback(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], [])
    end

    def with_traceback(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], opts)
    end

    def with_traceback(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], [])
    end

    def with_traceback(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        opts
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec args(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def args(ref) do
      SnakeBridge.Runtime.get_attr(ref, :args)
    end
  end

  defmodule Primitives.PythonInterpreter.FinalOutput do
    def __snakebridge_python_name__, do: "dspy.primitives.python_interpreter"
    def __snakebridge_python_class__, do: "FinalOutput"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(output, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [output], opts)
    end
  end

  defmodule Primitives.PythonInterpreterClass do
    def __snakebridge_python_name__, do: "dspy.primitives"
    def __snakebridge_python_class__, do: "PythonInterpreter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _ensure_deno_process(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _ensure_deno_process(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_ensure_deno_process, [], opts)
    end

    @spec _extract_parameters(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, list(%{optional(term()) => term()})} | {:error, Snakepit.Error.t()}
    def _extract_parameters(ref, py_fn, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_extract_parameters, [py_fn], opts)
    end

    @spec _get_deno_dir(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_deno_dir(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_deno_dir, [], opts)
    end

    @spec _get_runner_path(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _get_runner_path(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_runner_path, [], opts)
    end

    @spec _handle_tool_call(SnakeBridge.Ref.t(), %{optional(term()) => term()}, keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _handle_tool_call(ref, request, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_handle_tool_call, [request], opts)
    end

    @spec _inject_variables(
            SnakeBridge.Ref.t(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _inject_variables(ref, code, variables, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_inject_variables, [code, variables], opts)
    end

    @spec _mount_files(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _mount_files(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_mount_files, [], opts)
    end

    @spec _register_tools(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _register_tools(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_register_tools, [], opts)
    end

    @spec _serialize_value(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _serialize_value(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_serialize_value, [value], opts)
    end

    @spec _sync_files(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _sync_files(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_sync_files, [], opts)
    end

    @spec execute(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def execute(ref, code, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :execute, [code] ++ List.wrap(args), opts)
    end

    @spec shutdown(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def shutdown(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :shutdown, [], opts)
    end

    @spec start(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def start(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :start, [], opts)
    end
  end

  defmodule Primitives.ReplTypes.REPLEntry do
    def __snakebridge_python_name__, do: "dspy.primitives.repl_types"
    def __snakebridge_python_class__, do: "REPLEntry"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), integer(), list(term()), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format(ref, index, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :format, [index] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Primitives.ReplTypes.REPLHistory do
    def __snakebridge_python_name__, do: "dspy.primitives.repl_types"
    def __snakebridge_python_class__, do: "REPLHistory"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec append(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, Dspy.Primitives.ReplTypes.REPLHistory.t()} | {:error, Snakepit.Error.t()}
    def append(ref, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["code", "output"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :append, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :format, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Primitives.ReplTypes.REPLVariable do
    def __snakebridge_python_name__, do: "dspy.primitives.repl_types"
    def __snakebridge_python_class__, do: "REPLVariable"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec from_value(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_value(ref, name, value, field_info, preview_chars, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :from_value,
        [name, value, field_info, preview_chars],
        opts
      )
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Program do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Program"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule ProgramOfThought do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "ProgramOfThought"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _execute_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _execute_code(ref, code, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_execute_code, [code], opts)
    end

    @spec _generate_instruction(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _generate_instruction(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_generate_instruction, [mode], opts)
    end

    @spec _generate_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _generate_signature(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_generate_signature, [mode], opts)
    end

    @spec _parse_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_code(ref, code_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_parse_code, [code_data], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Propose.DatasetSummaryGenerator.DatasetDescriptor do
    def __snakebridge_python_name__, do: "dspy.propose.dataset_summary_generator"
    def __snakebridge_python_class__, do: "DatasetDescriptor"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Propose.DatasetSummaryGenerator.DatasetDescriptorWithPriorObservations do
    def __snakebridge_python_name__, do: "dspy.propose.dataset_summary_generator"
    def __snakebridge_python_class__, do: "DatasetDescriptorWithPriorObservations"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Propose.DatasetSummaryGenerator.ObservationSummarizer do
    def __snakebridge_python_name__, do: "dspy.propose.dataset_summary_generator"
    def __snakebridge_python_class__, do: "ObservationSummarizer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Propose.GroundedProposer.DescribeModule do
    def __snakebridge_python_name__, do: "dspy.propose.grounded_proposer"
    def __snakebridge_python_class__, do: "DescribeModule"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Propose.GroundedProposer.DescribeProgram do
    def __snakebridge_python_name__, do: "dspy.propose.grounded_proposer"
    def __snakebridge_python_class__, do: "DescribeProgram"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Propose.GroundedProposer.GenerateModuleInstruction do
    def __snakebridge_python_name__, do: "dspy.propose.grounded_proposer"
    def __snakebridge_python_class__, do: "GenerateModuleInstruction"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(
          ref,
          demo_candidates,
          pred_i,
          demo_set_i,
          program,
          previous_instructions,
          data_summary,
          args,
          opts \\ []
        ) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :forward,
        [demo_candidates, pred_i, demo_set_i, program, previous_instructions, data_summary] ++
          List.wrap(args),
        opts
      )
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Propose.GroundedProposer.GroundedProposer do
    def __snakebridge_python_name__, do: "dspy.propose.grounded_proposer"
    def __snakebridge_python_class__, do: "GroundedProposer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), term(), term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(prompt_model, program, trainset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [prompt_model, program, trainset] ++ List.wrap(args),
        opts
      )
    end

    @spec propose_instruction_for_predictor(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def propose_instruction_for_predictor(
          ref,
          program,
          predictor,
          pred_i,
          demo_candidates,
          demo_set_i,
          trial_logs,
          args,
          opts \\ []
        ) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :propose_instruction_for_predictor,
        [program, predictor, pred_i, demo_candidates, demo_set_i, trial_logs] ++ List.wrap(args),
        opts
      )
    end

    @spec propose_instructions_for_program(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, list(String.t())} | {:error, Snakepit.Error.t()}
    def propose_instructions_for_program(
          ref,
          trainset,
          program,
          demo_candidates,
          trial_logs,
          n,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :propose_instructions_for_program,
        [trainset, program, demo_candidates, trial_logs, n],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end
  end

  defmodule Propose.GroundedProposerClass3 do
    def __snakebridge_python_name__, do: "dspy.propose"
    def __snakebridge_python_class__, do: "GroundedProposer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), term(), term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(prompt_model, program, trainset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [prompt_model, program, trainset] ++ List.wrap(args),
        opts
      )
    end

    @spec propose_instruction_for_predictor(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def propose_instruction_for_predictor(
          ref,
          program,
          predictor,
          pred_i,
          demo_candidates,
          demo_set_i,
          trial_logs,
          args,
          opts \\ []
        ) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :propose_instruction_for_predictor,
        [program, predictor, pred_i, demo_candidates, demo_set_i, trial_logs] ++ List.wrap(args),
        opts
      )
    end

    @spec propose_instructions_for_program(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, list(String.t())} | {:error, Snakepit.Error.t()}
    def propose_instructions_for_program(
          ref,
          trainset,
          program,
          demo_candidates,
          trial_logs,
          n,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :propose_instructions_for_program,
        [trainset, program, demo_candidates, trial_logs, n],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end
  end

  defmodule Propose.ProposeBase.Proposer do
    def __snakebridge_python_name__, do: "dspy.propose.propose_base"
    def __snakebridge_python_class__, do: "Proposer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec propose_instruction_for_predictor(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def propose_instruction_for_predictor(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :propose_instruction_for_predictor, [], opts)
    end

    @spec propose_instructions_for_program(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def propose_instructions_for_program(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :propose_instructions_for_program, [], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end
  end

  defmodule Provider do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Provider"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finetune(
            SnakeBridge.Ref.t(),
            Dspy.Clients.Provider.TrainingJob.t(),
            String.t(),
            list(%{optional(String.t()) => term()}),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def finetune(ref, job, model, train_data, train_data_format, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :finetune,
        [job, model, train_data, train_data_format] ++ List.wrap(args),
        opts
      )
    end

    @spec is_provider_model(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_provider_model(ref, model, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_provider_model, [model], opts)
    end

    @spec kill(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :kill, [lm] ++ List.wrap(args), opts)
    end

    @spec launch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :launch, [lm] ++ List.wrap(args), opts)
    end
  end

  defmodule PythonInterpreter do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "PythonInterpreter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _ensure_deno_process(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _ensure_deno_process(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_ensure_deno_process, [], opts)
    end

    @spec _extract_parameters(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, list(%{optional(term()) => term()})} | {:error, Snakepit.Error.t()}
    def _extract_parameters(ref, py_fn, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_extract_parameters, [py_fn], opts)
    end

    @spec _get_deno_dir(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_deno_dir(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_deno_dir, [], opts)
    end

    @spec _get_runner_path(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _get_runner_path(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_runner_path, [], opts)
    end

    @spec _handle_tool_call(SnakeBridge.Ref.t(), %{optional(term()) => term()}, keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _handle_tool_call(ref, request, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_handle_tool_call, [request], opts)
    end

    @spec _inject_variables(
            SnakeBridge.Ref.t(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _inject_variables(ref, code, variables, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_inject_variables, [code, variables], opts)
    end

    @spec _mount_files(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _mount_files(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_mount_files, [], opts)
    end

    @spec _register_tools(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _register_tools(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_register_tools, [], opts)
    end

    @spec _serialize_value(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _serialize_value(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_serialize_value, [value], opts)
    end

    @spec _sync_files(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _sync_files(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_sync_files, [], opts)
    end

    @spec execute(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def execute(ref, code, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :execute, [code] ++ List.wrap(args), opts)
    end

    @spec shutdown(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def shutdown(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :shutdown, [], opts)
    end

    @spec start(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def start(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :start, [], opts)
    end
  end

  defmodule RLM do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "RLM"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), term(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(
          signature,
          max_iterations,
          max_llm_calls,
          max_output_chars,
          verbose,
          tools,
          sub_lm,
          interpreter,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [
          signature,
          max_iterations,
          max_llm_calls,
          max_output_chars,
          verbose,
          tools,
          sub_lm,
          interpreter
        ],
        opts
      )
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec _build_variables(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(Dspy.Primitives.ReplTypes.REPLVariable.t())} | {:error, Snakepit.Error.t()}
    def _build_variables(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_variables, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec _get_output_fields_info(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(term()) => term()})} | {:error, Snakepit.Error.t()}
    def _get_output_fields_info(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_output_fields_info, [], opts)
    end

    @spec _validate_tools(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _validate_tools(ref, tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_tools, [tools], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec _process_execution_result(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            list(String.t()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_execution_result(ref, pred, result, history, output_field_names, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_execution_result,
        [pred, result, history, output_field_names],
        opts
      )
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec _prepare_execution_tools(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def _prepare_execution_tools(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_prepare_execution_tools, [], opts)
    end

    @spec _format_tool_docs(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _format_tool_docs(ref, tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_tool_docs, [tools], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec _validate_inputs(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def _validate_inputs(ref, input_args, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_inputs, [input_args], opts)
    end

    @spec _aexecute_iteration(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.CodeInterpreter.t(),
            list(Dspy.Primitives.ReplTypes.REPLVariable.t()),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            integer(),
            %{optional(String.t()) => term()},
            list(String.t()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _aexecute_iteration(
          ref,
          repl,
          variables,
          history,
          iteration,
          input_args,
          output_field_names,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_aexecute_iteration,
        [repl, variables, history, iteration, input_args, output_field_names],
        opts
      )
    end

    @spec _inject_execution_context(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.CodeInterpreter.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def _inject_execution_context(ref, interpreter, execution_tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_inject_execution_context,
        [interpreter, execution_tools],
        opts
      )
    end

    @spec _make_llm_tools(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def _make_llm_tools(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_make_llm_tools, [] ++ List.wrap(args), opts)
    end

    @spec _interpreter_context(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _interpreter_context(ref, execution_tools, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_interpreter_context, [execution_tools], opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec _format_output(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _format_output(ref, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_output, [output], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec _extract_fallback(
            SnakeBridge.Ref.t(),
            list(Dspy.Primitives.ReplTypes.REPLVariable.t()),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            list(String.t()),
            keyword()
          ) :: {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def _extract_fallback(ref, variables, history, output_field_names, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_extract_fallback,
        [variables, history, output_field_names],
        opts
      )
    end

    @spec _build_signatures(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _build_signatures(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_signatures, [], opts)
    end

    @spec _execute_iteration(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.CodeInterpreter.t(),
            list(Dspy.Primitives.ReplTypes.REPLVariable.t()),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            integer(),
            %{optional(String.t()) => term()},
            list(String.t()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _execute_iteration(
          ref,
          repl,
          variables,
          history,
          iteration,
          input_args,
          output_field_names,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_execute_iteration,
        [repl, variables, history, iteration, input_args, output_field_names],
        opts
      )
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec _aextract_fallback(
            SnakeBridge.Ref.t(),
            list(Dspy.Primitives.ReplTypes.REPLVariable.t()),
            Dspy.Primitives.ReplTypes.REPLHistory.t(),
            list(String.t()),
            keyword()
          ) :: {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def _aextract_fallback(ref, variables, history, output_field_names, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_aextract_fallback,
        [variables, history, output_field_names],
        opts
      )
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec _process_final_output(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.CodeInterpreter.FinalOutput.t(),
            list(String.t()),
            keyword()
          ) :: {:ok, {term(), term()}} | {:error, Snakepit.Error.t()}
    def _process_final_output(ref, result, output_field_names, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_final_output,
        [result, output_field_names],
        opts
      )
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec _reserved_tool_names(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _reserved_tool_names(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_RESERVED_TOOL_NAMES)
    end

    @spec tools(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def tools(ref) do
      SnakeBridge.Runtime.get_attr(ref, :tools)
    end
  end

  defmodule ReAct do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "ReAct"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, tools, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [signature, tools] ++ List.wrap(args),
        opts
      )
    end

    @spec _async_call_with_potential_trajectory_truncation(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _async_call_with_potential_trajectory_truncation(ref, module, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_async_call_with_potential_trajectory_truncation,
        [module, trajectory],
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _call_with_potential_trajectory_truncation(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_with_potential_trajectory_truncation(ref, module, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_with_potential_trajectory_truncation,
        [module, trajectory],
        opts
      )
    end

    @spec _format_trajectory(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _format_trajectory(ref, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_trajectory, [trajectory], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec truncate_trajectory(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def truncate_trajectory(ref, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :truncate_trajectory, [trajectory], opts)
    end
  end

  defmodule Reasoning do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Reasoning"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.ReasoningClass.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Refine do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Refine"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            Dspy.Primitives.Module.Module.t(),
            integer(),
            term(),
            float(),
            list(term()),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(module, n, reward_fn, threshold, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [module, n, reward_fn, threshold] ++ List.wrap(args),
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Retrieve do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Retrieve"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, query, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [query] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec reset(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset, [], opts)
    end

    @spec desc(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def desc(ref) do
      SnakeBridge.Runtime.get_attr(ref, :desc)
    end

    @spec input_variable(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def input_variable(ref) do
      SnakeBridge.Runtime.get_attr(ref, :input_variable)
    end

    @spec name(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def name(ref) do
      SnakeBridge.Runtime.get_attr(ref, :name)
    end
  end

  defmodule Retrievers.Embeddings do
    def __snakebridge_python_name__, do: "dspy.retrievers.embeddings"
    def __snakebridge_python_class__, do: "Embeddings"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(String.t()), term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(corpus, embedder, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [corpus, embedder] ++ List.wrap(args),
        opts
      )
    end

    @spec _batch_forward(SnakeBridge.Ref.t(), list(String.t()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _batch_forward(ref, queries, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_batch_forward, [queries], opts)
    end

    @spec _build_faiss(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _build_faiss(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_faiss, [], opts)
    end

    @spec _faiss_search(SnakeBridge.Ref.t(), term(), integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _faiss_search(ref, query_embeddings, num_candidates, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_faiss_search,
        [query_embeddings, num_candidates],
        opts
      )
    end

    @spec _normalize(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _normalize(ref, embeddings, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_normalize, [embeddings], opts)
    end

    @spec _rerank_and_predict(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _rerank_and_predict(ref, q_embeds, candidate_indices, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_rerank_and_predict,
        [q_embeds, candidate_indices],
        opts
      )
    end

    @spec forward(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, query, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [query], opts)
    end

    @spec from_saved(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_saved(ref, path, embedder, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_saved, [path, embedder], opts)
    end

    @spec load(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, embedder, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path, embedder], opts)
    end

    @spec save(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :save, [path], opts)
    end
  end

  defmodule Retrievers.EmbeddingsClass do
    def __snakebridge_python_name__, do: "dspy.retrievers"
    def __snakebridge_python_class__, do: "Embeddings"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(String.t()), term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(corpus, embedder, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [corpus, embedder] ++ List.wrap(args),
        opts
      )
    end

    @spec _batch_forward(SnakeBridge.Ref.t(), list(String.t()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _batch_forward(ref, queries, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_batch_forward, [queries], opts)
    end

    @spec _build_faiss(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _build_faiss(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_faiss, [], opts)
    end

    @spec _faiss_search(SnakeBridge.Ref.t(), term(), integer(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _faiss_search(ref, query_embeddings, num_candidates, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_faiss_search,
        [query_embeddings, num_candidates],
        opts
      )
    end

    @spec _normalize(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _normalize(ref, embeddings, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_normalize, [embeddings], opts)
    end

    @spec _rerank_and_predict(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _rerank_and_predict(ref, q_embeds, candidate_indices, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_rerank_and_predict,
        [q_embeds, candidate_indices],
        opts
      )
    end

    @spec forward(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, query, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [query], opts)
    end

    @spec from_saved(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_saved(ref, path, embedder, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_saved, [path, embedder], opts)
    end

    @spec load(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, embedder, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path, embedder], opts)
    end

    @spec save(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :save, [path], opts)
    end
  end

  defmodule Retrievers.Retrieve.Retrieve do
    def __snakebridge_python_name__, do: "dspy.retrievers.retrieve"
    def __snakebridge_python_class__, do: "Retrieve"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, query, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [query] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec reset(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset, [], opts)
    end

    @spec desc(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def desc(ref) do
      SnakeBridge.Runtime.get_attr(ref, :desc)
    end

    @spec input_variable(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def input_variable(ref) do
      SnakeBridge.Runtime.get_attr(ref, :input_variable)
    end

    @spec name(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def name(ref) do
      SnakeBridge.Runtime.get_attr(ref, :name)
    end
  end

  defmodule Retrievers.RetrieveClass3 do
    def __snakebridge_python_name__, do: "dspy.retrievers"
    def __snakebridge_python_class__, do: "Retrieve"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, query, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [query] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec reset(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset, [], opts)
    end

    @spec desc(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def desc(ref) do
      SnakeBridge.Runtime.get_attr(ref, :desc)
    end

    @spec input_variable(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def input_variable(ref) do
      SnakeBridge.Runtime.get_attr(ref, :input_variable)
    end

    @spec name(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def name(ref) do
      SnakeBridge.Runtime.get_attr(ref, :name)
    end
  end

  defmodule SIMBA do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "SIMBA"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["metric"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Signature do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Signature"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule SignatureMeta do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "SignatureMeta"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _abc_caches_clear(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_caches_clear(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_abc_caches_clear, [], opts)
    end

    @spec _abc_registry_clear(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_registry_clear(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_abc_registry_clear, [], opts)
    end

    @spec _collect_bases_data(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _collect_bases_data(ref, bases, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_collect_bases_data, [bases], opts)
    end

    @spec _detect_custom_types_from_caller(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _detect_custom_types_from_caller(ref, signature_str, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_detect_custom_types_from_caller,
        [signature_str],
        opts
      )
    end

    @spec _dump_registry(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _dump_registry(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_dump_registry, [] ++ List.wrap(args), opts)
    end

    @spec _get_fields_with_type(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def _get_fields_with_type(ref, field_type, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_fields_with_type, [field_type], opts)
    end

    @spec _validate_fields(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _validate_fields(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_fields, [], opts)
    end

    @spec mro(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def mro(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :mro, [], opts)
    end

    @spec register(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def register(ref, subclass, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :register, [subclass], opts)
    end

    @spec fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :fields)
    end

    @spec input_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def input_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :input_fields)
    end

    @spec instructions(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def instructions(ref) do
      SnakeBridge.Runtime.get_attr(ref, :instructions)
    end

    @spec output_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def output_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :output_fields)
    end

    @spec signature(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def signature(ref) do
      SnakeBridge.Runtime.get_attr(ref, :signature)
    end
  end

  defmodule Signatures.Field.OldField do
    def __snakebridge_python_name__, do: "dspy.signatures.field"
    def __snakebridge_python_class__, do: "OldField"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["input"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finalize(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, key, inferred_prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [key, inferred_prefix], opts)
    end
  end

  defmodule Signatures.Field.OldInputField do
    def __snakebridge_python_name__, do: "dspy.signatures.field"
    def __snakebridge_python_class__, do: "OldInputField"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finalize(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, key, inferred_prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [key, inferred_prefix], opts)
    end
  end

  defmodule Signatures.Field.OldOutputField do
    def __snakebridge_python_name__, do: "dspy.signatures.field"
    def __snakebridge_python_class__, do: "OldOutputField"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finalize(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, key, inferred_prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [key, inferred_prefix], opts)
    end
  end

  defmodule Signatures.OldField do
    def __snakebridge_python_name__, do: "dspy.signatures"
    def __snakebridge_python_class__, do: "OldField"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["input"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finalize(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, key, inferred_prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [key, inferred_prefix], opts)
    end
  end

  defmodule Signatures.OldInputField do
    def __snakebridge_python_name__, do: "dspy.signatures"
    def __snakebridge_python_class__, do: "OldInputField"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finalize(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, key, inferred_prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [key, inferred_prefix], opts)
    end
  end

  defmodule Signatures.OldOutputField do
    def __snakebridge_python_name__, do: "dspy.signatures"
    def __snakebridge_python_class__, do: "OldOutputField"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finalize(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, key, inferred_prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [key, inferred_prefix], opts)
    end
  end

  defmodule Signatures.Signature.Signature do
    def __snakebridge_python_name__, do: "dspy.signatures.signature"
    def __snakebridge_python_class__, do: "Signature"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Signatures.Signature.SignatureMeta do
    def __snakebridge_python_name__, do: "dspy.signatures.signature"
    def __snakebridge_python_class__, do: "SignatureMeta"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _abc_caches_clear(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_caches_clear(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_abc_caches_clear, [], opts)
    end

    @spec _abc_registry_clear(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_registry_clear(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_abc_registry_clear, [], opts)
    end

    @spec _collect_bases_data(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _collect_bases_data(ref, bases, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_collect_bases_data, [bases], opts)
    end

    @spec _detect_custom_types_from_caller(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _detect_custom_types_from_caller(ref, signature_str, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_detect_custom_types_from_caller,
        [signature_str],
        opts
      )
    end

    @spec _dump_registry(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _dump_registry(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_dump_registry, [] ++ List.wrap(args), opts)
    end

    @spec _get_fields_with_type(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def _get_fields_with_type(ref, field_type, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_fields_with_type, [field_type], opts)
    end

    @spec _validate_fields(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _validate_fields(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_fields, [], opts)
    end

    @spec mro(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def mro(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :mro, [], opts)
    end

    @spec register(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def register(ref, subclass, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :register, [subclass], opts)
    end

    @spec fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :fields)
    end

    @spec input_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def input_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :input_fields)
    end

    @spec instructions(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def instructions(ref) do
      SnakeBridge.Runtime.get_attr(ref, :instructions)
    end

    @spec output_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def output_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :output_fields)
    end

    @spec signature(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def signature(ref) do
      SnakeBridge.Runtime.get_attr(ref, :signature)
    end
  end

  defmodule Signatures.SignatureClass do
    def __snakebridge_python_name__, do: "dspy.signatures"
    def __snakebridge_python_class__, do: "Signature"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Signatures.SignatureMeta do
    def __snakebridge_python_name__, do: "dspy.signatures"
    def __snakebridge_python_class__, do: "SignatureMeta"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _abc_caches_clear(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_caches_clear(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_abc_caches_clear, [], opts)
    end

    @spec _abc_registry_clear(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_registry_clear(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_abc_registry_clear, [], opts)
    end

    @spec _collect_bases_data(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _collect_bases_data(ref, bases, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_collect_bases_data, [bases], opts)
    end

    @spec _detect_custom_types_from_caller(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _detect_custom_types_from_caller(ref, signature_str, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_detect_custom_types_from_caller,
        [signature_str],
        opts
      )
    end

    @spec _dump_registry(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _dump_registry(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_dump_registry, [] ++ List.wrap(args), opts)
    end

    @spec _get_fields_with_type(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def _get_fields_with_type(ref, field_type, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_fields_with_type, [field_type], opts)
    end

    @spec _validate_fields(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _validate_fields(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_fields, [], opts)
    end

    @spec mro(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def mro(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :mro, [], opts)
    end

    @spec register(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def register(ref, subclass, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :register, [subclass], opts)
    end

    @spec fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :fields)
    end

    @spec input_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def input_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :input_fields)
    end

    @spec instructions(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def instructions(ref) do
      SnakeBridge.Runtime.get_attr(ref, :instructions)
    end

    @spec output_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def output_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :output_fields)
    end

    @spec signature(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def signature(ref) do
      SnakeBridge.Runtime.get_attr(ref, :signature)
    end
  end

  defmodule Streaming.Messages.StatusMessage do
    def __snakebridge_python_name__, do: "dspy.streaming.messages"
    def __snakebridge_python_class__, do: "StatusMessage"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t(), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(message, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [message], opts)
    end
  end

  defmodule Streaming.Messages.StatusMessageProvider do
    def __snakebridge_python_name__, do: "dspy.streaming.messages"
    def __snakebridge_python_class__, do: "StatusMessageProvider"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec lm_end_status_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def lm_end_status_message(ref, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :lm_end_status_message, [outputs], opts)
    end

    @spec lm_start_status_message(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lm_start_status_message(ref, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :lm_start_status_message, [instance, inputs], opts)
    end

    @spec module_end_status_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def module_end_status_message(ref, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :module_end_status_message, [outputs], opts)
    end

    @spec module_start_status_message(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def module_start_status_message(ref, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :module_start_status_message, [instance, inputs], opts)
    end

    @spec tool_end_status_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def tool_end_status_message(ref, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :tool_end_status_message, [outputs], opts)
    end

    @spec tool_start_status_message(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def tool_start_status_message(ref, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :tool_start_status_message, [instance, inputs], opts)
    end
  end

  defmodule Streaming.Messages.StatusStreamingCallback do
    def __snakebridge_python_name__, do: "dspy.streaming.messages"
    def __snakebridge_python_class__, do: "StatusStreamingCallback"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec on_adapter_format_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_adapter_format_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_adapter_format_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_adapter_format_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_adapter_format_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :on_adapter_format_start,
        [call_id, instance, inputs],
        opts
      )
    end

    @spec on_adapter_parse_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_adapter_parse_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_adapter_parse_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_adapter_parse_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_adapter_parse_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :on_adapter_parse_start,
        [call_id, instance, inputs],
        opts
      )
    end

    @spec on_evaluate_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_evaluate_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_evaluate_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_evaluate_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_evaluate_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :on_evaluate_start, [call_id, instance, inputs], opts)
    end

    @spec on_lm_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_lm_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_lm_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_lm_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_lm_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :on_lm_start, [call_id, instance, inputs], opts)
    end

    @spec on_module_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_module_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_module_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_module_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_module_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :on_module_start, [call_id, instance, inputs], opts)
    end

    @spec on_tool_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_tool_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_tool_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_tool_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_tool_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :on_tool_start, [call_id, instance, inputs], opts)
    end
  end

  defmodule Streaming.Messages.StreamResponse do
    def __snakebridge_python_name__, do: "dspy.streaming.messages"
    def __snakebridge_python_class__, do: "StreamResponse"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t(), String.t(), String.t(), boolean(), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(predict_name, signature_field_name, chunk, is_last_chunk, opts \\ []) do
      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [predict_name, signature_field_name, chunk, is_last_chunk],
        opts
      )
    end
  end

  defmodule Streaming.StatusMessage do
    def __snakebridge_python_name__, do: "dspy.streaming"
    def __snakebridge_python_class__, do: "StatusMessage"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t(), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(message, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [message], opts)
    end
  end

  defmodule Streaming.StatusMessageProvider do
    def __snakebridge_python_name__, do: "dspy.streaming"
    def __snakebridge_python_class__, do: "StatusMessageProvider"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec lm_end_status_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def lm_end_status_message(ref, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :lm_end_status_message, [outputs], opts)
    end

    @spec lm_start_status_message(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lm_start_status_message(ref, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :lm_start_status_message, [instance, inputs], opts)
    end

    @spec module_end_status_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def module_end_status_message(ref, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :module_end_status_message, [outputs], opts)
    end

    @spec module_start_status_message(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def module_start_status_message(ref, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :module_start_status_message, [instance, inputs], opts)
    end

    @spec tool_end_status_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def tool_end_status_message(ref, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :tool_end_status_message, [outputs], opts)
    end

    @spec tool_start_status_message(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def tool_start_status_message(ref, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :tool_start_status_message, [instance, inputs], opts)
    end
  end

  defmodule Streaming.StreamListener do
    def __snakebridge_python_name__, do: "dspy.streaming"
    def __snakebridge_python_class__, do: "StreamListener"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature_field_name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [signature_field_name] ++ List.wrap(args),
        opts
      )
    end

    @spec _buffered_message_end_with_start_identifier(
            SnakeBridge.Ref.t(),
            String.t(),
            String.t(),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _buffered_message_end_with_start_identifier(
          ref,
          concat_message,
          start_identifier,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_buffered_message_end_with_start_identifier,
        [concat_message, start_identifier],
        opts
      )
    end

    @spec _could_form_end_identifier(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _could_form_end_identifier(ref, concat_message, adapter_name, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_could_form_end_identifier,
        [concat_message, adapter_name],
        opts
      )
    end

    @spec _default_handle_stream_chunk(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _default_handle_stream_chunk(ref, token, end_identifier, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_default_handle_stream_chunk,
        [token, end_identifier],
        opts
      )
    end

    @spec _json_adapter_handle_stream_chunk(
            SnakeBridge.Ref.t(),
            String.t(),
            String.t(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _json_adapter_handle_stream_chunk(ref, token, chunk_message, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_json_adapter_handle_stream_chunk,
        [token, chunk_message],
        opts
      )
    end

    @spec finalize(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [], opts)
    end

    @spec flush(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def flush(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :flush, [], opts)
    end

    @spec py_receive(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def py_receive(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "receive", [chunk], opts)
    end

    @spec _output_type(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _output_type(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_output_type)
    end
  end

  defmodule Streaming.StreamResponse do
    def __snakebridge_python_name__, do: "dspy.streaming"
    def __snakebridge_python_class__, do: "StreamResponse"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t(), String.t(), String.t(), boolean(), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(predict_name, signature_field_name, chunk, is_last_chunk, opts \\ []) do
      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [predict_name, signature_field_name, chunk, is_last_chunk],
        opts
      )
    end
  end

  defmodule Streaming.StreamingListener.StreamListener do
    def __snakebridge_python_name__, do: "dspy.streaming.streaming_listener"
    def __snakebridge_python_class__, do: "StreamListener"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature_field_name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [signature_field_name] ++ List.wrap(args),
        opts
      )
    end

    @spec _buffered_message_end_with_start_identifier(
            SnakeBridge.Ref.t(),
            String.t(),
            String.t(),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _buffered_message_end_with_start_identifier(
          ref,
          concat_message,
          start_identifier,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_buffered_message_end_with_start_identifier,
        [concat_message, start_identifier],
        opts
      )
    end

    @spec _could_form_end_identifier(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _could_form_end_identifier(ref, concat_message, adapter_name, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_could_form_end_identifier,
        [concat_message, adapter_name],
        opts
      )
    end

    @spec _default_handle_stream_chunk(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _default_handle_stream_chunk(ref, token, end_identifier, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_default_handle_stream_chunk,
        [token, end_identifier],
        opts
      )
    end

    @spec _json_adapter_handle_stream_chunk(
            SnakeBridge.Ref.t(),
            String.t(),
            String.t(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _json_adapter_handle_stream_chunk(ref, token, chunk_message, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_json_adapter_handle_stream_chunk,
        [token, chunk_message],
        opts
      )
    end

    @spec finalize(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [], opts)
    end

    @spec flush(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def flush(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :flush, [], opts)
    end

    @spec py_receive(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def py_receive(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "receive", [chunk], opts)
    end

    @spec _output_type(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _output_type(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_output_type)
    end
  end

  defmodule Teleprompt.AvatarOptimizer do
    def __snakebridge_python_name__, do: "dspy.teleprompt.avatar_optimizer"
    def __snakebridge_python_class__, do: "AvatarOptimizer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec _get_pos_neg_results(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            keyword()
          ) ::
            {:ok,
             {float(), list(Dspy.Teleprompt.AvatarOptimizer.EvalResult.t()),
              list(Dspy.Teleprompt.AvatarOptimizer.EvalResult.t())}}
            | {:error, Snakepit.Error.t()}
    def _get_pos_neg_results(ref, actor, trainset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_pos_neg_results, [actor, trainset], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end

    @spec process_example(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def process_example(ref, actor, example, return_outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :process_example,
        [actor, example, return_outputs],
        opts
      )
    end

    @spec thread_safe_evaluator(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def thread_safe_evaluator(ref, devset, actor, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :thread_safe_evaluator,
        [devset, actor] ++ List.wrap(args),
        opts
      )
    end
  end

  defmodule Teleprompt.AvatarOptimizer.Comparator do
    def __snakebridge_python_name__, do: "dspy.teleprompt.avatar_optimizer"
    def __snakebridge_python_class__, do: "Comparator"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Teleprompt.AvatarOptimizer.EvalResult do
    def __snakebridge_python_name__, do: "dspy.teleprompt.avatar_optimizer"
    def __snakebridge_python_class__, do: "EvalResult"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Teleprompt.AvatarOptimizer.FeedbackBasedInstruction do
    def __snakebridge_python_name__, do: "dspy.teleprompt.avatar_optimizer"
    def __snakebridge_python_class__, do: "FeedbackBasedInstruction"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Teleprompt.AvatarOptimizerClass do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "AvatarOptimizer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec _get_pos_neg_results(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            keyword()
          ) ::
            {:ok,
             {float(), list(Dspy.Teleprompt.AvatarOptimizer.EvalResult.t()),
              list(Dspy.Teleprompt.AvatarOptimizer.EvalResult.t())}}
            | {:error, Snakepit.Error.t()}
    def _get_pos_neg_results(ref, actor, trainset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_pos_neg_results, [actor, trainset], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end

    @spec process_example(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def process_example(ref, actor, example, return_outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :process_example,
        [actor, example, return_outputs],
        opts
      )
    end

    @spec thread_safe_evaluator(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def thread_safe_evaluator(ref, devset, actor, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :thread_safe_evaluator,
        [devset, actor] ++ List.wrap(args),
        opts
      )
    end
  end

  defmodule Teleprompt.BetterTogether do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "BetterTogether"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec _compile_prompt_optimizer(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def _compile_prompt_optimizer(ref, student, trainset, valset_ratio, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_compile_prompt_optimizer,
        [student, trainset, valset_ratio],
        opts
      )
    end

    @spec _compile_weight_optimizer(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def _compile_weight_optimizer(ref, student, trainset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_compile_weight_optimizer, [student, trainset], opts)
    end

    @spec _run_strategies(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def _run_strategies(ref, parsed_strategy, student, trainset, valset_ratio, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_run_strategies,
        [parsed_strategy, student, trainset, valset_ratio],
        opts
      )
    end

    @spec compile(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            list(term()),
            keyword()
          ) :: {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, trainset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :compile, [student, trainset] ++ List.wrap(args), opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end

    @spec strat_sep(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def strat_sep(ref) do
      SnakeBridge.Runtime.get_attr(ref, :STRAT_SEP)
    end
  end

  defmodule Teleprompt.Bettertogether.BetterTogether do
    def __snakebridge_python_name__, do: "dspy.teleprompt.bettertogether"
    def __snakebridge_python_class__, do: "BetterTogether"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec _compile_prompt_optimizer(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def _compile_prompt_optimizer(ref, student, trainset, valset_ratio, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_compile_prompt_optimizer,
        [student, trainset, valset_ratio],
        opts
      )
    end

    @spec _compile_weight_optimizer(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def _compile_weight_optimizer(ref, student, trainset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_compile_weight_optimizer, [student, trainset], opts)
    end

    @spec _run_strategies(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def _run_strategies(ref, parsed_strategy, student, trainset, valset_ratio, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_run_strategies,
        [parsed_strategy, student, trainset, valset_ratio],
        opts
      )
    end

    @spec compile(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            list(term()),
            keyword()
          ) :: {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, trainset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :compile, [student, trainset] ++ List.wrap(args), opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end

    @spec strat_sep(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def strat_sep(ref) do
      SnakeBridge.Runtime.get_attr(ref, :STRAT_SEP)
    end
  end

  defmodule Teleprompt.Bootstrap.BootstrapFewShot do
    def __snakebridge_python_name__, do: "dspy.teleprompt.bootstrap"
    def __snakebridge_python_class__, do: "BootstrapFewShot"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _bootstrap(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_bootstrap, [], opts)
    end

    @spec _bootstrap_one_example(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap_one_example(ref, example, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_bootstrap_one_example,
        [example] ++ List.wrap(args),
        opts
      )
    end

    @spec _prepare_predictor_mappings(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_predictor_mappings(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_prepare_predictor_mappings, [], opts)
    end

    @spec _prepare_student_and_teacher(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_student_and_teacher(ref, student, teacher, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_prepare_student_and_teacher,
        [student, teacher],
        opts
      )
    end

    @spec _train(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _train(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_train, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.BootstrapFewShot do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "BootstrapFewShot"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _bootstrap(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_bootstrap, [], opts)
    end

    @spec _bootstrap_one_example(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap_one_example(ref, example, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_bootstrap_one_example,
        [example] ++ List.wrap(args),
        opts
      )
    end

    @spec _prepare_predictor_mappings(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_predictor_mappings(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_prepare_predictor_mappings, [], opts)
    end

    @spec _prepare_student_and_teacher(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_student_and_teacher(ref, student, teacher, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_prepare_student_and_teacher,
        [student, teacher],
        opts
      )
    end

    @spec _train(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _train(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_train, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.BootstrapFewShotWithOptuna do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "BootstrapFewShotWithOptuna"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["max_demos", "trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end

    @spec objective(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def objective(ref, trial, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :objective, [trial], opts)
    end
  end

  defmodule Teleprompt.BootstrapFewShotWithRandomSearch do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "BootstrapFewShotWithRandomSearch"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.BootstrapFinetune.BootstrapFinetune do
    def __snakebridge_python_name__, do: "dspy.teleprompt.bootstrap_finetune"
    def __snakebridge_python_class__, do: "BootstrapFinetune"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _prepare_finetune_data(
            SnakeBridge.Ref.t(),
            list(%{optional(String.t()) => term()}),
            Dspy.Clients.LMClass.t(),
            list(term()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_finetune_data(ref, trace_data, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_prepare_finetune_data,
        [trace_data, lm] ++ List.wrap(args),
        opts
      )
    end

    @spec compile(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            list(term()),
            keyword()
          ) :: {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, trainset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :compile, [student, trainset] ++ List.wrap(args), opts)
    end

    @spec convert_to_lm_dict(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, %{optional(Dspy.Clients.LMClass.t()) => term()}} | {:error, Snakepit.Error.t()}
    def convert_to_lm_dict(ref, arg, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :convert_to_lm_dict, [arg], opts)
    end

    @spec finetune_lms(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, %{optional(term()) => Dspy.Clients.LMClass.t()}} | {:error, Snakepit.Error.t()}
    def finetune_lms(ref, finetune_dict, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finetune_lms, [finetune_dict], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.BootstrapFinetune.FinetuneTeleprompter do
    def __snakebridge_python_name__, do: "dspy.teleprompt.bootstrap_finetune"
    def __snakebridge_python_class__, do: "FinetuneTeleprompter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec convert_to_lm_dict(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, %{optional(Dspy.Clients.LMClass.t()) => term()}} | {:error, Snakepit.Error.t()}
    def convert_to_lm_dict(ref, arg, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :convert_to_lm_dict, [arg], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.BootstrapFinetuneClass do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "BootstrapFinetune"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _prepare_finetune_data(
            SnakeBridge.Ref.t(),
            list(%{optional(String.t()) => term()}),
            Dspy.Clients.LMClass.t(),
            list(term()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_finetune_data(ref, trace_data, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_prepare_finetune_data,
        [trace_data, lm] ++ List.wrap(args),
        opts
      )
    end

    @spec compile(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            list(term()),
            keyword()
          ) :: {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, trainset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :compile, [student, trainset] ++ List.wrap(args), opts)
    end

    @spec convert_to_lm_dict(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, %{optional(Dspy.Clients.LMClass.t()) => term()}} | {:error, Snakepit.Error.t()}
    def convert_to_lm_dict(ref, arg, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :convert_to_lm_dict, [arg], opts)
    end

    @spec finetune_lms(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, %{optional(term()) => Dspy.Clients.LMClass.t()}} | {:error, Snakepit.Error.t()}
    def finetune_lms(ref, finetune_dict, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finetune_lms, [finetune_dict], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.BootstrapTrace.FailedPrediction do
    def __snakebridge_python_name__, do: "dspy.teleprompt.bootstrap_trace"
    def __snakebridge_python_class__, do: "FailedPrediction"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(completion_text, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [completion_text] ++ List.wrap(args),
        opts
      )
    end

    @spec format_reward(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_reward(ref) do
      SnakeBridge.Runtime.get_attr(ref, :format_reward)
    end
  end

  defmodule Teleprompt.BootstrapTrace.TraceData do
    def __snakebridge_python_name__, do: "dspy.teleprompt.bootstrap_trace"
    def __snakebridge_python_class__, do: "TraceData"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec clear(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def clear(ref) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], [])
    end

    def clear(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
    end

    def clear(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], [])
    end

    def clear(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], opts)
    end

    def clear(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], [])
    end

    def clear(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], opts)
    end

    def clear(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], [])
    end

    def clear(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec copy(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], [])
    end

    def copy(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    def copy(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], [])
    end

    def copy(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], opts)
    end

    def copy(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], [])
    end

    def copy(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], opts)
    end

    def copy(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], [])
    end

    def copy(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec fromkeys(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def fromkeys(ref, iterable, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :fromkeys, [iterable] ++ List.wrap(args), opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec items(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref) do
      SnakeBridge.Runtime.call_method(ref, :items, [], [])
    end

    def items(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end

    def items(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], [])
    end

    def items(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], opts)
    end

    def items(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], [])
    end

    def items(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], opts)
    end

    def items(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], [])
    end

    def items(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec keys(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], [])
    end

    def keys(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], opts)
    end

    def keys(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], [])
    end

    def keys(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], opts)
    end

    def keys(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], [])
    end

    def keys(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], opts)
    end

    def keys(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], [])
    end

    def keys(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec pop(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pop(ref) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], [])
    end

    def pop(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], opts)
    end

    def pop(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], [])
    end

    def pop(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], opts)
    end

    def pop(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], [])
    end

    def pop(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], opts)
    end

    def pop(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], [])
    end

    def pop(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec popitem(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def popitem(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :popitem, [], opts)
    end

    @spec setdefault(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def setdefault(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :setdefault, [key] ++ List.wrap(args), opts)
    end

    @spec update(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def update(ref) do
      SnakeBridge.Runtime.call_method(ref, :update, [], [])
    end

    def update(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [], opts)
    end

    def update(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], [])
    end

    def update(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], opts)
    end

    def update(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], [])
    end

    def update(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], opts)
    end

    def update(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], [])
    end

    def update(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec values(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref) do
      SnakeBridge.Runtime.call_method(ref, :values, [], [])
    end

    def values(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [], opts)
    end

    def values(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], [])
    end

    def values(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], opts)
    end

    def values(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], [])
    end

    def values(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], opts)
    end

    def values(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], [])
    end

    def values(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end
  end

  defmodule Teleprompt.COPRO do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "COPRO"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _check_candidates_equal(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _check_candidates_equal(ref, candidate1, candidate2, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_check_candidates_equal,
        [candidate1, candidate2],
        opts
      )
    end

    @spec _drop_duplicates(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _drop_duplicates(ref, candidates, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_drop_duplicates, [candidates], opts)
    end

    @spec _get_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_signature(ref, predictor, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_signature, [predictor], opts)
    end

    @spec _print_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _print_signature(ref, predictor, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_print_signature, [predictor], opts)
    end

    @spec _set_signature(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_signature(ref, predictor, updated_signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_signature, [predictor, updated_signature], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset", "eval_kwargs"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.CoproOptimizer.BasicGenerateInstruction do
    def __snakebridge_python_name__, do: "dspy.teleprompt.copro_optimizer"
    def __snakebridge_python_class__, do: "BasicGenerateInstruction"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Teleprompt.CoproOptimizer.COPRO do
    def __snakebridge_python_name__, do: "dspy.teleprompt.copro_optimizer"
    def __snakebridge_python_class__, do: "COPRO"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _check_candidates_equal(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _check_candidates_equal(ref, candidate1, candidate2, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_check_candidates_equal,
        [candidate1, candidate2],
        opts
      )
    end

    @spec _drop_duplicates(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _drop_duplicates(ref, candidates, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_drop_duplicates, [candidates], opts)
    end

    @spec _get_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_signature(ref, predictor, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_signature, [predictor], opts)
    end

    @spec _print_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _print_signature(ref, predictor, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_print_signature, [predictor], opts)
    end

    @spec _set_signature(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_signature(ref, predictor, updated_signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_signature, [predictor, updated_signature], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset", "eval_kwargs"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.CoproOptimizer.GenerateInstructionGivenAttempts do
    def __snakebridge_python_name__, do: "dspy.teleprompt.copro_optimizer"
    def __snakebridge_python_class__, do: "GenerateInstructionGivenAttempts"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Teleprompt.Ensemble do
    def __snakebridge_python_name__, do: "dspy.teleprompt.ensemble"
    def __snakebridge_python_class__, do: "Ensemble"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, programs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :compile, [programs], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.EnsembleClass do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "Ensemble"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, programs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :compile, [programs], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.GEPA do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa"
    def __snakebridge_python_class__, do: "GEPA"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(Dspy.Teleprompt.Gepa.Gepa.GEPAFeedbackMetric.t(), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric], opts)
    end

    @spec _build_seed_candidate(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, %{optional(String.t()) => String.t()}} | {:error, Snakepit.Error.t()}
    def _build_seed_candidate(ref, student, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_seed_candidate, [student], opts)
    end

    @spec auto_budget(SnakeBridge.Ref.t(), term(), term(), integer(), list(term()), keyword()) ::
            {:ok, integer()} | {:error, Snakepit.Error.t()}
    def auto_budget(ref, num_preds, num_candidates, valset_size, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :auto_budget,
        [num_preds, num_candidates, valset_size] ++ List.wrap(args),
        opts
      )
    end

    @spec compile(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.GEPAClass do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "GEPA"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(Dspy.Teleprompt.Gepa.Gepa.GEPAFeedbackMetric.t(), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric], opts)
    end

    @spec _build_seed_candidate(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, %{optional(String.t()) => String.t()}} | {:error, Snakepit.Error.t()}
    def _build_seed_candidate(ref, student, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_seed_candidate, [student], opts)
    end

    @spec auto_budget(SnakeBridge.Ref.t(), term(), term(), integer(), list(term()), keyword()) ::
            {:ok, integer()} | {:error, Snakepit.Error.t()}
    def auto_budget(ref, num_preds, num_candidates, valset_size, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :auto_budget,
        [num_preds, num_candidates, valset_size] ++ List.wrap(args),
        opts
      )
    end

    @spec compile(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.GRPO do
    def __snakebridge_python_name__, do: "dspy.teleprompt.grpo"
    def __snakebridge_python_class__, do: "GRPO"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec compile(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.Module.Module.t(),
            list(Dspy.Primitives.Example.t()),
            list(term()),
            keyword()
          ) :: {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, trainset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :compile, [student, trainset] ++ List.wrap(args), opts)
    end

    @spec convert_to_lm_dict(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, %{optional(Dspy.Clients.LMClass.t()) => term()}} | {:error, Snakepit.Error.t()}
    def convert_to_lm_dict(ref, arg, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :convert_to_lm_dict, [arg], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end

    @spec report_validation_metrics(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def report_validation_metrics(ref, student, trainset, valset, logger, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :report_validation_metrics,
        [student, trainset, valset, logger] ++ List.wrap(args),
        opts
      )
    end

    @spec select_training_sample_and_update_shuffled_trainset(
            SnakeBridge.Ref.t(),
            list(Dspy.Primitives.Example.t()),
            integer(),
            keyword()
          ) :: {:ok, list(Dspy.Primitives.Example.t())} | {:error, Snakepit.Error.t()}
    def select_training_sample_and_update_shuffled_trainset(
          ref,
          original_trainset,
          train_step_idx,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :select_training_sample_and_update_shuffled_trainset,
        [original_trainset, train_step_idx],
        opts
      )
    end

    @spec update_shuffled_trainset(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_shuffled_trainset(ref, original_trainset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_shuffled_trainset, [original_trainset], opts)
    end

    @spec validate_trace_data_and_log_issues(
            SnakeBridge.Ref.t(),
            list(list(list(%{optional(String.t()) => term()}))),
            list(Dspy.Primitives.Example.t()),
            integer(),
            integer(),
            %{optional(integer()) => integer()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate_trace_data_and_log_issues(
          ref,
          trace_data,
          subsample_training_dataset,
          num_teachers,
          num_samples_per_input,
          pred_signature_hash_to_ind,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :validate_trace_data_and_log_issues,
        [
          trace_data,
          subsample_training_dataset,
          num_teachers,
          num_samples_per_input,
          pred_signature_hash_to_ind
        ],
        opts
      )
    end
  end

  defmodule Teleprompt.Gepa.GEPA do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.gepa"
    def __snakebridge_python_class__, do: "GEPA"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(Dspy.Teleprompt.Gepa.Gepa.GEPAFeedbackMetric.t(), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric], opts)
    end

    @spec _build_seed_candidate(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, %{optional(String.t()) => String.t()}} | {:error, Snakepit.Error.t()}
    def _build_seed_candidate(ref, student, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_build_seed_candidate, [student], opts)
    end

    @spec auto_budget(SnakeBridge.Ref.t(), term(), term(), integer(), list(term()), keyword()) ::
            {:ok, integer()} | {:error, Snakepit.Error.t()}
    def auto_budget(ref, num_preds, num_candidates, valset_size, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :auto_budget,
        [num_preds, num_candidates, valset_size] ++ List.wrap(args),
        opts
      )
    end

    @spec compile(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.Gepa.Gepa.DspyGEPAResult do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.gepa"
    def __snakebridge_python_class__, do: "DspyGEPAResult"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            list(Dspy.Primitives.Module.Module.t()),
            list(list(term())),
            list(float()),
            list(list(float())),
            list(MapSet.t(integer())),
            list(integer()),
            list(term()),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(
          candidates,
          parents,
          val_aggregate_scores,
          val_subscores,
          per_val_instance_best_candidates,
          discovery_eval_counts,
          args,
          opts \\ []
        ) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [
          candidates,
          parents,
          val_aggregate_scores,
          val_subscores,
          per_val_instance_best_candidates,
          discovery_eval_counts
        ] ++ List.wrap(args),
        opts
      )
    end

    @spec from_gepa_result(
            SnakeBridge.Ref.t(),
            term(),
            Dspy.Teleprompt.Gepa.GepaUtils.DspyAdapter.t(),
            keyword()
          ) :: {:ok, Dspy.Teleprompt.Gepa.Gepa.DspyGEPAResult.t()} | {:error, Snakepit.Error.t()}
    def from_gepa_result(ref, gepa_result, adapter, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_gepa_result, [gepa_result, adapter], opts)
    end

    @spec to_dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def to_dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :to_dict, [], opts)
    end

    @spec best_candidate(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def best_candidate(ref) do
      SnakeBridge.Runtime.get_attr(ref, :best_candidate)
    end

    @spec best_idx(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def best_idx(ref) do
      SnakeBridge.Runtime.get_attr(ref, :best_idx)
    end

    @spec best_outputs_valset(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def best_outputs_valset(ref) do
      SnakeBridge.Runtime.get_attr(ref, :best_outputs_valset)
    end

    @spec highest_score_achieved_per_val_task(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def highest_score_achieved_per_val_task(ref) do
      SnakeBridge.Runtime.get_attr(ref, :highest_score_achieved_per_val_task)
    end

    @spec log_dir(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def log_dir(ref) do
      SnakeBridge.Runtime.get_attr(ref, :log_dir)
    end

    @spec num_full_val_evals(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def num_full_val_evals(ref) do
      SnakeBridge.Runtime.get_attr(ref, :num_full_val_evals)
    end

    @spec seed(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def seed(ref) do
      SnakeBridge.Runtime.get_attr(ref, :seed)
    end

    @spec total_metric_calls(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def total_metric_calls(ref) do
      SnakeBridge.Runtime.get_attr(ref, :total_metric_calls)
    end
  end

  defmodule Teleprompt.Gepa.Gepa.GEPAFeedbackMetric do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.gepa"
    def __snakebridge_python_class__, do: "GEPAFeedbackMetric"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec _is_protocol(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_protocol)
    end

    @spec _is_runtime_protocol(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_runtime_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_runtime_protocol)
    end
  end

  defmodule Teleprompt.Gepa.GepaUtils.DspyAdapter do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.gepa_utils"
    def __snakebridge_python_class__, do: "DspyAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), term(), %{optional(String.t()) => term()}, list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(student_module, metric_fn, feedback_map, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [student_module, metric_fn, feedback_map] ++ List.wrap(args),
        opts
      )
    end

    @spec _collect_tools(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, %{optional(String.t()) => Dspy.Adapters.Types.Tool.Tool.t()}}
            | {:error, Snakepit.Error.t()}
    def _collect_tools(ref, module, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_collect_tools, [module], opts)
    end

    @spec _update_tool_descriptions(
            SnakeBridge.Ref.t(),
            Dspy.Primitives.Module.Module.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def _update_tool_descriptions(ref, program, tool_candidates, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_update_tool_descriptions,
        [program, tool_candidates],
        opts
      )
    end

    @spec build_program(SnakeBridge.Ref.t(), %{optional(String.t()) => String.t()}, keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def build_program(ref, candidate, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :build_program, [candidate], opts)
    end

    @spec evaluate(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def evaluate(ref, batch, candidate, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :evaluate, [batch, candidate] ++ List.wrap(args), opts)
    end

    @spec make_reflective_dataset(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok,
             %{optional(String.t()) => list(Dspy.Teleprompt.Gepa.GepaUtils.ReflectiveExample.t())}}
            | {:error, Snakepit.Error.t()}
    def make_reflective_dataset(ref, candidate, eval_batch, components_to_update, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :make_reflective_dataset,
        [candidate, eval_batch, components_to_update],
        opts
      )
    end

    @spec propose_new_texts(
            SnakeBridge.Ref.t(),
            %{optional(String.t()) => String.t()},
            %{optional(String.t()) => list(%{optional(String.t()) => term()})},
            list(String.t()),
            keyword()
          ) :: {:ok, %{optional(String.t()) => String.t()}} | {:error, Snakepit.Error.t()}
    def propose_new_texts(ref, candidate, reflective_dataset, components_to_update, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :propose_new_texts,
        [candidate, reflective_dataset, components_to_update],
        opts
      )
    end

    @spec stripped_lm_call(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, list(String.t())} | {:error, Snakepit.Error.t()}
    def stripped_lm_call(ref, x, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :stripped_lm_call, [x], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec _is_protocol(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_protocol)
    end

    @spec _is_runtime_protocol(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_runtime_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_runtime_protocol)
    end
  end

  defmodule Teleprompt.Gepa.GepaUtils.LoggerAdapter do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.gepa_utils"
    def __snakebridge_python_class__, do: "LoggerAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(logger, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [logger], opts)
    end

    @spec log(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def log(ref, x, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :log, [x], opts)
    end
  end

  defmodule Teleprompt.Gepa.GepaUtils.PredictorFeedbackFn do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.gepa_utils"
    def __snakebridge_python_class__, do: "PredictorFeedbackFn"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec _is_protocol(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_protocol)
    end

    @spec _is_runtime_protocol(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_runtime_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_runtime_protocol)
    end
  end

  defmodule Teleprompt.Gepa.GepaUtils.ReflectiveExample do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.gepa_utils"
    def __snakebridge_python_class__, do: "ReflectiveExample"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec clear(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec clear(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def clear(ref) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], [])
    end

    def clear(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
    end

    def clear(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], [])
    end

    def clear(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1], opts)
    end

    def clear(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], [])
    end

    def clear(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2], opts)
    end

    def clear(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], [])
    end

    def clear(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :clear, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def clear(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :clear,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec copy(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec copy(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], [])
    end

    def copy(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    def copy(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], [])
    end

    def copy(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1], opts)
    end

    def copy(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], [])
    end

    def copy(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2], opts)
    end

    def copy(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], [])
    end

    def copy(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :copy, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def copy(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :copy,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec fromkeys(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def fromkeys(ref, iterable, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :fromkeys, [iterable] ++ List.wrap(args), opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec items(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec items(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref) do
      SnakeBridge.Runtime.call_method(ref, :items, [], [])
    end

    def items(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end

    def items(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], [])
    end

    def items(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1], opts)
    end

    def items(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], [])
    end

    def items(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2], opts)
    end

    def items(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], [])
    end

    def items(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :items, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def items(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :items,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec keys(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec keys(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], [])
    end

    def keys(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [], opts)
    end

    def keys(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], [])
    end

    def keys(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1], opts)
    end

    def keys(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], [])
    end

    def keys(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2], opts)
    end

    def keys(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], [])
    end

    def keys(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :keys, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def keys(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :keys,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec pop(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec pop(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def pop(ref) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], [])
    end

    def pop(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [], opts)
    end

    def pop(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], [])
    end

    def pop(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1], opts)
    end

    def pop(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], [])
    end

    def pop(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2], opts)
    end

    def pop(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], [])
    end

    def pop(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :pop, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def pop(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :pop,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec popitem(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def popitem(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :popitem, [], opts)
    end

    @spec setdefault(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def setdefault(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :setdefault, [key] ++ List.wrap(args), opts)
    end

    @spec update(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec update(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def update(ref) do
      SnakeBridge.Runtime.call_method(ref, :update, [], [])
    end

    def update(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [], opts)
    end

    def update(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], [])
    end

    def update(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1], opts)
    end

    def update(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], [])
    end

    def update(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2], opts)
    end

    def update(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], [])
    end

    def update(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :update, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def update(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec values(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec values(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref) do
      SnakeBridge.Runtime.call_method(ref, :values, [], [])
    end

    def values(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [], opts)
    end

    def values(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], [])
    end

    def values(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1], opts)
    end

    def values(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], [])
    end

    def values(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2], opts)
    end

    def values(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], [])
    end

    def values(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :values, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def values(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :values,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end
  end

  defmodule Teleprompt.Gepa.GepaUtils.ScoreWithFeedback do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.gepa_utils"
    def __snakebridge_python_class__, do: "ScoreWithFeedback"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec from_completions(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_completions(ref, list_or_dict, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :from_completions,
        [list_or_dict] ++ List.wrap(args),
        opts
      )
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec get_lm_usage(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm_usage(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm_usage, [], opts)
    end

    @spec inputs(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inputs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :inputs, [], opts)
    end

    @spec items(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :items, [] ++ List.wrap(args), opts)
    end

    @spec keys(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :keys, [] ++ List.wrap(args), opts)
    end

    @spec labels(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def labels(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :labels, [], opts)
    end

    @spec set_lm_usage(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm_usage(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm_usage, [value], opts)
    end

    @spec to_dict(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "toDict", [], opts)
    end

    @spec values(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :values, [] ++ List.wrap(args), opts)
    end

    @spec with_inputs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_inputs(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_inputs, [] ++ List.wrap(args), opts)
    end

    @spec without(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def without(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :without, [] ++ List.wrap(args), opts)
    end

    @spec completions(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def completions(ref) do
      SnakeBridge.Runtime.get_attr(ref, :completions)
    end
  end

  defmodule Teleprompt.Gepa.InstructionProposal.GenerateEnhancedMultimodalInstructionFromFeedback do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.instruction_proposal"
    def __snakebridge_python_class__, do: "GenerateEnhancedMultimodalInstructionFromFeedback"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Teleprompt.Gepa.InstructionProposal.GenerateImprovedToolModuleDescriptionsFromFeedback do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.instruction_proposal"
    def __snakebridge_python_class__, do: "GenerateImprovedToolModuleDescriptionsFromFeedback"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Teleprompt.Gepa.InstructionProposal.MultiModalInstructionProposer do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.instruction_proposal"
    def __snakebridge_python_class__, do: "MultiModalInstructionProposer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec _is_protocol(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_protocol)
    end

    @spec _is_runtime_protocol(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_runtime_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_runtime_protocol)
    end
  end

  defmodule Teleprompt.Gepa.InstructionProposal.SingleComponentMultiModalProposer do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.instruction_proposal"
    def __snakebridge_python_class__, do: "SingleComponentMultiModalProposer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _analyze_feedback_patterns(
            SnakeBridge.Ref.t(),
            list(Dspy.Teleprompt.Gepa.GepaUtils.ReflectiveExample.t()),
            keyword()
          ) :: {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def _analyze_feedback_patterns(ref, reflective_dataset, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_analyze_feedback_patterns,
        [reflective_dataset],
        opts
      )
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _create_multimodal_examples(
            SnakeBridge.Ref.t(),
            String.t(),
            %{optional(integer()) => list(Dspy.Adapters.Types.BaseType.Type.t())},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _create_multimodal_examples(ref, formatted_text, image_map, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_create_multimodal_examples,
        [formatted_text, image_map],
        opts
      )
    end

    @spec _create_pattern_summary(
            SnakeBridge.Ref.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _create_pattern_summary(ref, feedback_analysis, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_create_pattern_summary, [feedback_analysis], opts)
    end

    @spec _format_examples_for_instruction_generation(
            SnakeBridge.Ref.t(),
            list(Dspy.Teleprompt.Gepa.GepaUtils.ReflectiveExample.t()),
            keyword()
          ) ::
            {:ok,
             {String.t(), %{optional(integer()) => list(Dspy.Adapters.Types.BaseType.Type.t())}}}
            | {:error, Snakepit.Error.t()}
    def _format_examples_for_instruction_generation(ref, reflective_dataset, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_format_examples_for_instruction_generation,
        [reflective_dataset],
        opts
      )
    end

    @spec _format_examples_with_pattern_analysis(
            SnakeBridge.Ref.t(),
            list(Dspy.Teleprompt.Gepa.GepaUtils.ReflectiveExample.t()),
            keyword()
          ) ::
            {:ok,
             {String.t(), %{optional(integer()) => list(Dspy.Adapters.Types.BaseType.Type.t())}}}
            | {:error, Snakepit.Error.t()}
    def _format_examples_with_pattern_analysis(ref, reflective_dataset, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_format_examples_with_pattern_analysis,
        [reflective_dataset],
        opts
      )
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(
            SnakeBridge.Ref.t(),
            String.t(),
            list(Dspy.Teleprompt.Gepa.GepaUtils.ReflectiveExample.t()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def forward(ref, current_instruction, reflective_dataset, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :forward,
        [current_instruction, reflective_dataset],
        opts
      )
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Teleprompt.Gepa.InstructionProposal.ToolProposer do
    def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.instruction_proposal"
    def __snakebridge_python_class__, do: "ToolProposer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _format_examples(
            SnakeBridge.Ref.t(),
            list(Dspy.Teleprompt.Gepa.GepaUtils.ReflectiveExample.t()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def _format_examples(ref, reflective_dataset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_examples, [reflective_dataset], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec _is_protocol(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_protocol)
    end

    @spec _is_runtime_protocol(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _is_runtime_protocol(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_is_runtime_protocol)
    end
  end

  defmodule Teleprompt.InferRules do
    def __snakebridge_python_name__, do: "dspy.teleprompt.infer_rules"
    def __snakebridge_python_class__, do: "InferRules"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _bootstrap(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_bootstrap, [], opts)
    end

    @spec _bootstrap_one_example(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap_one_example(ref, example, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_bootstrap_one_example,
        [example] ++ List.wrap(args),
        opts
      )
    end

    @spec _prepare_predictor_mappings(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_predictor_mappings(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_prepare_predictor_mappings, [], opts)
    end

    @spec _prepare_student_and_teacher(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_student_and_teacher(ref, student, teacher, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_prepare_student_and_teacher,
        [student, teacher],
        opts
      )
    end

    @spec _train(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _train(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_train, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec evaluate_program(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def evaluate_program(ref, program, dataset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :evaluate_program, [program, dataset], opts)
    end

    @spec format_examples(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_examples(ref, demos, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_examples, [demos, signature], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end

    @spec get_predictor_demos(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_predictor_demos(ref, trainset, predictor, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_predictor_demos, [trainset, predictor], opts)
    end

    @spec induce_natural_language_rules(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def induce_natural_language_rules(ref, predictor, trainset, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :induce_natural_language_rules,
        [predictor, trainset],
        opts
      )
    end

    @spec update_program_instructions(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_program_instructions(ref, predictor, natural_language_rules, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update_program_instructions,
        [predictor, natural_language_rules],
        opts
      )
    end
  end

  defmodule Teleprompt.InferRules.RulesInductionProgram do
    def __snakebridge_python_name__, do: "dspy.teleprompt.infer_rules"
    def __snakebridge_python_class__, do: "RulesInductionProgram"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(num_rules, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [num_rules] ++ List.wrap(args), opts)
    end

    @spec _base_init(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _base_init(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
    end

    @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_lm_usage(ref, tokens, output, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, Dspy.Primitives.Prediction.t()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, examples_text, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [examples_text], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Teleprompt.InferRulesClass do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "InferRules"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _bootstrap(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_bootstrap, [], opts)
    end

    @spec _bootstrap_one_example(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap_one_example(ref, example, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :_bootstrap_one_example,
        [example] ++ List.wrap(args),
        opts
      )
    end

    @spec _prepare_predictor_mappings(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_predictor_mappings(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_prepare_predictor_mappings, [], opts)
    end

    @spec _prepare_student_and_teacher(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _prepare_student_and_teacher(ref, student, teacher, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_prepare_student_and_teacher,
        [student, teacher],
        opts
      )
    end

    @spec _train(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _train(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_train, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec evaluate_program(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def evaluate_program(ref, program, dataset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :evaluate_program, [program, dataset], opts)
    end

    @spec format_examples(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_examples(ref, demos, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_examples, [demos, signature], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end

    @spec get_predictor_demos(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_predictor_demos(ref, trainset, predictor, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_predictor_demos, [trainset, predictor], opts)
    end

    @spec induce_natural_language_rules(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def induce_natural_language_rules(ref, predictor, trainset, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :induce_natural_language_rules,
        [predictor, trainset],
        opts
      )
    end

    @spec update_program_instructions(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_program_instructions(ref, predictor, natural_language_rules, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :update_program_instructions,
        [predictor, natural_language_rules],
        opts
      )
    end
  end

  defmodule Teleprompt.KNNFewShot do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "KNNFewShot"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            integer(),
            list(Dspy.Primitives.Example.t()),
            Dspy.Clients.Embedding.Embedder.t(),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(k, trainset, vectorizer, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [k, trainset, vectorizer], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.KnnFewshot.KNNFewShot do
    def __snakebridge_python_name__, do: "dspy.teleprompt.knn_fewshot"
    def __snakebridge_python_class__, do: "KNNFewShot"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            integer(),
            list(Dspy.Primitives.Example.t()),
            Dspy.Clients.Embedding.Embedder.t(),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(k, trainset, vectorizer, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [k, trainset, vectorizer], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.LabeledFewShot do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "LabeledFewShot"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.MIPROv2 do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "MIPROv2"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec _bootstrap_fewshot_examples(
            SnakeBridge.Ref.t(),
            term(),
            list(term()),
            integer(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap_fewshot_examples(ref, program, trainset, seed, teacher, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)

      missing_kw =
        [
          "num_fewshot_candidates",
          "max_bootstrapped_demos",
          "max_labeled_demos",
          "max_errors",
          "metric_threshold"
        ]
        |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(
        ref,
        :_bootstrap_fewshot_examples,
        [program, trainset, seed, teacher],
        opts
      )
    end

    @spec _estimate_lm_calls(
            SnakeBridge.Ref.t(),
            term(),
            integer(),
            boolean(),
            integer(),
            integer(),
            list(term()),
            boolean(),
            integer(),
            keyword()
          ) :: {:ok, {String.t(), String.t()}} | {:error, Snakepit.Error.t()}
    def _estimate_lm_calls(
          ref,
          program,
          num_trials,
          minibatch,
          minibatch_size,
          minibatch_full_eval_steps,
          valset,
          program_aware_proposer,
          num_instruct_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_estimate_lm_calls,
        [
          program,
          num_trials,
          minibatch,
          minibatch_size,
          minibatch_full_eval_steps,
          valset,
          program_aware_proposer,
          num_instruct_candidates
        ],
        opts
      )
    end

    @spec _get_param_distributions(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_param_distributions(
          ref,
          program,
          instruction_candidates,
          demo_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_get_param_distributions,
        [program, instruction_candidates, demo_candidates],
        opts
      )
    end

    @spec _log_minibatch_eval(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _log_minibatch_eval(
          ref,
          score,
          best_score,
          batch_size,
          chosen_params,
          score_data,
          trial,
          adjusted_num_trials,
          trial_logs,
          trial_num,
          candidate_program,
          total_eval_calls,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_log_minibatch_eval,
        [
          score,
          best_score,
          batch_size,
          chosen_params,
          score_data,
          trial,
          adjusted_num_trials,
          trial_logs,
          trial_num,
          candidate_program,
          total_eval_calls
        ],
        opts
      )
    end

    @spec _log_normal_eval(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _log_normal_eval(
          ref,
          score,
          best_score,
          chosen_params,
          score_data,
          trial,
          num_trials,
          trial_logs,
          trial_num,
          valset,
          batch_size,
          candidate_program,
          total_eval_calls,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_log_normal_eval,
        [
          score,
          best_score,
          chosen_params,
          score_data,
          trial,
          num_trials,
          trial_logs,
          trial_num,
          valset,
          batch_size,
          candidate_program,
          total_eval_calls
        ],
        opts
      )
    end

    @spec _optimize_prompt_parameters(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(integer()) => list(String.t())},
            term(),
            Dspy.Evaluate.Evaluate.Evaluate.t(),
            list(term()),
            integer(),
            boolean(),
            integer(),
            integer(),
            integer(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _optimize_prompt_parameters(
          ref,
          program,
          instruction_candidates,
          demo_candidates,
          evaluate,
          valset,
          num_trials,
          minibatch,
          minibatch_size,
          minibatch_full_eval_steps,
          seed,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_optimize_prompt_parameters,
        [
          program,
          instruction_candidates,
          demo_candidates,
          evaluate,
          valset,
          num_trials,
          minibatch,
          minibatch_size,
          minibatch_full_eval_steps,
          seed
        ],
        opts
      )
    end

    @spec _perform_full_evaluation(
            SnakeBridge.Ref.t(),
            integer(),
            integer(),
            %{optional(term()) => term()},
            %{optional(term()) => term()},
            Dspy.Evaluate.Evaluate.Evaluate.t(),
            list(term()),
            %{optional(term()) => term()},
            integer(),
            term(),
            float(),
            term(),
            term(),
            list(term()),
            list(term()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _perform_full_evaluation(
          ref,
          trial_num,
          adjusted_num_trials,
          param_score_dict,
          fully_evaled_param_combos,
          evaluate,
          valset,
          trial_logs,
          total_eval_calls,
          score_data,
          best_score,
          best_program,
          study,
          instruction_candidates,
          demo_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_perform_full_evaluation,
        [
          trial_num,
          adjusted_num_trials,
          param_score_dict,
          fully_evaled_param_combos,
          evaluate,
          valset,
          trial_logs,
          total_eval_calls,
          score_data,
          best_score,
          best_program,
          study,
          instruction_candidates,
          demo_candidates
        ],
        opts
      )
    end

    @spec _print_auto_run_settings(
            SnakeBridge.Ref.t(),
            integer(),
            boolean(),
            list(term()),
            integer(),
            integer(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _print_auto_run_settings(
          ref,
          num_trials,
          minibatch,
          valset,
          num_fewshot_candidates,
          num_instruct_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_print_auto_run_settings,
        [num_trials, minibatch, valset, num_fewshot_candidates, num_instruct_candidates],
        opts
      )
    end

    @spec _propose_instructions(
            SnakeBridge.Ref.t(),
            term(),
            list(term()),
            term(),
            integer(),
            boolean(),
            boolean(),
            boolean(),
            boolean(),
            integer(),
            keyword()
          ) :: {:ok, %{optional(integer()) => list(String.t())}} | {:error, Snakepit.Error.t()}
    def _propose_instructions(
          ref,
          program,
          trainset,
          demo_candidates,
          view_data_batch_size,
          program_aware_proposer,
          data_aware_proposer,
          tip_aware_proposer,
          fewshot_aware_proposer,
          num_instruct_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_propose_instructions,
        [
          program,
          trainset,
          demo_candidates,
          view_data_batch_size,
          program_aware_proposer,
          data_aware_proposer,
          tip_aware_proposer,
          fewshot_aware_proposer,
          num_instruct_candidates
        ],
        opts
      )
    end

    @spec _select_and_insert_instructions_and_demos(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(integer()) => list(String.t())},
            term(),
            term(),
            %{optional(term()) => term()},
            integer(),
            keyword()
          ) :: {:ok, list(String.t())} | {:error, Snakepit.Error.t()}
    def _select_and_insert_instructions_and_demos(
          ref,
          candidate_program,
          instruction_candidates,
          demo_candidates,
          trial,
          trial_logs,
          trial_num,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_select_and_insert_instructions_and_demos,
        [
          candidate_program,
          instruction_candidates,
          demo_candidates,
          trial,
          trial_logs,
          trial_num
        ],
        opts
      )
    end

    @spec _set_and_validate_datasets(SnakeBridge.Ref.t(), list(term()), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_and_validate_datasets(ref, trainset, valset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_and_validate_datasets, [trainset, valset], opts)
    end

    @spec _set_hyperparams_from_run_mode(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            boolean(),
            boolean(),
            list(term()),
            term(),
            term(),
            keyword()
          ) ::
            {:ok, {integer(), list(term()), boolean(), integer(), integer()}}
            | {:error, Snakepit.Error.t()}
    def _set_hyperparams_from_run_mode(
          ref,
          program,
          num_trials,
          minibatch,
          zeroshot_opt,
          valset,
          num_instruct_candidates,
          num_fewshot_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_set_hyperparams_from_run_mode,
        [
          program,
          num_trials,
          minibatch,
          zeroshot_opt,
          valset,
          num_instruct_candidates,
          num_fewshot_candidates
        ],
        opts
      )
    end

    @spec _set_num_trials_from_num_candidates(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_num_trials_from_num_candidates(
          ref,
          program,
          zeroshot_opt,
          num_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_set_num_trials_from_num_candidates,
        [program, zeroshot_opt, num_candidates],
        opts
      )
    end

    @spec _set_random_seeds(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_random_seeds(ref, seed, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_random_seeds, [seed], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.MiproOptimizerV2.MIPROv2 do
    def __snakebridge_python_name__, do: "dspy.teleprompt.mipro_optimizer_v2"
    def __snakebridge_python_class__, do: "MIPROv2"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec _bootstrap_fewshot_examples(
            SnakeBridge.Ref.t(),
            term(),
            list(term()),
            integer(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _bootstrap_fewshot_examples(ref, program, trainset, seed, teacher, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)

      missing_kw =
        [
          "num_fewshot_candidates",
          "max_bootstrapped_demos",
          "max_labeled_demos",
          "max_errors",
          "metric_threshold"
        ]
        |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(
        ref,
        :_bootstrap_fewshot_examples,
        [program, trainset, seed, teacher],
        opts
      )
    end

    @spec _estimate_lm_calls(
            SnakeBridge.Ref.t(),
            term(),
            integer(),
            boolean(),
            integer(),
            integer(),
            list(term()),
            boolean(),
            integer(),
            keyword()
          ) :: {:ok, {String.t(), String.t()}} | {:error, Snakepit.Error.t()}
    def _estimate_lm_calls(
          ref,
          program,
          num_trials,
          minibatch,
          minibatch_size,
          minibatch_full_eval_steps,
          valset,
          program_aware_proposer,
          num_instruct_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_estimate_lm_calls,
        [
          program,
          num_trials,
          minibatch,
          minibatch_size,
          minibatch_full_eval_steps,
          valset,
          program_aware_proposer,
          num_instruct_candidates
        ],
        opts
      )
    end

    @spec _get_param_distributions(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_param_distributions(
          ref,
          program,
          instruction_candidates,
          demo_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_get_param_distributions,
        [program, instruction_candidates, demo_candidates],
        opts
      )
    end

    @spec _log_minibatch_eval(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _log_minibatch_eval(
          ref,
          score,
          best_score,
          batch_size,
          chosen_params,
          score_data,
          trial,
          adjusted_num_trials,
          trial_logs,
          trial_num,
          candidate_program,
          total_eval_calls,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_log_minibatch_eval,
        [
          score,
          best_score,
          batch_size,
          chosen_params,
          score_data,
          trial,
          adjusted_num_trials,
          trial_logs,
          trial_num,
          candidate_program,
          total_eval_calls
        ],
        opts
      )
    end

    @spec _log_normal_eval(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _log_normal_eval(
          ref,
          score,
          best_score,
          chosen_params,
          score_data,
          trial,
          num_trials,
          trial_logs,
          trial_num,
          valset,
          batch_size,
          candidate_program,
          total_eval_calls,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_log_normal_eval,
        [
          score,
          best_score,
          chosen_params,
          score_data,
          trial,
          num_trials,
          trial_logs,
          trial_num,
          valset,
          batch_size,
          candidate_program,
          total_eval_calls
        ],
        opts
      )
    end

    @spec _optimize_prompt_parameters(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(integer()) => list(String.t())},
            term(),
            Dspy.Evaluate.Evaluate.Evaluate.t(),
            list(term()),
            integer(),
            boolean(),
            integer(),
            integer(),
            integer(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _optimize_prompt_parameters(
          ref,
          program,
          instruction_candidates,
          demo_candidates,
          evaluate,
          valset,
          num_trials,
          minibatch,
          minibatch_size,
          minibatch_full_eval_steps,
          seed,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_optimize_prompt_parameters,
        [
          program,
          instruction_candidates,
          demo_candidates,
          evaluate,
          valset,
          num_trials,
          minibatch,
          minibatch_size,
          minibatch_full_eval_steps,
          seed
        ],
        opts
      )
    end

    @spec _perform_full_evaluation(
            SnakeBridge.Ref.t(),
            integer(),
            integer(),
            %{optional(term()) => term()},
            %{optional(term()) => term()},
            Dspy.Evaluate.Evaluate.Evaluate.t(),
            list(term()),
            %{optional(term()) => term()},
            integer(),
            term(),
            float(),
            term(),
            term(),
            list(term()),
            list(term()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _perform_full_evaluation(
          ref,
          trial_num,
          adjusted_num_trials,
          param_score_dict,
          fully_evaled_param_combos,
          evaluate,
          valset,
          trial_logs,
          total_eval_calls,
          score_data,
          best_score,
          best_program,
          study,
          instruction_candidates,
          demo_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_perform_full_evaluation,
        [
          trial_num,
          adjusted_num_trials,
          param_score_dict,
          fully_evaled_param_combos,
          evaluate,
          valset,
          trial_logs,
          total_eval_calls,
          score_data,
          best_score,
          best_program,
          study,
          instruction_candidates,
          demo_candidates
        ],
        opts
      )
    end

    @spec _print_auto_run_settings(
            SnakeBridge.Ref.t(),
            integer(),
            boolean(),
            list(term()),
            integer(),
            integer(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _print_auto_run_settings(
          ref,
          num_trials,
          minibatch,
          valset,
          num_fewshot_candidates,
          num_instruct_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_print_auto_run_settings,
        [num_trials, minibatch, valset, num_fewshot_candidates, num_instruct_candidates],
        opts
      )
    end

    @spec _propose_instructions(
            SnakeBridge.Ref.t(),
            term(),
            list(term()),
            term(),
            integer(),
            boolean(),
            boolean(),
            boolean(),
            boolean(),
            integer(),
            keyword()
          ) :: {:ok, %{optional(integer()) => list(String.t())}} | {:error, Snakepit.Error.t()}
    def _propose_instructions(
          ref,
          program,
          trainset,
          demo_candidates,
          view_data_batch_size,
          program_aware_proposer,
          data_aware_proposer,
          tip_aware_proposer,
          fewshot_aware_proposer,
          num_instruct_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_propose_instructions,
        [
          program,
          trainset,
          demo_candidates,
          view_data_batch_size,
          program_aware_proposer,
          data_aware_proposer,
          tip_aware_proposer,
          fewshot_aware_proposer,
          num_instruct_candidates
        ],
        opts
      )
    end

    @spec _select_and_insert_instructions_and_demos(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(integer()) => list(String.t())},
            term(),
            term(),
            %{optional(term()) => term()},
            integer(),
            keyword()
          ) :: {:ok, list(String.t())} | {:error, Snakepit.Error.t()}
    def _select_and_insert_instructions_and_demos(
          ref,
          candidate_program,
          instruction_candidates,
          demo_candidates,
          trial,
          trial_logs,
          trial_num,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_select_and_insert_instructions_and_demos,
        [
          candidate_program,
          instruction_candidates,
          demo_candidates,
          trial,
          trial_logs,
          trial_num
        ],
        opts
      )
    end

    @spec _set_and_validate_datasets(SnakeBridge.Ref.t(), list(term()), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_and_validate_datasets(ref, trainset, valset, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_and_validate_datasets, [trainset, valset], opts)
    end

    @spec _set_hyperparams_from_run_mode(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            boolean(),
            boolean(),
            list(term()),
            term(),
            term(),
            keyword()
          ) ::
            {:ok, {integer(), list(term()), boolean(), integer(), integer()}}
            | {:error, Snakepit.Error.t()}
    def _set_hyperparams_from_run_mode(
          ref,
          program,
          num_trials,
          minibatch,
          zeroshot_opt,
          valset,
          num_instruct_candidates,
          num_fewshot_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_set_hyperparams_from_run_mode,
        [
          program,
          num_trials,
          minibatch,
          zeroshot_opt,
          valset,
          num_instruct_candidates,
          num_fewshot_candidates
        ],
        opts
      )
    end

    @spec _set_num_trials_from_num_candidates(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_num_trials_from_num_candidates(
          ref,
          program,
          zeroshot_opt,
          num_candidates,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_set_num_trials_from_num_candidates,
        [program, zeroshot_opt, num_candidates],
        opts
      )
    end

    @spec _set_random_seeds(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_random_seeds(ref, seed, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_random_seeds, [seed], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.RandomSearch.BootstrapFewShotWithRandomSearch do
    def __snakebridge_python_name__, do: "dspy.teleprompt.random_search"
    def __snakebridge_python_class__, do: "BootstrapFewShotWithRandomSearch"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.SIMBA do
    def __snakebridge_python_name__, do: "dspy.teleprompt.simba"
    def __snakebridge_python_class__, do: "SIMBA"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["metric"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.SIMBAClass do
    def __snakebridge_python_name__, do: "dspy.teleprompt"
    def __snakebridge_python_class__, do: "SIMBA"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["metric"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.SignatureOpt.SignatureOptimizer do
    def __snakebridge_python_name__, do: "dspy.teleprompt.signature_opt"
    def __snakebridge_python_class__, do: "SignatureOptimizer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _check_candidates_equal(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _check_candidates_equal(ref, candidate1, candidate2, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_check_candidates_equal,
        [candidate1, candidate2],
        opts
      )
    end

    @spec _drop_duplicates(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _drop_duplicates(ref, candidates, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_drop_duplicates, [candidates], opts)
    end

    @spec _get_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_signature(ref, predictor, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_signature, [predictor], opts)
    end

    @spec _print_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _print_signature(ref, predictor, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_print_signature, [predictor], opts)
    end

    @spec _set_signature(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _set_signature(ref, predictor, updated_signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_set_signature, [predictor, updated_signature], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["devset", "eval_kwargs"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.SimbaUtils.OfferFeedback do
    def __snakebridge_python_name__, do: "dspy.teleprompt.simba_utils"
    def __snakebridge_python_class__, do: "OfferFeedback"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_instructions(ref, instructions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def delete(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prepend(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_updated_fields(ref, name, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def append(ref, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def equals(ref, other, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def insert(ref, index, name, field, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Teleprompt.Teleprompt.Teleprompter do
    def __snakebridge_python_name__, do: "dspy.teleprompt.teleprompt"
    def __snakebridge_python_class__, do: "Teleprompter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), Dspy.Primitives.Module.Module.t(), keyword()) ::
            {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Teleprompt.TelepromptOptuna.BootstrapFewShotWithOptuna do
    def __snakebridge_python_name__, do: "dspy.teleprompt.teleprompt_optuna"
    def __snakebridge_python_class__, do: "BootstrapFewShotWithOptuna"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["max_demos", "trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end

    @spec objective(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def objective(ref, trial, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :objective, [trial], opts)
    end
  end

  defmodule Teleprompt.Vanilla.LabeledFewShot do
    def __snakebridge_python_name__, do: "dspy.teleprompt.vanilla"
    def __snakebridge_python_class__, do: "LabeledFewShot"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def get_params(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
    end
  end

  defmodule Tool do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Tool"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(func, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [func] ++ List.wrap(args), opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec _run_async_in_sync(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _run_async_in_sync(ref, coroutine, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_run_async_in_sync, [coroutine], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec from_langchain(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_langchain(ref, tool, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_langchain, [tool], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec format_as_litellm_function_call(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_as_litellm_function_call(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_as_litellm_function_call, [], opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _validate_and_parse_args(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _validate_and_parse_args(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_validate_and_parse_args, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec from_mcp_tool(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_mcp_tool(ref, session, tool, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_mcp_tool, [session, tool], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec _parse_function(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_function(ref, func, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :_parse_function, [func] ++ List.wrap(args), opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec acall(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def acall(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :acall, [], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule ToolCalls do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "ToolCalls"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec tool_call(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def tool_call(ref, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["name", "args"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, "ToolCall", [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec validate_input(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def validate_input(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate_input, [data], opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec from_dict_list(SnakeBridge.Ref.t(), list(%{optional(String.t()) => term()}), keyword()) ::
            {:ok, Dspy.Adapters.Types.Tool.ToolCalls.t()} | {:error, Snakepit.Error.t()}
    def from_dict_list(ref, tool_calls_dicts, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_dict_list, [tool_calls_dicts], opts)
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule TrainingJob do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "TrainingJob"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec __future__get_result(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def __future__get_result(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "_Future__get_result", [], opts)
    end

    @spec _invoke_callbacks(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _invoke_callbacks(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_invoke_callbacks, [], opts)
    end

    @spec add_done_callback(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def add_done_callback(ref, py_fn, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :add_done_callback, [py_fn], opts)
    end

    @spec cancel(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancel(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cancel, [], opts)
    end

    @spec cancelled(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancelled(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cancelled, [], opts)
    end

    @spec done(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def done(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :done, [], opts)
    end

    @spec exception(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def exception(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :exception, [] ++ List.wrap(args), opts)
    end

    @spec result(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def result(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :result, [] ++ List.wrap(args), opts)
    end

    @spec running(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def running(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :running, [], opts)
    end

    @spec set_exception(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_exception(ref, exception, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_exception, [exception], opts)
    end

    @spec set_result(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_result(ref, result, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_result, [result], opts)
    end

    @spec set_running_or_notify_cancel(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_running_or_notify_cancel(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_running_or_notify_cancel, [], opts)
    end

    @spec status(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def status(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :status, [], opts)
    end
  end

  defmodule TwoStepAdapter do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "TwoStepAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(Dspy.Clients.LMClass.t(), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(extraction_model, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [extraction_model], opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _create_extractor_signature(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _create_extractor_signature(ref, original_signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_create_extractor_signature,
        [original_signature],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            Dspy.Clients.LMClass.t(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(
            SnakeBridge.Ref.t(),
            Dspy.Signatures.Signature.Signature.t(),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(
            SnakeBridge.Ref.t(),
            Dspy.Signatures.Signature.Signature.t(),
            String.t(),
            keyword()
          ) :: {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end
  end

  defmodule Type do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Type"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :extract_custom_type_from_annotation,
        [annotation],
        opts
      )
    end

    @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_json(ref, json_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
    end

    @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_raw,
        [b, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_obj(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
    end

    @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_value(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
    end

    @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _calculate_keys(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
    end

    @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def schema_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, include, exclude, update, deep, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
    end

    @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate_strings(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
    end

    @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_rebuild(
          ref,
          force,
          raise_errors,
          parent_namespace_depth,
          types_namespace,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :model_rebuild,
        [force, raise_errors, parent_namespace_depth, types_namespace],
        opts
      )
    end

    @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _iter(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
    end

    @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_validate(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def construct(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
    end

    @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def from_orm(ref, obj, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
    end

    @spec adapt_to_native_lm_feature(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :adapt_to_native_lm_feature,
        [signature, field_name, lm, lm_kwargs],
        opts
      )
    end

    @spec description(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def description(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :description, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [], opts)
    end

    @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
    end

    @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_lm_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
    end

    @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_streamable(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
    def parse_stream_chunk(ref, chunk, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
    end

    @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_parametrized_name(ref, params, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_json_schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def validate(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
    end

    @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def schema(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
    end

    @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
            {:ok, term() | nil} | {:error, Snakepit.Error.t()}
    def _setattr_handler(ref, name, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
    end

    @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update_forward_refs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
    end

    @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :parse_file,
        [path, content_type, encoding, proto, allow_pickle],
        opts
      )
    end

    @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _abc_impl(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
    end

    @spec model_computed_fields(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_computed_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
    end

    @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_config(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_config)
    end

    @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_extra(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_extra)
    end

    @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields)
    end

    @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_fields_set(ref) do
      SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
    end
  end

  defmodule Utils.BaseCallback do
    def __snakebridge_python_name__, do: "dspy.utils"
    def __snakebridge_python_class__, do: "BaseCallback"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec on_adapter_format_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_adapter_format_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_adapter_format_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_adapter_format_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_adapter_format_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :on_adapter_format_start,
        [call_id, instance, inputs],
        opts
      )
    end

    @spec on_adapter_parse_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_adapter_parse_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_adapter_parse_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_adapter_parse_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_adapter_parse_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :on_adapter_parse_start,
        [call_id, instance, inputs],
        opts
      )
    end

    @spec on_evaluate_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_evaluate_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_evaluate_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_evaluate_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_evaluate_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :on_evaluate_start, [call_id, instance, inputs], opts)
    end

    @spec on_lm_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_lm_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_lm_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_lm_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_lm_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :on_lm_start, [call_id, instance, inputs], opts)
    end

    @spec on_module_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_module_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_module_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_module_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_module_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :on_module_start, [call_id, instance, inputs], opts)
    end

    @spec on_tool_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_tool_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_tool_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_tool_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_tool_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :on_tool_start, [call_id, instance, inputs], opts)
    end
  end

  defmodule Utils.Callback.BaseCallback do
    def __snakebridge_python_name__, do: "dspy.utils.callback"
    def __snakebridge_python_class__, do: "BaseCallback"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec on_adapter_format_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_adapter_format_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_adapter_format_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_adapter_format_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_adapter_format_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :on_adapter_format_start,
        [call_id, instance, inputs],
        opts
      )
    end

    @spec on_adapter_parse_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_adapter_parse_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_adapter_parse_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_adapter_parse_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_adapter_parse_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :on_adapter_parse_start,
        [call_id, instance, inputs],
        opts
      )
    end

    @spec on_evaluate_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_evaluate_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_evaluate_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_evaluate_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_evaluate_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :on_evaluate_start, [call_id, instance, inputs], opts)
    end

    @spec on_lm_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_lm_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_lm_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_lm_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_lm_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :on_lm_start, [call_id, instance, inputs], opts)
    end

    @spec on_module_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_module_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_module_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_module_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_module_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :on_module_start, [call_id, instance, inputs], opts)
    end

    @spec on_tool_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_tool_end(ref, call_id, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :on_tool_end,
        [call_id, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec on_tool_start(
            SnakeBridge.Ref.t(),
            String.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def on_tool_start(ref, call_id, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :on_tool_start, [call_id, instance, inputs], opts)
    end
  end

  defmodule Utils.Dummies.DummyLM do
    def __snakebridge_python_name__, do: "dspy.utils.dummies"
    def __snakebridge_python_class__, do: "DummyLM"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(answers, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [answers] ++ List.wrap(args), opts)
    end

    @spec _check_truncation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _check_truncation(ref, results, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_check_truncation, [results], opts)
    end

    @spec _extract_citations_from_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _extract_citations_from_response(ref, choice, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_extract_citations_from_response, [choice], opts)
    end

    @spec _get_cached_completion_fn(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_cached_completion_fn(ref, completion_fn, cache, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_get_cached_completion_fn,
        [completion_fn, cache],
        opts
      )
    end

    @spec _process_completion(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_completion(ref, response, merged_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_completion, [response, merged_kwargs], opts)
    end

    @spec _process_lm_response(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_lm_response(ref, response, prompt, messages, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_lm_response,
        [response, prompt, messages],
        opts
      )
    end

    @spec _process_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_response, [response], opts)
    end

    @spec _run_finetune_job(SnakeBridge.Ref.t(), Dspy.Clients.Provider.TrainingJob.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _run_finetune_job(ref, job, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_run_finetune_job, [job], opts)
    end

    @spec _use_example(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _use_example(ref, messages, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_use_example, [messages], opts)
    end

    @spec _warn_zero_temp_rollout(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _warn_zero_temp_rollout(ref, temperature, rollout_id, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_warn_zero_temp_rollout,
        [temperature, rollout_id],
        opts
      )
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :aforward, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec finetune(
            SnakeBridge.Ref.t(),
            list(%{optional(String.t()) => term()}),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, Dspy.Clients.Provider.TrainingJob.t()} | {:error, Snakepit.Error.t()}
    def finetune(ref, train_data, train_data_format, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :finetune,
        [train_data, train_data_format] ++ List.wrap(args),
        opts
      )
    end

    @spec forward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [] ++ List.wrap(args), opts)
    end

    @spec get_convo(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_convo(ref, index, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_convo, [index], opts)
    end

    @spec infer_provider(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, Dspy.Clients.ProviderClass.t()} | {:error, Snakepit.Error.t()}
    def infer_provider(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :infer_provider, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec kill(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :kill, [] ++ List.wrap(args), opts)
    end

    @spec launch(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :launch, [] ++ List.wrap(args), opts)
    end

    @spec reinforce(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Clients.Provider.ReinforceJob.t()} | {:error, Snakepit.Error.t()}
    def reinforce(ref, train_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reinforce, [train_kwargs], opts)
    end

    @spec update_history(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_history(ref, entry, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_history, [entry], opts)
    end
  end

  defmodule Utils.Dummies.DummyVectorizer do
    def __snakebridge_python_name__, do: "dspy.utils.dummies"
    def __snakebridge_python_class__, do: "DummyVectorizer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _hash(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _hash(ref, gram, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_hash, [gram], opts)
    end
  end

  defmodule Utils.DummyLM do
    def __snakebridge_python_name__, do: "dspy.utils"
    def __snakebridge_python_class__, do: "DummyLM"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(answers, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [answers] ++ List.wrap(args), opts)
    end

    @spec _check_truncation(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _check_truncation(ref, results, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_check_truncation, [results], opts)
    end

    @spec _extract_citations_from_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _extract_citations_from_response(ref, choice, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_extract_citations_from_response, [choice], opts)
    end

    @spec _get_cached_completion_fn(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _get_cached_completion_fn(ref, completion_fn, cache, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_get_cached_completion_fn,
        [completion_fn, cache],
        opts
      )
    end

    @spec _process_completion(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_completion(ref, response, merged_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_completion, [response, merged_kwargs], opts)
    end

    @spec _process_lm_response(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_lm_response(ref, response, prompt, messages, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_process_lm_response,
        [response, prompt, messages],
        opts
      )
    end

    @spec _process_response(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _process_response(ref, response, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_process_response, [response], opts)
    end

    @spec _run_finetune_job(SnakeBridge.Ref.t(), Dspy.Clients.Provider.TrainingJob.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _run_finetune_job(ref, job, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_run_finetune_job, [job], opts)
    end

    @spec _use_example(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _use_example(ref, messages, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_use_example, [messages], opts)
    end

    @spec _warn_zero_temp_rollout(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _warn_zero_temp_rollout(ref, temperature, rollout_id, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_warn_zero_temp_rollout,
        [temperature, rollout_id],
        opts
      )
    end

    @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def acall(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
    end

    @spec aforward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def aforward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :aforward, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec finetune(
            SnakeBridge.Ref.t(),
            list(%{optional(String.t()) => term()}),
            term(),
            list(term()),
            keyword()
          ) :: {:ok, Dspy.Clients.Provider.TrainingJob.t()} | {:error, Snakepit.Error.t()}
    def finetune(ref, train_data, train_data_format, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :finetune,
        [train_data, train_data_format] ++ List.wrap(args),
        opts
      )
    end

    @spec forward(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [] ++ List.wrap(args), opts)
    end

    @spec get_convo(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_convo(ref, index, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_convo, [index], opts)
    end

    @spec infer_provider(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, Dspy.Clients.ProviderClass.t()} | {:error, Snakepit.Error.t()}
    def infer_provider(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :infer_provider, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec kill(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :kill, [] ++ List.wrap(args), opts)
    end

    @spec launch(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :launch, [] ++ List.wrap(args), opts)
    end

    @spec reinforce(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, Dspy.Clients.Provider.ReinforceJob.t()} | {:error, Snakepit.Error.t()}
    def reinforce(ref, train_kwargs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reinforce, [train_kwargs], opts)
    end

    @spec update_history(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_history(ref, entry, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_history, [entry], opts)
    end
  end

  defmodule Utils.DummyVectorizer do
    def __snakebridge_python_name__, do: "dspy.utils"
    def __snakebridge_python_class__, do: "DummyVectorizer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _hash(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _hash(ref, gram, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_hash, [gram], opts)
    end
  end

  defmodule Utils.Exceptions.AdapterParseError do
    def __snakebridge_python_name__, do: "dspy.utils.exceptions"
    def __snakebridge_python_class__, do: "AdapterParseError"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(
            String.t(),
            Dspy.Signatures.Signature.Signature.t(),
            String.t(),
            list(term()),
            keyword()
          ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(adapter_name, signature, lm_response, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [adapter_name, signature, lm_response] ++ List.wrap(args),
        opts
      )
    end

    @spec add_note(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec add_note(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def add_note(ref) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [], [])
    end

    def add_note(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [], opts)
    end

    def add_note(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], [])
    end

    def add_note(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], opts)
    end

    def add_note(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], [])
    end

    def add_note(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], opts)
    end

    def add_note(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], [])
    end

    def add_note(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], [])
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :add_note,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec with_traceback(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    @spec with_traceback(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            term(),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_traceback(ref) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [], [])
    end

    def with_traceback(ref, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [], opts)
    end

    def with_traceback(ref, arg1) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], [])
    end

    def with_traceback(ref, arg1, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], opts)
    end

    def with_traceback(ref, arg1, arg2) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], [])
    end

    def with_traceback(ref, arg1, arg2, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], [])
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], opts)
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6],
        opts
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
        opts
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        []
      )
    end

    def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
        when is_list(opts) and
               (opts == [] or
                  (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
      SnakeBridge.Runtime.call_method(
        ref,
        :with_traceback,
        [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
        opts
      )
    end

    @spec args(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def args(ref) do
      SnakeBridge.Runtime.get_attr(ref, :args)
    end
  end

  defmodule Utils.Hasher do
    def __snakebridge_python_name__, do: "dspy.utils.hasher"
    def __snakebridge_python_class__, do: "Hasher"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec hash(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def hash(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :hash, [value], opts)
    end

    @spec hash_bytes(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def hash_bytes(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :hash_bytes, [value], opts)
    end

    @spec hexdigest(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def hexdigest(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :hexdigest, [], opts)
    end

    @spec update(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def update(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update, [value], opts)
    end

    @spec dispatch(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dispatch(ref) do
      SnakeBridge.Runtime.get_attr(ref, :dispatch)
    end
  end

  defmodule Utils.LoggingUtils.DSPyLoggingStream do
    def __snakebridge_python_name__, do: "dspy.utils.logging_utils"
    def __snakebridge_python_class__, do: "DSPyLoggingStream"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec flush(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def flush(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :flush, [], opts)
    end

    @spec write(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def write(ref, text, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :write, [text], opts)
    end

    @spec enabled(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def enabled(ref) do
      SnakeBridge.Runtime.get_attr(ref, :enabled)
    end
  end

  defmodule Utils.Parallelizer.ParallelExecutor do
    def __snakebridge_python_name__, do: "dspy.utils.parallelizer"
    def __snakebridge_python_class__, do: "ParallelExecutor"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _execute_parallel(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _execute_parallel(ref, function, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_execute_parallel, [function, data], opts)
    end

    @spec _update_progress(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _update_progress(ref, pbar, nresults, ntotal, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_update_progress, [pbar, nresults, ntotal], opts)
    end

    @spec _wrap_function(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _wrap_function(ref, user_function, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_wrap_function, [user_function], opts)
    end

    @spec execute(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def execute(ref, function, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :execute, [function, data], opts)
    end
  end

  defmodule Utils.StatusMessage do
    def __snakebridge_python_name__, do: "dspy.utils"
    def __snakebridge_python_class__, do: "StatusMessage"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t(), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(message, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [message], opts)
    end
  end

  defmodule Utils.StatusMessageProvider do
    def __snakebridge_python_name__, do: "dspy.utils"
    def __snakebridge_python_class__, do: "StatusMessageProvider"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec lm_end_status_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def lm_end_status_message(ref, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :lm_end_status_message, [outputs], opts)
    end

    @spec lm_start_status_message(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lm_start_status_message(ref, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :lm_start_status_message, [instance, inputs], opts)
    end

    @spec module_end_status_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def module_end_status_message(ref, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :module_end_status_message, [outputs], opts)
    end

    @spec module_start_status_message(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def module_start_status_message(ref, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :module_start_status_message, [instance, inputs], opts)
    end

    @spec tool_end_status_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def tool_end_status_message(ref, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :tool_end_status_message, [outputs], opts)
    end

    @spec tool_start_status_message(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def tool_start_status_message(ref, instance, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :tool_start_status_message, [instance, inputs], opts)
    end
  end

  defmodule Utils.Unbatchify do
    def __snakebridge_python_name__, do: "dspy.utils.unbatchify"
    def __snakebridge_python_class__, do: "Unbatchify"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(batch_fn, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [batch_fn] ++ List.wrap(args), opts)
    end

    @spec _worker(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _worker(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_worker, [], opts)
    end

    @spec close(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def close(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :close, [], opts)
    end
  end

  defmodule Utils.UsageTrackerClass3 do
    def __snakebridge_python_name__, do: "dspy.utils.usage_tracker"
    def __snakebridge_python_class__, do: "UsageTracker"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec _flatten_usage_entry(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def _flatten_usage_entry(ref, usage_entry, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_flatten_usage_entry, [usage_entry], opts)
    end

    @spec _merge_usage_entries(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def _merge_usage_entries(ref, usage_entry1, usage_entry2, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_merge_usage_entries,
        [usage_entry1, usage_entry2],
        opts
      )
    end

    @spec add_usage(SnakeBridge.Ref.t(), String.t(), %{optional(String.t()) => term()}, keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def add_usage(ref, lm, usage_entry, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :add_usage, [lm, usage_entry], opts)
    end

    @spec get_total_tokens(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => %{optional(String.t()) => term()}}}
            | {:error, Snakepit.Error.t()}
    def get_total_tokens(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_total_tokens, [], opts)
    end
  end

  defmodule XMLAdapter do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "XMLAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _call_postprocess(
            SnakeBridge.Ref.t(),
            term(),
            term(),
            list(term()),
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def _call_postprocess(
          ref,
          processed_signature,
          original_signature,
          outputs,
          lm,
          lm_kwargs,
          opts \\ []
        ) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_postprocess,
        [processed_signature, original_signature, outputs, lm, lm_kwargs],
        opts
      )
    end

    @spec _call_preprocess(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            term(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_call_preprocess,
        [lm, lm_kwargs, signature, inputs],
        opts
      )
    end

    @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_history_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
    end

    @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
    end

    @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
    end

    @spec _parse_field_value(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_field_value(ref, field_info, raw, completion, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :_parse_field_value,
        [field_info, raw, completion, signature],
        opts
      )
    end

    @spec acall(
            SnakeBridge.Ref.t(),
            Dspy.Clients.LMClass.t(),
            %{optional(String.t()) => term()},
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :acall,
        [lm, lm_kwargs, signature, demos, inputs],
        opts
      )
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_assistant_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_assistant_message_content,
        [signature, outputs] ++ List.wrap(args),
        opts
      )
    end

    @spec format_conversation_history(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_conversation_history,
        [signature, history_field_name, inputs],
        opts
      )
    end

    @spec format_demos(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format_demos(ref, signature, demos, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
    end

    @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
    end

    @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_structure(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
    end

    @spec format_field_with_value(
            SnakeBridge.Ref.t(),
            %{optional(Dspy.Adapters.ChatAdapter.FieldInfoWithName.t()) => term()},
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_field_with_value(ref, fields_with_values, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_field_with_value, [fields_with_values], opts)
    end

    @spec format_finetune_data(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, %{optional(String.t()) => list(term())}} | {:error, Snakepit.Error.t()}
    def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_finetune_data,
        [signature, demos, inputs, outputs],
        opts
      )
    end

    @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_system_message(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
    end

    @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_task_description(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
    end

    @spec format_user_message_content(
            SnakeBridge.Ref.t(),
            term(),
            %{optional(String.t()) => term()},
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_user_message_content,
        [signature, inputs] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end

    @spec user_message_output_requirements(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def user_message_output_requirements(ref, signature, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :user_message_output_requirements, [signature], opts)
    end
  end

  @doc false
  def __functions__ do
    [
      {:colbertv2_post_request, 0, __MODULE__, ""},
      {:enable_logging, 0, __MODULE__,
       "Enables the `DSPyLoggingStream` used by event logging APIs throughout DSPy"},
      {:generate_instruction_class, 0, __MODULE__, ""},
      {:colbertv2_post_request_v2_wrapped, 0, __MODULE__, ""},
      {:has_answer, 2, __MODULE__, "Source: DPR Implementation from Facebook Research"},
      {:track_usage, 0, __MODULE__, "Context manager for tracking LM usage."},
      {:s_tokenizer, 0, __MODULE__, "Source: DPR Implementation from Facebook Research"},
      {:find_data_errors_completion, 1, __MODULE__, ""},
      {:normalize_text, 1, __MODULE__, "Normalize text for string and token comparisons."},
      {:answer_exact_match, 2, __MODULE__,
       "Evaluate exact match or F1-thresholded match for an example/prediction pair."},
      {:wrap_program, 2, __MODULE__, ""},
      {:ensure_signature, 1, __MODULE__, ""},
      {:create_directory, 1, __MODULE__, ""},
      {:alitellm_text_completion, 2, __MODULE__, ""},
      {:process_grouped_by_first_item, 1, __MODULE__,
       "Requires items in list to already be grouped by first item."},
      {:prepare_models_for_resampling, 2, __MODULE__, ""},
      {:assert_structural_equivalency, 2, __MODULE__, ""},
      {:bootstrap_trace_data, 2, __MODULE__, ""},
      {:load_batch_backgrounds, 2, __MODULE__, ""},
      {:streamify, 1, __MODULE__,
       "Wrap a DSPy program so that it streams its outputs incrementally, rather than returning them"},
      {:prepare_student, 1, __MODULE__, ""},
      {:find_data_error_chat_message, 1, __MODULE__, ""},
      {:dspy_cache, 0, __MODULE__, "DSPy Cache"},
      {:disable_litellm_logging, 0, __MODULE__, ""},
      {:disable_logging, 0, __MODULE__,
       "Disables the `DSPyLoggingStream` used by event logging APIs throughout DSPy"},
      {:default_normalize, 1, __MODULE__, ""},
      {:get_annotation_name, 1, __MODULE__, ""},
      {:locate_answers, 2, __MODULE__,
       "Returns each occurrence of an answer as (offset, endpos) in terms of *characters*."},
      {:f1, 2, __MODULE__, "Compute the maximum token-level F1 score against reference answers."},
      {:get_free_port, 0, __MODULE__, "Return a free TCP port on localhost."},
      {:merge_dicts, 2, __MODULE__, ""},
      {:get_signature, 1, __MODULE__, ""},
      {:encode_file_to_dict, 1, __MODULE__,
       "Encode various file inputs to a dict with file_data, file_id, and/or filename."},
      {:groupby_first_item, 1, __MODULE__, ""},
      {:append_a_rule, 2, __MODULE__, ""},
      {:dpr_normalize, 1, __MODULE__, ""},
      {:settings, 0, __MODULE__, "A singleton class for DSPy configuration settings."},
      {:int_or_float, 1, __MODULE__, ""},
      {:get_program_instruction_set_string, 1, __MODULE__, ""},
      {:create_n_fewshot_demo_sets, 7, __MODULE__,
       "This function is copied from random_search.py, and creates fewshot examples in the same way that random search does."},
      {:dpr_tokenize, 1, __MODULE__, "Source: DPR Implementation from Facebook Research"},
      {:configure_cache, 0, __MODULE__, "Configure the cache for DSPy."},
      {:pretty_print_history, 1, __MODULE__, "Prints the last n prompts and their completions."},
      {:run_async, 1, __MODULE__, "Run an async coroutine from a synchronous context."},
      {:streaming_response, 1, __MODULE__,
       "Convert a DSPy program output stream to an OpenAI-compatible output stream that can be"},
      {:batch, 2, __MODULE__, ""},
      {:print_message, 0, __MODULE__, ""},
      {:bootstrap_trace_data, 2, __MODULE__, ""},
      {:create_output_dir, 2, __MODULE__, ""},
      {:extract_answer, 1, __MODULE__, ""},
      {:timestamp, 0, __MODULE__, ""},
      {:colbertv2_post_request_v2, 3, __MODULE__, ""},
      {:timestamp, 0, __MODULE__, ""},
      {:enable_logging, 0, __MODULE__,
       "Enables the `DSPyLoggingStream` used by event logging APIs throughout DSPy"},
      {:convert_langchain_tool, 1, __MODULE__, "Build a DSPy tool from a LangChain tool."},
      {:save_candidate_program, 3, __MODULE__,
       "Save the candidate program to the log directory."},
      {:f1_score, 2, __MODULE__,
       "Compute token-level F1 between prediction and reference (after normalization)."},
      {:assert_no_shared_predictor, 2, __MODULE__, ""},
      {:save_data, 1, __MODULE__, ""},
      {:deduplicate, 1, __MODULE__, "From Raymond Hettinger"},
      {:colbertv2_get_request_v2, 3, __MODULE__, ""},
      {:single_query_passage, 1, __MODULE__, ""},
      {:parse_list_of_instructions, 1, __MODULE__, ""},
      {:strip_accents, 1, __MODULE__, "Strips accents from a piece of text."},
      {:create_subdir_in_cachedir, 1, __MODULE__,
       "Create a subdirectory in the DSPy cache directory."},
      {:request_cache, 0, __MODULE__,
       "Decorator for applying caching to a function based on the request argument."},
      {:zipstar, 1, __MODULE__, "A much faster A, B, C = zip(*[(a, b, c), (a, b, c), ...])"},
      {:truncate_cell, 1, __MODULE__, "Truncate content of a cell to 25 words."},
      {:lookup, 2, __MODULE__,
       "Like get but instead of returning the final value it returns the"},
      {:env_worker, 2, __MODULE__, "Worker process: creates a single AlfredTWEnv instance,"},
      {:em, 2, __MODULE__,
       "Compute the Exact Match (EM) metric between a prediction and reference answers."},
      {:grouper, 2, __MODULE__, "Collect data into fixed-length chunks or blocks"},
      {:set_attribute_by_name, 3, __MODULE__, ""},
      {:strip_accents, 1, __MODULE__, "Strips accents from a piece of text."},
      {:litellm_completion, 2, __MODULE__, ""},
      {:answer_passage_match, 2, __MODULE__,
       "Return True if any passage in `pred.context` contains the answer(s)."},
      {:configure, 0, __MODULE__, ""},
      {:set_signature, 2, __MODULE__, ""},
      {:with_callbacks, 1, __MODULE__,
       "Decorator to add callback functionality to instance methods."},
      {:print_full_program, 1, __MODULE__,
       "Print out the program's instructions & prefixes for each module."},
      {:get_dependency_versions, 0, __MODULE__, ""},
      {:get_unique_lms, 1, __MODULE__, ""},
      {:setup_logging, 1, __MODULE__,
       "Setup logger, which will log our print statements to a txt file at our log_dir for later viewing"},
      {:disable_lm_cache, 2, __MODULE__,
       "Disable the LM cache for all predictors in the program."},
      {:get_number_with_suffix, 1, __MODULE__, ""},
      {:get_limiter, 0, __MODULE__, ""},
      {:download, 1, __MODULE__, ""},
      {:eval_candidate_program_with_pruning, 6, __MODULE__,
       "Evaluation of candidate_program with pruning implemented"},
      {:majority, 1, __MODULE__,
       "Returns the most common completion for the target field (or the last field) in the signature."},
      {:get_dspy_source_code, 1, __MODULE__, ""},
      {:recursive_mask, 1, __MODULE__, ""},
      {:infer_prefix, 1, __MODULE__,
       "Infer a prefix from an attribute name by converting it to a human-readable format."},
      {:zip_first, 2, __MODULE__, ""},
      {:infer_data_format, 1, __MODULE__, ""},
      {:write_lines, 2, __MODULE__, ""},
      {:move_kwargs, 0, __MODULE__, ""},
      {:launch_lms, 1, __MODULE__, ""},
      {:asyncify, 1, __MODULE__,
       "Wraps a DSPy program so that it can be called asynchronously. This is useful for running a"},
      {:em, 2, __MODULE__,
       "Compute the Exact Match (EM) metric between a prediction and reference answers."},
      {:majority, 1, __MODULE__,
       "Returns the most common completion for the target field (or the last field) in the signature."},
      {:em_score, 2, __MODULE__, "Compute boolean exact match after normalization."},
      {:is_url, 1, __MODULE__, "Check if a string is a valid URL."},
      {:find_enum_member, 2, __MODULE__,
       "Finds the enum member corresponding to the specified identifier, which may be the"},
      {:get_token_usage, 1, __MODULE__,
       "Extract total input tokens and output tokens from a model's interaction history."},
      {:prediction_is_dictlike, 1, __MODULE__, ""},
      {:set, 3, __MODULE__,
       "A setattr that supports nested lookups on objects, dicts, lists, and"},
      {:infer_prefix, 1, __MODULE__,
       "Infer a prefix from an attribute name by converting it to a human-readable format."},
      {:deduplicate, 1, __MODULE__, "From Raymond Hettinger"},
      {:dummy_rm, 0, __MODULE__, ""},
      {:delete, 2, __MODULE__,
       "A delattr that supports deletion of a nested lookups on objects,"},
      {:with_callbacks, 1, __MODULE__,
       "Decorator to add callback functionality to instance methods."},
      {:get_task_model_history_for_full_example, 4, __MODULE__,
       "Get a full trace of the task model's history for a given candidate program."},
      {:flatten, 1, __MODULE__, ""},
      {:wait_for_server, 1, __MODULE__,
       "Wait for the server to be ready by polling the /v1/models endpoint."},
      {:get_finetune_directory, 0, __MODULE__, ""},
      {:answer_exact_match, 2, __MODULE__,
       "Evaluate exact match or F1-thresholded match for an example/prediction pair."},
      {:configure_dspy_loggers, 1, __MODULE__, ""},
      {:experimental, 0, __MODULE__,
       "Decorator / decorator creator for marking APIs experimental in the docstring."},
      {:format_field_value, 2, __MODULE__,
       "Formats the value of the specified field according to the field's DSPy type (input or output),"},
      {:streamify, 1, __MODULE__,
       "Wrap a DSPy program so that it streams its outputs incrementally, rather than returning them"},
      {:ensure_signature, 1, __MODULE__, ""},
      {:majority, 1, __MODULE__,
       "Returns the most common completion for the target field (or the last field) in the signature."},
      {:create_instruction_set_history_string, 3, __MODULE__, ""},
      {:get_number_with_suffix, 1, __MODULE__, ""},
      {:calculate_last_n_proposed_quality, 6, __MODULE__,
       "Calculate the average and best quality of the last n programs proposed. This is useful for seeing if our proposals"},
      {:make_signature, 1, __MODULE__,
       "Create a new Signature subclass with the specified fields and instructions."},
      {:create_predictor_level_history_string, 4, __MODULE__, ""},
      {:grouper, 2, __MODULE__, "Collect data into fixed-length chunks or blocks"},
      {:disable_litellm_logging, 0, __MODULE__, ""},
      {:inspect_history, 0, __MODULE__, "The global history shared across all LMs."},
      {:p, 0, __MODULE__, "Parameter specification variable."},
      {:output_field, 0, __MODULE__, ""},
      {:bootstrap_trace_data, 2, __MODULE__, ""},
      {:dpr_normalize, 1, __MODULE__, "Source: DPR Implementation from Facebook Research"},
      {:int_or_float, 1, __MODULE__, ""},
      {:r, 0, __MODULE__, "Type variable."},
      {:build_call_data_from_trace, 3, __MODULE__, ""},
      {:settings, 0, __MODULE__, "A singleton class for DSPy configuration settings."},
      {:recursive_mask, 1, __MODULE__, ""},
      {:encode_sft_example, 3, __MODULE__,
       "This function encodes a single example into a format that can be used for sft training."},
      {:split_message_content_for_custom_types, 1, __MODULE__,
       "Split user message content into a list of content blocks."},
      {:is_in_ipython_notebook_environment, 0, __MODULE__,
       "Check if the current environment is an IPython notebook environment."},
      {:encode_audio, 1, __MODULE__, "Encode audio to a dict with 'data' and 'audio_format'."},
      {:cache, 0, __MODULE__, "DSPy Cache"},
      {:find_predictor_for_stream_listeners, 2, __MODULE__,
       "Find the predictor for each stream listener."},
      {:create_dataset_summary, 3, __MODULE__, ""},
      {:zipstar, 1, __MODULE__, "A much faster A, B, C = zip(*[(a, b, c), (a, b, c), ...])"},
      {:f1_score, 2, __MODULE__, ""},
      {:output_field, 0, __MODULE__, ""},
      {:groupby_first_item, 1, __MODULE__, ""},
      {:alitellm_responses_completion, 2, __MODULE__, ""},
      {:hotpot_f1_score, 2, __MODULE__, "Compute HotPotQA-style token F1 with special labels."},
      {:create_directory, 1, __MODULE__, ""},
      {:has_answer, 2, __MODULE__, ""},
      {:create_minibatch, 1, __MODULE__, "Create a minibatch from the trainset."},
      {:display_dataframe, 1, __MODULE__,
       "Display the specified Pandas DataFrame in the console."},
      {:hot_pot_f1, 2, __MODULE__,
       "Compute the maximum HotPotQA-style F1 score against reference answers."},
      {:default_config, 0, __MODULE__, ""},
      {:track_usage, 0, __MODULE__, "Context manager for tracking LM usage."},
      {:load, 1, __MODULE__, "Load saved DSPy model."},
      {:file_tqdm, 1, __MODULE__, ""},
      {:load, 1, __MODULE__, "Load saved DSPy model."},
      {:syncify, 1, __MODULE__, "Convert an async DSPy module to a sync program."},
      {:display, 1, __MODULE__, "Display the specified Python object in the console."},
      {:configure_cache, 0, __MODULE__, "Configure the cache for DSPy."},
      {:dspy_logging_stream, 0, __MODULE__,
       "A Python stream for use with event logging APIs throughout DSPy (`eprint()`,"},
      {:colbertv2_get_request, 0, __MODULE__, ""},
      {:get_field_description_string, 1, __MODULE__, ""},
      {:zip_first, 2, __MODULE__, ""},
      {:lengths2offsets, 1, __MODULE__, ""},
      {:strip_prefix, 1, __MODULE__, ""},
      {:inspect_modules, 1, __MODULE__, ""},
      {:asyncify, 1, __MODULE__,
       "Wraps a DSPy program so that it can be called asynchronously. This is useful for running a"},
      {:translate_field_type, 2, __MODULE__, ""},
      {:configure_dspy_loggers, 1, __MODULE__, ""},
      {:kill_lms, 1, __MODULE__, ""},
      {:all_predictors_have_lms, 1, __MODULE__,
       "Return True if all predictors in the program have an LM set."},
      {:validate_data_format, 2, __MODULE__, ""},
      {:settings, 0, __MODULE__, "A singleton class for DSPy configuration settings."},
      {:normalize_text, 1, __MODULE__, "Normalize text for string and token comparisons."},
      {:load_settings, 1, __MODULE__, "Load the settings from a file using cloudpickle."},
      {:alitellm_completion, 2, __MODULE__, ""},
      {:dpr_tokenize, 1, __MODULE__, ""},
      {:sync_send_to_stream, 2, __MODULE__,
       "Send message to stream in a sync context, regardless of event loop state."},
      {:make_signature, 1, __MODULE__,
       "Create a new Signature subclass with the specified fields and instructions."},
      {:get, 2, __MODULE__,
       "A getattr that supports nested lookups on objects, dicts, lists, and"},
      {:inspect_modules, 1, __MODULE__, ""},
      {:configure_dataframe_for_ipython_notebook_display, 1, __MODULE__,
       "Set various pandas display options for DataFrame in an IPython notebook environment."},
      {:dummy_rm, 0, __MODULE__, ""},
      {:parse_value, 2, __MODULE__, ""},
      {:load_batch_backgrounds, 2, __MODULE__, ""},
      {:streamify, 1, __MODULE__,
       "Wrap a DSPy program so that it streams its outputs incrementally, rather than returning them"},
      {:litellm_text_completion, 2, __MODULE__, ""},
      {:print_message, 0, __MODULE__, ""},
      {:train_sft_locally, 3, __MODULE__, ""},
      {:append_a_demo, 1, __MODULE__, ""},
      {:order_input_keys_in_string, 1, __MODULE__, ""},
      {:old_getfile, 1, __MODULE__,
       "Work out which source or compiled file an object was defined in."},
      {:save_file_to_log_dir, 2, __MODULE__, ""},
      {:new_getfile, 1, __MODULE__, ""},
      {:input_field, 0, __MODULE__, ""},
      {:infer_prefix, 1, __MODULE__,
       "Infer a prefix from an attribute name by converting it to a human-readable format."},
      {:log_token_usage, 3, __MODULE__,
       "Extract total input and output tokens used by each model and log to trial_logs[trial_num][\"token_usage\"]."},
      {:serialize_for_json, 1, __MODULE__,
       "Formats the specified value so that it can be serialized as a JSON string."},
      {:batch, 2, __MODULE__, ""},
      {:inspect_history, 0, __MODULE__, "The global history shared across all LMs."},
      {:file_tqdm, 1, __MODULE__, ""},
      {:find_data_error_chat, 1, __MODULE__, ""},
      {:colbertv2_get_request_v2_wrapped, 0, __MODULE__, ""},
      {:locate_answers, 2, __MODULE__,
       "Returns each occurrence of an answer as (offset, endpos) in terms of *characters*."},
      {:disable_logging, 0, __MODULE__,
       "Disables the `DSPyLoggingStream` used by event logging APIs throughout DSPy"},
      {:enable_litellm_logging, 0, __MODULE__, ""},
      {:html, 1, __MODULE__, "Obtain the HTML representation of the specified string."},
      {:copy_program_with_lms, 1, __MODULE__, ""},
      {:eval_candidate_program, 4, __MODULE__,
       "Evaluate a candidate program on the trainset, using the specified batch size."},
      {:get_program_with_highest_avg_score, 2, __MODULE__,
       "Used as a helper function for bayesian + minibatching optimizers. Returns the program with the highest average score from the batches evaluated so far."},
      {:s_tokenizer, 0, __MODULE__, ""},
      {:new_to_old_field, 1, __MODULE__, ""},
      {:apply_sync_streaming, 1, __MODULE__,
       "Convert the async streaming generator to a sync generator."},
      {:streaming_response, 1, __MODULE__,
       "Convert a DSPy program output stream to an OpenAI-compatible output stream that can be"},
      {:get_dspy_field_type, 1, __MODULE__, ""},
      {:context, 0, __MODULE__,
       "Context manager for temporary configuration changes at the thread level."},
      {:is_image, 1, __MODULE__,
       "Check if the object is an image or a valid media file reference."},
      {:answer_passage_match, 2, __MODULE__,
       "Return True if any passage in `pred.context` contains the answer(s)."},
      {:lengths2offsets, 1, __MODULE__, ""},
      {:apply_sync_streaming, 1, __MODULE__,
       "Convert the async streaming generator to a sync generator."},
      {:convert_mcp_tool, 2, __MODULE__, "Build a DSPy tool from an MCP tool."},
      {:create_example_string, 2, __MODULE__, ""},
      {:get_async_max_workers, 0, __MODULE__, ""},
      {:process_grouped_by_first_item, 1, __MODULE__,
       "Requires items in list to already be grouped by first item."},
      {:ensure_signature, 1, __MODULE__, "Signature class for DSPy."},
      {:recover_lm_cache, 2, __MODULE__,
       "Recover the LM caches for all predictors in the program to their original state."},
      {:precision_score, 2, __MODULE__,
       "Compute token-level precision of prediction against reference (after normalization)."},
      {:encode_image, 1, __MODULE__, "Encode an image or file to a base64 data URI."},
      {:gsm8k_metric, 2, __MODULE__, ""},
      {:get_prompt_model, 1, __MODULE__, ""},
      {:serialize_object, 1, __MODULE__,
       "Recursively serialize a given object into a JSON-compatible format."},
      {:make_signature, 1, __MODULE__,
       "Create a new Signature subclass with the specified fields and instructions."},
      {:flatten, 1, __MODULE__, ""},
      {:convert_input_schema_to_tool_args, 1, __MODULE__,
       "Convert an input json schema to tool arguments compatible with DSPy Tool."},
      {:parse_integer_answer, 1, __MODULE__, ""},
      {:stylize_metric_name, 2, __MODULE__,
       "Stylize the cell contents of a pandas DataFrame corresponding to the specified metric name."},
      {:experimental, 0, __MODULE__,
       "Decorator / decorator creator for marking APIs experimental in the docstring."},
      {:main_thread_config, 0, __MODULE__, ""},
      {:syncify, 1, __MODULE__, "Convert an async DSPy module to a sync program."},
      {:litellm_responses_completion, 2, __MODULE__, ""},
      {:input_field, 0, __MODULE__, ""},
      {:enable_litellm_logging, 0, __MODULE__, ""},
      {:pretty_print_history, 1, __MODULE__, "Prints the last n prompts and their completions."},
      {:output_field, 0, __MODULE__, ""},
      {:input_field, 0, __MODULE__, ""},
      {:prepare_teacher, 1, __MODULE__, ""},
      {:inspect_history, 0, __MODULE__, "The global history shared across all LMs."}
    ]
  end

  @doc false
  def __classes__ do
    [
      {Dspy.Propose.ProposeBase.Proposer,
       "Helper class that provides a standard way to create an ABC using\ninheritance."},
      {Dspy.Evaluate.AutoEvaluation.AnswerGroundedness,
       "Estimate the groundedness of a system's responses, against real retrieved documents written by people.\nYou will first enumerate whatever non-trivial or check-worthy claims are made in the system response, and then\ndiscuss the extent to which some or all of them can be deduced from the retrieved context and basic commonsense."},
      {Dspy.Dsp.Utils.Dpr.Tokens, "A class to represent a list of tokenized text."},
      {Dspy.Prediction,
       "A prediction object that contains the output of a DSPy module.\n\nPrediction inherits from Example.\n\nTo allow feedback-augmented scores, Prediction supports comparison operations\n(<, >, <=, >=) for Predictions with a `score` field. The comparison operations\ncompare the 'score' values as floats. For equality comparison, Predictions are equal\nif their underlying data stores are equal (inherited from Example).\n\nArithmetic operations (+, /, etc.) are also supported for Predictions with a 'score'\nfield, operating on the score value."},
      {Dspy.Predict.RLMClass,
       "Experimental: This class may change or be removed in a future release without warning.\n\nRecursive Language Model module.\n\n    Uses a sandboxed REPL to let the LLM programmatically explore large contexts\n    through code execution. The LLM writes Python code to examine data, call\n    sub-LLMs for semantic analysis, and build up answers iteratively.\n\n    The default interpreter is PythonInterpreter (Deno/Pyodide/WASM), but you\n    can provide any CodeInterpreter implementation (e.g., MockInterpreter, or write a custom one using E2B or Modal).\n\n    Note: RLM instances are not thread-safe when using a custom interpreter.\n    Create separate RLM instances for concurrent use, or use the default\n    PythonInterpreter which creates a fresh instance per forward() call.\n\n    Example:\n        ```python\n        # Basic usage\n        rlm = dspy.RLM(\"context, query -> output\", max_iterations=10)\n        result = rlm(context=\"...very long text...\", query=\"What is the magic number?\")\n        print(result.output)\n        ```\n    "},
      {Dspy.Clients.BaseLMClass,
       "Base class for handling LLM calls.\n\nMost users can directly use the `dspy.LM` class, which is a subclass of `BaseLM`. Users can also implement their\nown subclasses of `BaseLM` to support custom LLM providers and inject custom logic. To do so, simply override the\n`forward` method and make sure the return format is identical to the\n[OpenAI response format](https://platform.openai.com/docs/api-reference/responses/object).\n\nExample:\n\n```python\nfrom openai import OpenAI\n\nimport dspy\n\n\nclass MyLM(dspy.BaseLM):\n    def forward(self, prompt, messages=None, **kwargs):\n        client = OpenAI()\n        return client.chat.completions.create(\n            model=self.model,\n            messages=messages or [{\"role\": \"user\", \"content\": prompt}],\n            **self.kwargs,\n        )\n\n\nlm = MyLM(model=\"gpt-4o-mini\")\ndspy.configure(lm=lm)\nprint(dspy.Predict(\"q->a\")(q=\"Why did the chicken cross the kitchen?\"))\n```"},
      {Dspy.Dsp.Utils.DotdictLax,
       "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)"},
      {Dspy.Teleprompt.Bettertogether.BetterTogether, ""},
      {Dspy.Evaluate.CompleteAndGrounded, ""},
      {Dspy.OldOutputField, "A more ergonomic datatype that infers prefix and desc if omitted."},
      {Dspy.Clients.Openai.OpenAIProvider, ""},
      {Dspy.Teleprompt.TelepromptOptuna.BootstrapFewShotWithOptuna, ""},
      {Dspy.Teleprompt.Gepa.GepaUtils.PredictorFeedbackFn,
       "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto[T](Protocol):\n        def meth(self) -> T:\n            ..."},
      {Dspy.BootstrapFewShotWithRandomSearch, ""},
      {Dspy.Adapters.Types.Audio.Audio,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Evaluate.Evaluate.EvaluationResult,
       "A class that represents the result of an evaluation.\nIt is a subclass of `dspy.Prediction` that contains the following fields\n\n- score: An float value (e.g., 67.30) representing the overall performance\n- results: a list of (example, prediction, score) tuples for each example in devset"},
      {Dspy.Primitives.ReplTypes.REPLHistory,
       "Container for REPL interaction history.\n\nImmutable: append() returns a new instance with the entry added."},
      {Dspy.Predict.CodeActClass,
       "CodeAct is a module that utilizes the Code Interpreter and predefined tools to solve the problem."},
      {Dspy.Predict.Parallel, ""},
      {Dspy.Streaming.StreamListener,
       "Class that listens to the stream to capture the streeaming of a specific output field of a predictor."},
      {Dspy.CodeInterpreter,
       "Protocol for code execution environments (interpreters).\n\nImplementations must provide:\n- start(): Initialize the interpreter (optional, can be lazy)\n- execute(): Run code and return results\n- shutdown(): Clean up resources\n\nThe interpreter maintains state across execute() calls within a session,\nallowing variables defined in one call to be used in subsequent calls.\n\nLifecycle:\n    1. Create instance (config only, no resources allocated)\n    2. start() - Initialize interpreter (explicit) or let execute() do it (lazy)\n    3. execute() - Run code (can be called many times)\n    4. shutdown() - Release resources\n\nExample implementations:\n    - LocalInterpreter: Deno/Pyodide WASM interpreter (local)\n    - MockInterpreter: Scriptable responses for testing\n\nPooling:\n    For interpreter pooling, call start() to pre-warm instances, then\n    distribute execute() calls across the pool."},
      {Dspy.BootstrapFewShot, ""},
      {Dspy.Datasets.Alfworld.AlfWorld, ""},
      {Dspy.Predict.Parameter, ""},
      {Dspy.Adapters.Types.Type,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Teleprompt.BootstrapTrace.TraceData,
       "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)"},
      {Dspy.Teleprompt.BootstrapFinetuneClass, ""},
      {Dspy.EvaluateClass,
       "DSPy Evaluate class.\n\nThis class is used to evaluate the performance of a DSPy program. Users need to provide a evaluation dataset and\na metric function in order to use this class. This class supports parallel evaluation on the provided dataset."},
      {Dspy.Propose.GroundedProposer.GroundedProposer,
       "Helper class that provides a standard way to create an ABC using\ninheritance."},
      {Dspy.Dsp.Utils.SettingsClass,
       "A singleton class for DSPy configuration settings.\nThread-safe global configuration.\n- 'configure' can be called by only one 'owner' thread (the first thread that calls it).\n- Other threads see the configured global values from 'main_thread_config'.\n- 'context' sets thread-local overrides. These overrides propagate to threads spawned\n  inside that context block, when (and only when!) using a ParallelExecutor that copies overrides.\n\n  1. Only one unique thread (which can be any thread!) can call dspy.configure.\n  2. It affects a global state, visible to all. As a result, user threads work, but they shouldn't be\n     mixed with concurrent changes to dspy.configure from the \"main\" thread.\n     (TODO: In the future, add warnings: if there are near-in-time user-thread reads followed by .configure calls.)\n  3. Any thread can use dspy.context. It propagates to child threads created with DSPy primitives: Parallel, asyncify, etc."},
      {Dspy.Teleprompt.BootstrapFewShot, ""},
      {Dspy.Clients.UtilsFinetune.Message,
       "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)"},
      {Dspy.Predict.CodeAct,
       "CodeAct is a module that utilizes the Code Interpreter and predefined tools to solve the problem."},
      {Dspy.Clients.TrainingJob, "Represents the result of an asynchronous computation."},
      {Dspy.Dsp.Colbertv2.ColBERTv2, "Wrapper for the ColBERTv2 Retrieval."},
      {Dspy.Teleprompt.Gepa.InstructionProposal.ToolProposer,
       "Proposer for optimizing tool-using module configurations.\n\nSupports two types of modules:\n- Tool modules (1 predictor): Optimizes predictor instruction and tool descriptions\n- ReAct modules (2 predictors): Jointly optimizes react instruction, extract instruction, and tool descriptions\n\nUses dynamic signature generation to create output fields for each tool and parameter,\nenabling the reflection LM to optimize all components cohesively based on execution feedback.\n\nThis joint optimization approach allows the LM to see how instructions and tool descriptions\nwork together, leading to more coherent improvements than optimizing each component separately."},
      {Dspy.Predict.BestOfNClass, ""},
      {Dspy.Primitives.ExampleClass,
       "A flexible data container for DSPy examples and training data.\n\nThe `Example` class is the standard data format used in DSPy evaluation and optimization.\n\nKey features:\n    - Dictionary-like access patterns (item access, iteration, etc.)\n    - Flexible initialization from dictionaries, other `Example` instances, or keyword arguments\n    - Input/output field separation for training data\n    - Serialization support for saving/loading `Example` instances\n    - Immutable operations that return new `Example` instances\n\nExamples:\n\n    Basic usage with keyword arguments:\n\n    ```python\n    import dspy\n\n    # Create an example with input and output fields\n    example = dspy.Example(\n        question=\"What is the capital of France?\",\n        answer=\"Paris\",\n    )\n    print(example.question)  # \"What is the capital of France?\"\n    print(example.answer)   # \"Paris\"\n    ```\n\n    Initialize from a dictionary:\n\n    ```python\n    data = {\"question\": \"What is 2+2?\", \"answer\": \"4\"}\n    example = dspy.Example(data)\n    print(example[\"question\"])  # \"What is 2+2?\"\n    ```\n\n    Copy from another Example:\n\n    ```python\n    original = dspy.Example(question=\"Hello\", answer=\"World\")\n    copy = dspy.Example(original)\n    print(copy.question)  # \"Hello\"\n    ```\n\n    Working with input/output separation:\n\n    ```python\n    # Mark which fields are inputs for training\n    example = dspy.Example(\n        question=\"What is the weather?\",\n        answer=\"It's sunny\",\n    ).with_inputs(\"question\")\n\n    # Get only input fields\n    inputs = example.inputs()\n    print(inputs.question)  # \"What is the weather?\"\n\n    # Get only output fields (labels)\n    labels = example.labels()\n    print(labels.answer)  # \"It's sunny\"\n    ```\n\n    Dictionary-like operations:\n\n    ```python\n    example = dspy.Example(name=\"Alice\", age=30)\n\n    # Check if key exists\n    if \"name\" in example:\n        print(\"Name field exists\")\n\n    # Get with default value\n    city = example.get(\"city\", \"Unknown\")\n    print(city)  # \"Unknown\"\n    ```"},
      {Dspy.Teleprompt.Gepa.InstructionProposal.GenerateImprovedToolModuleDescriptionsFromFeedback,
       "I provided an assistant with predictor instructions and tool descriptions,\nbut its performance needs improvement based on the examples_with_feedback below.\n\nYour task is to propose better predictor instructions, tool descriptions, and tool argument descriptions that address the issues shown in these examples.\nFocus on reinforcing patterns that clearly improve the assistant's performance on similar tasks, rather than rewriting everything from scratch unless necessary.\nThese components are progressively optimized - refine only what needs to change.\n\nAnalyze the examples_with_feedback to identify success and failure patterns, and write improved instructions and descriptions at their appropriate level of abstraction and/or specificity,\nso that each layer plays a clear, complementary role without unnecessary repetition or verbosity unless redundancy clearly helps the assistant's performance."},
      {Dspy.Embeddings, ""},
      {Dspy.Retrievers.Embeddings, ""},
      {Dspy.AvatarOptimizer, ""},
      {Dspy.Teleprompt.GEPA,
       "Experimental: This class may change or be removed in a future release without warning (introduced in v3.0.0).\n\n\nGEPA is an evolutionary optimizer, which uses reflection to evolve text components\nof complex systems. GEPA is proposed in the paper [GEPA: Reflective Prompt Evolution Can Outperform Reinforcement Learning](https://arxiv.org/abs/2507.19457).\nThe GEPA optimization engine is provided by the `gepa` package, available from [https://github.com/gepa-ai/gepa](https://github.com/gepa-ai/gepa).\n\nGEPA captures full traces of the DSPy module's execution, identifies the parts of the trace\ncorresponding to a specific predictor, and reflects on the behaviour of the predictor to\npropose a new instruction for the predictor. GEPA allows users to provide textual feedback\nto the optimizer, which is used to guide the evolution of the predictor. The textual feedback\ncan be provided at the granularity of individual predictors, or at the level of the entire system's\nexecution.\n\nTo provide feedback to the GEPA optimizer, implement a metric as follows:\n```\ndef metric(\n    gold: Example,\n    pred: Prediction,\n    trace: Optional[DSPyTrace] = None,\n    pred_name: Optional[str] = None,\n    pred_trace: Optional[DSPyTrace] = None,\n) -> float | ScoreWithFeedback:\n    \"\"\"\n    This function is called with the following arguments:\n    - gold: The gold example.\n    - pred: The predicted output.\n    - trace: Optional. The trace of the program's execution.\n    - pred_name: Optional. The name of the target predictor currently being optimized by GEPA, for which\n        the feedback is being requested.\n    - pred_trace: Optional. The trace of the target predictor's execution GEPA is seeking feedback for.\n\n    Note the `pred_name` and `pred_trace` arguments. During optimization, GEPA will call the metric to obtain\n    feedback for individual predictors being optimized. GEPA provides the name of the predictor in `pred_name`\n    and the sub-trace (of the trace) corresponding to the predictor in `pred_trace`.\n    If available at the predictor level, the metric should return {'score': float, 'feedback': str} corresponding\n    to the predictor.\n    If not available at the predictor level, the metric can also return a text feedback at the program level\n    (using just the gold, pred and trace).\n    If no feedback is returned, GEPA will use a simple text feedback consisting of just the score:\n    f\"This trajectory got a score of {score}.\"\n    \"\"\"\n    ...\n```\n\nGEPA can also be used as a batch inference-time search strategy, by passing `valset=trainset, track_stats=True, track_best_outputs=True`, and using the\n`detailed_results` attribute of the optimized program (returned by `compile`) to get the Pareto frontier of the batch. `optimized_program.detailed_results.best_outputs_valset` will contain the best outputs for each task in the batch.\n\nExample:\n```\ngepa = GEPA(metric=metric, track_stats=True)\nbatch_of_tasks = [dspy.Example(...) for task in tasks]\nnew_prog = gepa.compile(student, trainset=trainset, valset=batch_of_tasks)\npareto_frontier = new_prog.detailed_results.val_aggregate_scores\n# pareto_frontier is a list of scores, one for each task in the batch.\n```\n\nArgs:\n    metric: The metric function to use for feedback and evaluation.\n    auto: The auto budget to use for the run. Options: \"light\", \"medium\", \"heavy\".\n    max_full_evals: The maximum number of full evaluations to perform.\n    max_metric_calls: The maximum number of metric calls to perform.\n    reflection_minibatch_size: The number of examples to use for reflection in a single GEPA step. Default is 3.\n    candidate_selection_strategy: The strategy to use for candidate selection. Default is \"pareto\",\n        which stochastically selects candidates from the Pareto frontier of all validation scores.\n        Options: \"pareto\", \"current_best\".\n    reflection_lm: The language model to use for reflection. Required parameter. GEPA benefits from\n        a strong reflection model. Consider using `dspy.LM(model='gpt-5', temperature=1.0, max_tokens=32000)`\n        for optimal performance.\n    skip_perfect_score: Whether to skip examples with perfect scores during reflection. Default is True.\n    instruction_proposer: Optional custom instruction proposer implementing GEPA's ProposalFn protocol.\n        **Default: None (recommended for most users)** - Uses GEPA's proven instruction proposer from\n        the [GEPA library](https://github.com/gepa-ai/gepa), which implements the\n        [`ProposalFn`](https://github.com/gepa-ai/gepa/blob/main/src/gepa/core/adapter.py). This default\n        proposer is highly capable and was validated across diverse experiments reported in the GEPA\n        paper and tutorials.\n\n        See documentation on custom instruction proposers\n        [here](https://dspy.ai/api/optimizers/GEPA/GEPA_Advanced/#custom-instruction-proposers).\n\n        **Advanced Feature**: Only needed for specialized scenarios:\n        - **Multi-modal handling**: Processing dspy.Image inputs alongside textual information\n        - **Nuanced control over constraints**: Fine-grained control over instruction length, format,\n          and structural requirements beyond standard feedback mechanisms\n        - **Domain-specific knowledge injection**: Specialized terminology or context that cannot be\n          provided through feedback_func alone\n        - **Provider-specific prompting**: Optimizations for specific LLM providers (OpenAI, Anthropic)\n          with unique formatting preferences\n        - **Coupled component updates**: Coordinated updates of multiple components together rather\n          than independent optimization\n        - **External knowledge integration**: Runtime access to databases, APIs, or knowledge bases\n\n        The default proposer handles the vast majority of use cases effectively. Use\n        MultiModalInstructionProposer() from dspy.teleprompt.gepa.instruction_proposal for visual\n        content or implement custom ProposalFn for highly specialized requirements.\n\n        Note: When both instruction_proposer and reflection_lm are set, the instruction_proposer is called\n        in the reflection_lm context. However, reflection_lm is optional when using a custom instruction_proposer.\n        Custom instruction proposers can invoke their own LLMs if needed.\n    component_selector: Custom component selector implementing the [ReflectionComponentSelector](https://github.com/gepa-ai/gepa/blob/main/src/gepa/proposer/reflective_mutation/base.py) protocol,\n        or a string specifying a built-in selector strategy. Controls which components (predictors) are selected\n        for optimization at each iteration. Defaults to 'round_robin' strategy which cycles through components\n        one at a time. Available string options: 'round_robin' (cycles through components sequentially),\n        'all' (selects all components for simultaneous optimization). Custom selectors can implement strategies\n        using LLM-driven selection logic based on optimization state and trajectories.\n        See [gepa component selectors](https://github.com/gepa-ai/gepa/blob/main/src/gepa/strategies/component_selector.py)\n        for available built-in selectors and the ReflectionComponentSelector protocol for implementing custom selectors.\n    add_format_failure_as_feedback: Whether to add format failures as feedback. Default is False.\n    use_merge: Whether to use merge-based optimization. Default is True.\n    max_merge_invocations: The maximum number of merge invocations to perform. Default is 5.\n    num_threads: The number of threads to use for evaluation with `Evaluate`. Optional.\n    failure_score: The score to assign to failed examples. Default is 0.0.\n    perfect_score: The maximum score achievable by the metric. Default is 1.0. Used by GEPA\n        to determine if all examples in a minibatch are perfect.\n    log_dir: The directory to save the logs. GEPA saves elaborate logs, along with all candidate\n        programs, in this directory. Running G"},
      {Dspy.Predict.Avatar.Avatar.Avatar, ""},
      {Dspy.Streaming.StatusMessageProvider,
       "Provides customizable status message streaming for DSPy programs.\n\nThis class serves as a base for creating custom status message providers. Users can subclass\nand override its methods to define specific status messages for different stages of program execution,\neach method must return a string.\n\nExample:\n```python\nclass MyStatusMessageProvider(StatusMessageProvider):\n    def lm_start_status_message(self, instance, inputs):\n        return f\"Calling LM with inputs {inputs}...\"\n\n    def module_end_status_message(self, outputs):\n        return f\"Module finished with output: {outputs}!\"\n\nprogram = dspy.streamify(dspy.Predict(\"q->a\"), status_message_provider=MyStatusMessageProvider())\n```"},
      {Dspy.Evaluate.AutoEvaluation.DecompositionalSemanticRecallPrecision,
       "Compare a system's response to the ground truth to compute recall and precision of key ideas.\nYou will first enumerate key ideas in each response, discuss their overlap, and then report recall and precision."},
      {Dspy.GEPA,
       "Experimental: This class may change or be removed in a future release without warning (introduced in v3.0.0).\n\n\nGEPA is an evolutionary optimizer, which uses reflection to evolve text components\nof complex systems. GEPA is proposed in the paper [GEPA: Reflective Prompt Evolution Can Outperform Reinforcement Learning](https://arxiv.org/abs/2507.19457).\nThe GEPA optimization engine is provided by the `gepa` package, available from [https://github.com/gepa-ai/gepa](https://github.com/gepa-ai/gepa).\n\nGEPA captures full traces of the DSPy module's execution, identifies the parts of the trace\ncorresponding to a specific predictor, and reflects on the behaviour of the predictor to\npropose a new instruction for the predictor. GEPA allows users to provide textual feedback\nto the optimizer, which is used to guide the evolution of the predictor. The textual feedback\ncan be provided at the granularity of individual predictors, or at the level of the entire system's\nexecution.\n\nTo provide feedback to the GEPA optimizer, implement a metric as follows:\n```\ndef metric(\n    gold: Example,\n    pred: Prediction,\n    trace: Optional[DSPyTrace] = None,\n    pred_name: Optional[str] = None,\n    pred_trace: Optional[DSPyTrace] = None,\n) -> float | ScoreWithFeedback:\n    \"\"\"\n    This function is called with the following arguments:\n    - gold: The gold example.\n    - pred: The predicted output.\n    - trace: Optional. The trace of the program's execution.\n    - pred_name: Optional. The name of the target predictor currently being optimized by GEPA, for which\n        the feedback is being requested.\n    - pred_trace: Optional. The trace of the target predictor's execution GEPA is seeking feedback for.\n\n    Note the `pred_name` and `pred_trace` arguments. During optimization, GEPA will call the metric to obtain\n    feedback for individual predictors being optimized. GEPA provides the name of the predictor in `pred_name`\n    and the sub-trace (of the trace) corresponding to the predictor in `pred_trace`.\n    If available at the predictor level, the metric should return {'score': float, 'feedback': str} corresponding\n    to the predictor.\n    If not available at the predictor level, the metric can also return a text feedback at the program level\n    (using just the gold, pred and trace).\n    If no feedback is returned, GEPA will use a simple text feedback consisting of just the score:\n    f\"This trajectory got a score of {score}.\"\n    \"\"\"\n    ...\n```\n\nGEPA can also be used as a batch inference-time search strategy, by passing `valset=trainset, track_stats=True, track_best_outputs=True`, and using the\n`detailed_results` attribute of the optimized program (returned by `compile`) to get the Pareto frontier of the batch. `optimized_program.detailed_results.best_outputs_valset` will contain the best outputs for each task in the batch.\n\nExample:\n```\ngepa = GEPA(metric=metric, track_stats=True)\nbatch_of_tasks = [dspy.Example(...) for task in tasks]\nnew_prog = gepa.compile(student, trainset=trainset, valset=batch_of_tasks)\npareto_frontier = new_prog.detailed_results.val_aggregate_scores\n# pareto_frontier is a list of scores, one for each task in the batch.\n```\n\nArgs:\n    metric: The metric function to use for feedback and evaluation.\n    auto: The auto budget to use for the run. Options: \"light\", \"medium\", \"heavy\".\n    max_full_evals: The maximum number of full evaluations to perform.\n    max_metric_calls: The maximum number of metric calls to perform.\n    reflection_minibatch_size: The number of examples to use for reflection in a single GEPA step. Default is 3.\n    candidate_selection_strategy: The strategy to use for candidate selection. Default is \"pareto\",\n        which stochastically selects candidates from the Pareto frontier of all validation scores.\n        Options: \"pareto\", \"current_best\".\n    reflection_lm: The language model to use for reflection. Required parameter. GEPA benefits from\n        a strong reflection model. Consider using `dspy.LM(model='gpt-5', temperature=1.0, max_tokens=32000)`\n        for optimal performance.\n    skip_perfect_score: Whether to skip examples with perfect scores during reflection. Default is True.\n    instruction_proposer: Optional custom instruction proposer implementing GEPA's ProposalFn protocol.\n        **Default: None (recommended for most users)** - Uses GEPA's proven instruction proposer from\n        the [GEPA library](https://github.com/gepa-ai/gepa), which implements the\n        [`ProposalFn`](https://github.com/gepa-ai/gepa/blob/main/src/gepa/core/adapter.py). This default\n        proposer is highly capable and was validated across diverse experiments reported in the GEPA\n        paper and tutorials.\n\n        See documentation on custom instruction proposers\n        [here](https://dspy.ai/api/optimizers/GEPA/GEPA_Advanced/#custom-instruction-proposers).\n\n        **Advanced Feature**: Only needed for specialized scenarios:\n        - **Multi-modal handling**: Processing dspy.Image inputs alongside textual information\n        - **Nuanced control over constraints**: Fine-grained control over instruction length, format,\n          and structural requirements beyond standard feedback mechanisms\n        - **Domain-specific knowledge injection**: Specialized terminology or context that cannot be\n          provided through feedback_func alone\n        - **Provider-specific prompting**: Optimizations for specific LLM providers (OpenAI, Anthropic)\n          with unique formatting preferences\n        - **Coupled component updates**: Coordinated updates of multiple components together rather\n          than independent optimization\n        - **External knowledge integration**: Runtime access to databases, APIs, or knowledge bases\n\n        The default proposer handles the vast majority of use cases effectively. Use\n        MultiModalInstructionProposer() from dspy.teleprompt.gepa.instruction_proposal for visual\n        content or implement custom ProposalFn for highly specialized requirements.\n\n        Note: When both instruction_proposer and reflection_lm are set, the instruction_proposer is called\n        in the reflection_lm context. However, reflection_lm is optional when using a custom instruction_proposer.\n        Custom instruction proposers can invoke their own LLMs if needed.\n    component_selector: Custom component selector implementing the [ReflectionComponentSelector](https://github.com/gepa-ai/gepa/blob/main/src/gepa/proposer/reflective_mutation/base.py) protocol,\n        or a string specifying a built-in selector strategy. Controls which components (predictors) are selected\n        for optimization at each iteration. Defaults to 'round_robin' strategy which cycles through components\n        one at a time. Available string options: 'round_robin' (cycles through components sequentially),\n        'all' (selects all components for simultaneous optimization). Custom selectors can implement strategies\n        using LLM-driven selection logic based on optimization state and trajectories.\n        See [gepa component selectors](https://github.com/gepa-ai/gepa/blob/main/src/gepa/strategies/component_selector.py)\n        for available built-in selectors and the ReflectionComponentSelector protocol for implementing custom selectors.\n    add_format_failure_as_feedback: Whether to add format failures as feedback. Default is False.\n    use_merge: Whether to use merge-based optimization. Default is True.\n    max_merge_invocations: The maximum number of merge invocations to perform. Default is 5.\n    num_threads: The number of threads to use for evaluation with `Evaluate`. Optional.\n    failure_score: The score to assign to failed examples. Default is 0.0.\n    perfect_score: The maximum score achievable by the metric. Default is 1.0. Used by GEPA\n        to determine if all examples in a minibatch are perfect.\n    log_dir: The directory to save the logs. GEPA saves elaborate logs, along with all candidate\n        programs, in this directory. Running G"},
      {Dspy.Primitives.ModuleClass, ""},
      {Dspy.Adapters.Adapter,
       "Base Adapter class.\n\nThe Adapter serves as the interface layer between DSPy module/signature and Language Models (LMs). It handles the\ncomplete transformation pipeline from DSPy inputs to LM calls and back to structured outputs.\n\nKey responsibilities:\n    - Transform user inputs and signatures into properly formatted LM prompts, which also instructs the LM to format\n        the response in a specific format.\n    - Parse LM outputs into dictionaries matching the signature's output fields.\n    - Enable/disable native LM features (function calling, citations, etc.) based on configuration.\n    - Handle conversation history, few-shot examples, and custom type processing.\n\nThe adapter pattern allows DSPy to work with different LM interfaces while maintaining a consistent programming\nmodel for users."},
      {Dspy.Teleprompt.LabeledFewShot, ""},
      {Dspy.Streaming.Messages.StatusMessageProvider,
       "Provides customizable status message streaming for DSPy programs.\n\nThis class serves as a base for creating custom status message providers. Users can subclass\nand override its methods to define specific status messages for different stages of program execution,\neach method must return a string.\n\nExample:\n```python\nclass MyStatusMessageProvider(StatusMessageProvider):\n    def lm_start_status_message(self, instance, inputs):\n        return f\"Calling LM with inputs {inputs}...\"\n\n    def module_end_status_message(self, outputs):\n        return f\"Module finished with output: {outputs}!\"\n\nprogram = dspy.streamify(dspy.Predict(\"q->a\"), status_message_provider=MyStatusMessageProvider())\n```"},
      {Dspy.Predict.Avatar.Models.Tool,
       "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."},
      {Dspy.Signatures.OldInputField,
       "A more ergonomic datatype that infers prefix and desc if omitted."},
      {Dspy.Adapters.Types.Code,
       "Code type in DSPy.\n\nThis type is useful for code generation and code analysis.\n\nExample 1: dspy.Code as output type in code generation:\n\n```python\nimport dspy\n\ndspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\n\nclass CodeGeneration(dspy.Signature):\n    '''Generate python code to answer the question.'''\n\n    question: str = dspy.InputField(description=\"The question to answer\")\n    code: dspy.Code[\"java\"] = dspy.OutputField(description=\"The code to execute\")\n\n\npredict = dspy.Predict(CodeGeneration)\n\nresult = predict(question=\"Given an array, find if any of the two numbers sum up to 10\")\nprint(result.code)\n```\n\nExample 2: dspy.Code as input type in code analysis:\n\n```python\nimport dspy\nimport inspect\n\ndspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\nclass CodeAnalysis(dspy.Signature):\n    '''Analyze the time complexity of the function.'''\n\n    code: dspy.Code[\"python\"] = dspy.InputField(description=\"The function to analyze\")\n    result: str = dspy.OutputField(description=\"The time complexity of the function\")\n\n\npredict = dspy.Predict(CodeAnalysis)\n\n\ndef sleepsort(x):\n    import time\n\n    for i in x:\n        time.sleep(i)\n        print(i)\n\nresult = predict(code=inspect.getsource(sleepsort))\nprint(result.result)\n```"},
      {Dspy.Dsp.Utils.Tokenizer,
       "Base tokenizer class.\nTokenizers implement tokenize, which should return a Tokens class."},
      {Dspy.Module, ""},
      {Dspy.Adapters.Code,
       "Code type in DSPy.\n\nThis type is useful for code generation and code analysis.\n\nExample 1: dspy.Code as output type in code generation:\n\n```python\nimport dspy\n\ndspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\n\nclass CodeGeneration(dspy.Signature):\n    '''Generate python code to answer the question.'''\n\n    question: str = dspy.InputField(description=\"The question to answer\")\n    code: dspy.Code[\"java\"] = dspy.OutputField(description=\"The code to execute\")\n\n\npredict = dspy.Predict(CodeGeneration)\n\nresult = predict(question=\"Given an array, find if any of the two numbers sum up to 10\")\nprint(result.code)\n```\n\nExample 2: dspy.Code as input type in code analysis:\n\n```python\nimport dspy\nimport inspect\n\ndspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\nclass CodeAnalysis(dspy.Signature):\n    '''Analyze the time complexity of the function.'''\n\n    code: dspy.Code[\"python\"] = dspy.InputField(description=\"The function to analyze\")\n    result: str = dspy.OutputField(description=\"The time complexity of the function\")\n\n\npredict = dspy.Predict(CodeAnalysis)\n\n\ndef sleepsort(x):\n    import time\n\n    for i in x:\n        time.sleep(i)\n        print(i)\n\nresult = predict(code=inspect.getsource(sleepsort))\nprint(result.result)\n```"},
      {Dspy.Adapters.Reasoning,
       "Reasoning type in DSPy.\n\nThis type is useful when you want the DSPy output to include the reasoning of the LM. We build this type so that\nDSPy can support the reasoning model and non-reasoning model with the same code.\n\nThis is a str-like type, you can convert a string directly to a Reasoning object, and from DSPy adapters'\nperspective, `Reasoning` is treated as a string."},
      {Dspy.ColBERTv2, "Wrapper for the ColBERTv2 Retrieval."},
      {Dspy.Dsp.Utils.SimpleTokenizer,
       "Base tokenizer class.\nTokenizers implement tokenize, which should return a Tokens class."},
      {Dspy.Datasets.Dataset, ""},
      {Dspy.Primitives.BaseModuleClass, ""},
      {Dspy.Primitives.PythonInterpreter,
       "Local interpreter for secure Python execution using Deno and Pyodide.\n\nImplements the Interpreter protocol for secure code execution in a\nWASM-based sandbox. Code runs in an isolated Pyodide environment with\nno access to the host filesystem, network, or environment by default.\n\nPrerequisites:\n    Deno must be installed: https://docs.deno.com/runtime/getting_started/installation/\n\nExample:\n    ```python\n    # Basic execution\n    with PythonInterpreter() as interp:\n        result = interp(\"print(1 + 2)\")  # Returns \"3\"\n\n    # With host-side tools\n    def my_tool(question: str) -> str:\n        return \"answer\"\n\n    with PythonInterpreter(tools={\"my_tool\": my_tool}) as interp:\n        result = interp(\"print(my_tool(question='test'))\")\n    ```"},
      {Dspy.Predict.ParallelClass, ""},
      {Dspy.Adapters.Types.CodeClass,
       "Code type in DSPy.\n\nThis type is useful for code generation and code analysis.\n\nExample 1: dspy.Code as output type in code generation:\n\n```python\nimport dspy\n\ndspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\n\nclass CodeGeneration(dspy.Signature):\n    '''Generate python code to answer the question.'''\n\n    question: str = dspy.InputField(description=\"The question to answer\")\n    code: dspy.Code[\"java\"] = dspy.OutputField(description=\"The code to execute\")\n\n\npredict = dspy.Predict(CodeGeneration)\n\nresult = predict(question=\"Given an array, find if any of the two numbers sum up to 10\")\nprint(result.code)\n```\n\nExample 2: dspy.Code as input type in code analysis:\n\n```python\nimport dspy\nimport inspect\n\ndspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\nclass CodeAnalysis(dspy.Signature):\n    '''Analyze the time complexity of the function.'''\n\n    code: dspy.Code[\"python\"] = dspy.InputField(description=\"The function to analyze\")\n    result: str = dspy.OutputField(description=\"The time complexity of the function\")\n\n\npredict = dspy.Predict(CodeAnalysis)\n\n\ndef sleepsort(x):\n    import time\n\n    for i in x:\n        time.sleep(i)\n        print(i)\n\nresult = predict(code=inspect.getsource(sleepsort))\nprint(result.result)\n```"},
      {Dspy.Adapters.Types.ImageClass,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Predict.Avatar.Signatures.Actor,
       "You will be given `Tools` which will be a list of tools to use to accomplish the `Goal`. Given the user query, your task is to decide which tool to use and what input values to provide.\n\nYou will output action needed to accomplish the `Goal`. `Action` should have a tool to use and the input query to pass to the tool.\n\nNote: You can opt to use no tools and provide the final answer directly. You can also one tool multiple times with different input queries if applicable."},
      {Dspy.LM,
       "A language model supporting chat or text completion requests for use with DSPy modules."},
      {Dspy.Propose.GroundedProposer.DescribeProgram,
       "Below is some pseudo-code for a pipeline that solves tasks with calls to language models. Please describe what type of task this program appears to be designed to solve, and how it appears to work."},
      {Dspy.Evaluate.SemanticF1, ""},
      {Dspy.Signatures.Field.OldOutputField,
       "A more ergonomic datatype that infers prefix and desc if omitted."},
      {Dspy.Streaming.StatusMessage,
       "Dataclass that wraps a status message for status streaming."},
      {Dspy.Utils.Unbatchify, ""},
      {Dspy.Primitives.PredictionClass,
       "A prediction object that contains the output of a DSPy module.\n\nPrediction inherits from Example.\n\nTo allow feedback-augmented scores, Prediction supports comparison operations\n(<, >, <=, >=) for Predictions with a `score` field. The comparison operations\ncompare the 'score' values as floats. For equality comparison, Predictions are equal\nif their underlying data stores are equal (inherited from Example).\n\nArithmetic operations (+, /, etc.) are also supported for Predictions with a 'score'\nfield, operating on the score value."},
      {Dspy.Dsp.Utils.Dpr.Tokenizer,
       "Base tokenizer class.\nTokenizers implement tokenize, which should return a Tokens class."},
      {Dspy.InferRules, ""},
      {Dspy.Dsp.Utils.Utils.Dotdict,
       "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)"},
      {Dspy.Primitives.PythonInterpreter.FinalOutput,
       "Returned by interpreter.execute() when SUBMIT() is called.\n\nThis signals that the code execution loop should terminate and return\nthe contained output to the caller."},
      {Dspy.Utils.StatusMessageProvider,
       "Provides customizable status message streaming for DSPy programs.\n\nThis class serves as a base for creating custom status message providers. Users can subclass\nand override its methods to define specific status messages for different stages of program execution,\neach method must return a string.\n\nExample:\n```python\nclass MyStatusMessageProvider(StatusMessageProvider):\n    def lm_start_status_message(self, instance, inputs):\n        return f\"Calling LM with inputs {inputs}...\"\n\n    def module_end_status_message(self, outputs):\n        return f\"Module finished with output: {outputs}!\"\n\nprogram = dspy.streamify(dspy.Predict(\"q->a\"), status_message_provider=MyStatusMessageProvider())\n```"},
      {Dspy.TwoStepAdapter,
       "A two-stage adapter that:\n    1. Uses a simpler, more natural prompt for the main LM\n    2. Uses a smaller LM with chat adapter to extract structured data from the response of main LM\nThis adapter uses a common __call__ logic defined in base Adapter class.\nThis class is particularly useful when interacting with reasoning models as the main LM since reasoning models\nare known to struggle with structured outputs.\n\nExample:\n```\nimport dspy\nlm = dspy.LM(model=\"openai/o3-mini\", max_tokens=16000, temperature = 1.0)\nadapter = dspy.TwoStepAdapter(dspy.LM(\"openai/gpt-4o-mini\"))\ndspy.configure(lm=lm, adapter=adapter)\nprogram = dspy.ChainOfThought(\"question->answer\")\nresult = program(\"What is the capital of France?\")\nprint(result)\n```"},
      {Dspy.Datasets.Colors, ""},
      {Dspy.BestOfN, ""},
      {Dspy.Teleprompt.BootstrapFinetune.FinetuneTeleprompter, ""},
      {Dspy.Clients.Provider, ""},
      {Dspy.Clients.Embedding.Embedder,
       "DSPy embedding class.\n\nThe class for computing embeddings for text inputs. This class provides a unified interface for both:\n\n1. Hosted embedding models (e.g. OpenAI's text-embedding-3-small) via litellm integration\n2. Custom embedding functions that you provide\n\nFor hosted models, simply pass the model name as a string (e.g., \"openai/text-embedding-3-small\"). The class will use\nlitellm to handle the API calls and caching.\n\nFor custom embedding models, pass a callable function that:\n- Takes a list of strings as input.\n- Returns embeddings as either:\n    - A 2D numpy array of float32 values\n    - A 2D list of float32 values\n- Each row should represent one embedding vector\n\nArgs:\n    model: The embedding model to use. This can be either a string (representing the name of the hosted embedding\n        model, must be an embedding model supported by litellm) or a callable that represents a custom embedding\n        model.\n    batch_size (int, optional): The default batch size for processing inputs in batches. Defaults to 200.\n    caching (bool, optional): Whether to cache the embedding response when using a hosted model. Defaults to True.\n    **kwargs: Additional default keyword arguments to pass to the embedding model.\n\nExamples:\n    Example 1: Using a hosted model.\n\n    ```python\n    import dspy\n\n    embedder = dspy.Embedder(\"openai/text-embedding-3-small\", batch_size=100)\n    embeddings = embedder([\"hello\", \"world\"])\n\n    assert embeddings.shape == (2, 1536)\n    ```\n\n    Example 2: Using any local embedding model, e.g. from https://huggingface.co/models?library=sentence-transformers.\n\n    ```python\n    # pip install sentence_transformers\n    import dspy\n    from sentence_transformers import SentenceTransformer\n\n    # Load an extremely efficient local model for retrieval\n    model = SentenceTransformer(\"sentence-transformers/static-retrieval-mrl-en-v1\", device=\"cpu\")\n\n    embedder = dspy.Embedder(model.encode)\n    embeddings = embedder([\"hello\", \"world\"], batch_size=1)\n\n    assert embeddings.shape == (2, 1024)\n    ```\n\n    Example 3: Using a custom function.\n\n    ```python\n    import dspy\n    import numpy as np\n\n    def my_embedder(texts):\n        return np.random.rand(len(texts), 10)\n\n    embedder = dspy.Embedder(my_embedder)\n    embeddings = embedder([\"hello\", \"world\"], batch_size=1)\n\n    assert embeddings.shape == (2, 10)\n    ```"},
      {Dspy.Reasoning,
       "Reasoning type in DSPy.\n\nThis type is useful when you want the DSPy output to include the reasoning of the LM. We build this type so that\nDSPy can support the reasoning model and non-reasoning model with the same code.\n\nThis is a str-like type, you can convert a string directly to a Reasoning object, and from DSPy adapters'\nperspective, `Reasoning` is treated as a string."},
      {Dspy.Teleprompt.SignatureOpt.SignatureOptimizer, ""},
      {Dspy.Adapter,
       "Base Adapter class.\n\nThe Adapter serves as the interface layer between DSPy module/signature and Language Models (LMs). It handles the\ncomplete transformation pipeline from DSPy inputs to LM calls and back to structured outputs.\n\nKey responsibilities:\n    - Transform user inputs and signatures into properly formatted LM prompts, which also instructs the LM to format\n        the response in a specific format.\n    - Parse LM outputs into dictionaries matching the signature's output fields.\n    - Enable/disable native LM features (function calling, citations, etc.) based on configuration.\n    - Handle conversation history, few-shot examples, and custom type processing.\n\nThe adapter pattern allows DSPy to work with different LM interfaces while maintaining a consistent programming\nmodel for users."},
      {Dspy.ChainOfThought, ""},
      {Dspy.Predict.Avatar.Actor,
       "You will be given `Tools` which will be a list of tools to use to accomplish the `Goal`. Given the user query, your task is to decide which tool to use and what input values to provide.\n\nYou will output action needed to accomplish the `Goal`. `Action` should have a tool to use and the input query to pass to the tool.\n\nNote: You can opt to use no tools and provide the final answer directly. You can also one tool multiple times with different input queries if applicable."},
      {Dspy.BaseModule, ""},
      {Dspy.MultiChainComparison, ""},
      {Dspy.PythonInterpreter,
       "Local interpreter for secure Python execution using Deno and Pyodide.\n\nImplements the Interpreter protocol for secure code execution in a\nWASM-based sandbox. Code runs in an isolated Pyodide environment with\nno access to the host filesystem, network, or environment by default.\n\nPrerequisites:\n    Deno must be installed: https://docs.deno.com/runtime/getting_started/installation/\n\nExample:\n    ```python\n    # Basic execution\n    with PythonInterpreter() as interp:\n        result = interp(\"print(1 + 2)\")  # Returns \"3\"\n\n    # With host-side tools\n    def my_tool(question: str) -> str:\n        return \"answer\"\n\n    with PythonInterpreter(tools={\"my_tool\": my_tool}) as interp:\n        result = interp(\"print(my_tool(question='test'))\")\n    ```"},
      {Dspy.Teleprompt.InferRulesClass, ""},
      {Dspy.Program, ""},
      {Dspy.Clients.ProviderClass, ""},
      {Dspy.Clients.UtilsFinetune.TrainDataFormat,
       "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'."},
      {Dspy.SIMBA,
       "SIMBA (Stochastic Introspective Mini-Batch Ascent) optimizer for DSPy.\n\nSIMBA is a DSPy optimizer that uses the LLM to analyze its own performance and \ngenerate improvement rules. It samples mini-batches, identifies challenging examples \nwith high output variability, then either creates self-reflective rules or adds \nsuccessful examples as demonstrations.\n\nFor more details, see: https://dspy.ai/api/optimizers/SIMBA/"},
      {Dspy.Experimental.Document,
       "Experimental: This class may change or be removed in a future release without warning (introduced in v3.0.4).\n\nA document type for providing content that can be cited by language models.\n\n    This type represents documents that can be passed to language models for citation-enabled\n    responses, particularly useful with Anthropic's Citations API. Documents include the content\n    and metadata that helps the LM understand and reference the source material.\n\n    Attributes:\n        data: The text content of the document\n        title: Optional title for the document (used in citations)\n        media_type: MIME type of the document content (defaults to \"text/plain\")\n        context: Optional context information about the document\n\n    Example:\n        ```python\n        import dspy\n        from dspy.signatures import Signature\n        from dspy.experimental import Document, Citations\n\n        class AnswerWithSources(Signature):\n            '''Answer questions using provided documents with citations.'''\n            documents: list[Document] = dspy.InputField()\n            question: str = dspy.InputField()\n            answer: str = dspy.OutputField()\n            citations: Citations = dspy.OutputField()\n\n        # Create documents\n        docs = [\n            Document(\n                data=\"The Earth orbits the Sun in an elliptical path.\",\n                title=\"Basic Astronomy Facts\"\n            ),\n            Document(\n                data=\"Water boils at 100C at standard atmospheric pressure.\",\n                title=\"Physics Fundamentals\",\n            )\n        ]\n\n        # Use with a citation-supporting model\n        lm = dspy.LM(\"anthropic/claude-opus-4-1-20250805\")\n        predictor = dspy.Predict(AnswerWithSources)\n        result = predictor(documents=docs, question=\"What temperature does water boil?\", lm=lm)\n        print(result.citations)\n        ```\n    "},
      {Dspy.Teleprompt.Bootstrap.BootstrapFewShot, ""},
      {Dspy.Adapters.Base.Adapter,
       "Base Adapter class.\n\nThe Adapter serves as the interface layer between DSPy module/signature and Language Models (LMs). It handles the\ncomplete transformation pipeline from DSPy inputs to LM calls and back to structured outputs.\n\nKey responsibilities:\n    - Transform user inputs and signatures into properly formatted LM prompts, which also instructs the LM to format\n        the response in a specific format.\n    - Parse LM outputs into dictionaries matching the signature's output fields.\n    - Enable/disable native LM features (function calling, citations, etc.) based on configuration.\n    - Handle conversation history, few-shot examples, and custom type processing.\n\nThe adapter pattern allows DSPy to work with different LM interfaces while maintaining a consistent programming\nmodel for users."},
      {Dspy.Predict.BestOfN, ""},
      {Dspy.Signatures.Signature.Signature,
       "Signature class for DSPy.\n\nYou typically subclass the Signature class, like this:\n    class MySignature(dspy.Signature):\n        input: str = InputField(desc=\"...\")\n        output: int = OutputField(desc=\"...\")\n\nYou can call Signature(\"input1, input2 -> output1, output2\") to create a new signature type.\nYou can also include instructions, Signature(\"input -> output\", \"This is a test\").\nBut it's generally better to use the make_signature function.\n\nIf you are not sure if your input is a string representation, (like \"input1, input2 -> output1, output2\"),\nor a signature, you can use the ensure_signature function.\n\nFor compatibility with the legacy dsp format, you can use the signature_to_template function."},
      {Dspy.Utils.DummyVectorizer, "Simple vectorizer based on n-grams."},
      {Dspy.Predict.Refine.OfferFeedback,
       "In the discussion, assign blame to each module that contributed to the final reward being below the threshold, if\nany. Then, prescribe concrete advice of how the module should act on its future input when we retry the process, if\nit were to receive the same or similar inputs. If a module is not to blame, the advice should be N/A.\nThe module will not see its own history, so it needs to rely on entirely concrete and actionable advice from you\nto avoid the same mistake on the same or similar inputs."},
      {Dspy.Clients.Databricks.TrainingJobDatabricks,
       "Represents the result of an asynchronous computation."},
      {Dspy.Teleprompt.AvatarOptimizerClass, ""},
      {Dspy.Datasets.ColorsClass, ""},
      {Dspy.Primitives.CodeInterpreter.FinalOutput,
       "Returned by interpreter.execute() when SUBMIT() is called.\n\nThis signals that the code execution loop should terminate and return\nthe contained output to the caller."},
      {Dspy.Utils.BaseCallback,
       "A base class for defining callback handlers for DSPy components.\n\nTo use a callback, subclass this class and implement the desired handlers. Each handler\nwill be called at the appropriate time before/after the execution of the corresponding component.  For example, if\nyou want to print a message before and after an LM is called, implement `the on_llm_start` and `on_lm_end` handler.\nUsers can set the callback globally using `dspy.configure` or locally by passing it to the component\nconstructor.\n\n\nExample 1: Set a global callback using `dspy.configure`.\n\n```\nimport dspy\nfrom dspy.utils.callback import BaseCallback\n\nclass LoggingCallback(BaseCallback):\n\n    def on_lm_start(self, call_id, instance, inputs):\n        print(f\"LM is called with inputs: {inputs}\")\n\n    def on_lm_end(self, call_id, outputs, exception):\n        print(f\"LM is finished with outputs: {outputs}\")\n\ndspy.configure(\n    callbacks=[LoggingCallback()]\n)\n\ncot = dspy.ChainOfThought(\"question -> answer\")\ncot(question=\"What is the meaning of life?\")\n\n# > LM is called with inputs: {'question': 'What is the meaning of life?'}\n# > LM is finished with outputs: {'answer': '42'}\n```\n\nExample 2: Set a local callback by passing it to the component constructor.\n\n```\nlm_1 = dspy.LM(\"gpt-3.5-turbo\", callbacks=[LoggingCallback()])\nlm_1(question=\"What is the meaning of life?\")\n\n# > LM is called with inputs: {'question': 'What is the meaning of life?'}\n# > LM is finished with outputs: {'answer': '42'}\n\nlm_2 = dspy.LM(\"gpt-3.5-turbo\")\nlm_2(question=\"What is the meaning of life?\")\n# No logging here because only `lm_1` has the callback set.\n```"},
      {Dspy.Teleprompt.AvatarOptimizer.EvalResult,
       "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."},
      {Dspy.Primitives.CodeInterpreterClass,
       "Protocol for code execution environments (interpreters).\n\nImplementations must provide:\n- start(): Initialize the interpreter (optional, can be lazy)\n- execute(): Run code and return results\n- shutdown(): Clean up resources\n\nThe interpreter maintains state across execute() calls within a session,\nallowing variables defined in one call to be used in subsequent calls.\n\nLifecycle:\n    1. Create instance (config only, no resources allocated)\n    2. start() - Initialize interpreter (explicit) or let execute() do it (lazy)\n    3. execute() - Run code (can be called many times)\n    4. shutdown() - Release resources\n\nExample implementations:\n    - LocalInterpreter: Deno/Pyodide WASM interpreter (local)\n    - MockInterpreter: Scriptable responses for testing\n\nPooling:\n    For interpreter pooling, call start() to pre-warm instances, then\n    distribute execute() calls across the pool."},
      {Dspy.Predict.React.ReAct, ""},
      {Dspy.Clients.BaseLM,
       "Base class for handling LLM calls.\n\nMost users can directly use the `dspy.LM` class, which is a subclass of `BaseLM`. Users can also implement their\nown subclasses of `BaseLM` to support custom LLM providers and inject custom logic. To do so, simply override the\n`forward` method and make sure the return format is identical to the\n[OpenAI response format](https://platform.openai.com/docs/api-reference/responses/object).\n\nExample:\n\n```python\nfrom openai import OpenAI\n\nimport dspy\n\n\nclass MyLM(dspy.BaseLM):\n    def forward(self, prompt, messages=None, **kwargs):\n        client = OpenAI()\n        return client.chat.completions.create(\n            model=self.model,\n            messages=messages or [{\"role\": \"user\", \"content\": prompt}],\n            **self.kwargs,\n        )\n\n\nlm = MyLM(model=\"gpt-4o-mini\")\ndspy.configure(lm=lm)\nprint(dspy.Predict(\"q->a\")(q=\"Why did the chicken cross the kitchen?\"))\n```"},
      {Dspy.Retrievers.Retrieve.Retrieve, ""},
      {Dspy.Predict.Tool,
       "Tool class.\n\nThis class is used to simplify the creation of tools for tool calling (function calling) in LLMs. Only supports\nfunctions for now."},
      {Dspy.Utils.UsageTrackerClass3, "Tracks LM usage data within a context."},
      {Dspy.Clients.Cache.Cache,
       "DSPy Cache\n\n`Cache` provides 2 levels of caching (in the given order):\n    1. In-memory cache - implemented with cachetools.LRUCache\n    2. On-disk cache - implemented with diskcache.FanoutCache"},
      {Dspy.Utils.Parallelizer.ParallelExecutor, ""},
      {Dspy.Adapters.ChatAdapterClass,
       "Default Adapter for most language models.\n\nThe ChatAdapter formats DSPy signatures into a format compatible with most language models.\nIt uses delimiter patterns like `[[ ## field_name ## ]]` to clearly separate input and output fields in\nthe message content.\n\nKey features:\n    - Structures inputs and outputs using field header markers for clear field delineation.\n    - Provides automatic fallback to JSONAdapter if the chat format fails."},
      {Dspy.Predict.Avatar.Action,
       "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."},
      {Dspy.Primitives.FinalOutput,
       "Returned by interpreter.execute() when SUBMIT() is called.\n\nThis signals that the code execution loop should terminate and return\nthe contained output to the caller."},
      {Dspy.Clients.UtilsFinetune.MessageAssistant,
       "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)"},
      {Dspy.Teleprompt.BootstrapFinetune.BootstrapFinetune, ""},
      {Dspy.Datasets.MATH, ""},
      {Dspy.Dsp.Utils.Dpr.SimpleTokenizer,
       "Base tokenizer class.\nTokenizers implement tokenize, which should return a Tokens class."},
      {Dspy.Predict.ChainOfThoughtClass, ""},
      {Dspy.Adapters.XMLAdapterClass,
       "Default Adapter for most language models.\n\nThe ChatAdapter formats DSPy signatures into a format compatible with most language models.\nIt uses delimiter patterns like `[[ ## field_name ## ]]` to clearly separate input and output fields in\nthe message content.\n\nKey features:\n    - Structures inputs and outputs using field header markers for clear field delineation.\n    - Provides automatic fallback to JSONAdapter if the chat format fails."},
      {Dspy.Adapters.Types.AudioClass,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Predict.Avatar.ActionOutput,
       "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."},
      {Dspy.Clients.Provider.ReinforceJob, ""},
      {Dspy.Adapters.Types.ToolCalls,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Propose.GroundedProposer.DescribeModule,
       "Below is some pseudo-code for a pipeline that solves tasks with calls to language models. Please describe the purpose of one of the specified module in this pipeline."},
      {Dspy.Propose.DatasetSummaryGenerator.DatasetDescriptor,
       "Given several examples from a dataset please write observations about trends that hold for most or all of the samples. Some areas you may consider in your observations: topics, content, syntax, conciseness, etc. It will be useful to make an educated guess as to the nature of the task this dataset will enable. Don't be afraid to be creative"},
      {Dspy.Signature, ""},
      {Dspy.BetterTogether, ""},
      {Dspy.Teleprompt.EnsembleClass, ""},
      {Dspy.Clients.Embedder,
       "DSPy embedding class.\n\nThe class for computing embeddings for text inputs. This class provides a unified interface for both:\n\n1. Hosted embedding models (e.g. OpenAI's text-embedding-3-small) via litellm integration\n2. Custom embedding functions that you provide\n\nFor hosted models, simply pass the model name as a string (e.g., \"openai/text-embedding-3-small\"). The class will use\nlitellm to handle the API calls and caching.\n\nFor custom embedding models, pass a callable function that:\n- Takes a list of strings as input.\n- Returns embeddings as either:\n    - A 2D numpy array of float32 values\n    - A 2D list of float32 values\n- Each row should represent one embedding vector\n\nArgs:\n    model: The embedding model to use. This can be either a string (representing the name of the hosted embedding\n        model, must be an embedding model supported by litellm) or a callable that represents a custom embedding\n        model.\n    batch_size (int, optional): The default batch size for processing inputs in batches. Defaults to 200.\n    caching (bool, optional): Whether to cache the embedding response when using a hosted model. Defaults to True.\n    **kwargs: Additional default keyword arguments to pass to the embedding model.\n\nExamples:\n    Example 1: Using a hosted model.\n\n    ```python\n    import dspy\n\n    embedder = dspy.Embedder(\"openai/text-embedding-3-small\", batch_size=100)\n    embeddings = embedder([\"hello\", \"world\"])\n\n    assert embeddings.shape == (2, 1536)\n    ```\n\n    Example 2: Using any local embedding model, e.g. from https://huggingface.co/models?library=sentence-transformers.\n\n    ```python\n    # pip install sentence_transformers\n    import dspy\n    from sentence_transformers import SentenceTransformer\n\n    # Load an extremely efficient local model for retrieval\n    model = SentenceTransformer(\"sentence-transformers/static-retrieval-mrl-en-v1\", device=\"cpu\")\n\n    embedder = dspy.Embedder(model.encode)\n    embeddings = embedder([\"hello\", \"world\"], batch_size=1)\n\n    assert embeddings.shape == (2, 1024)\n    ```\n\n    Example 3: Using a custom function.\n\n    ```python\n    import dspy\n    import numpy as np\n\n    def my_embedder(texts):\n        return np.random.rand(len(texts), 10)\n\n    embedder = dspy.Embedder(my_embedder)\n    embeddings = embedder([\"hello\", \"world\"], batch_size=1)\n\n    assert embeddings.shape == (2, 10)\n    ```"},
      {Dspy.Streaming.StreamingListener.StreamListener,
       "Class that listens to the stream to capture the streeaming of a specific output field of a predictor."},
      {Dspy.ProgramOfThought,
       "A DSPy module that runs Python programs to solve a problem.\nThis module requires deno to be installed. Please install deno following https://docs.deno.com/runtime/getting_started/installation/\n\nExample:\n```\nimport dspy\n\nlm = dspy.LM('openai/gpt-4o-mini')\ndspy.configure(lm=lm)\npot = dspy.ProgramOfThought(\"question -> answer\")\npot(question=\"what is 1+1?\")\n```"},
      {Dspy.Predict.Avatar.Models.ActionOutput,
       "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."},
      {Dspy.Predict.MultiChainComparison, ""},
      {Dspy.Signatures.SignatureClass, ""},
      {Dspy.Teleprompt.Teleprompt.Teleprompter, ""},
      {Dspy.Dsp.Utils.Utils.NullContextManager, ""},
      {Dspy.Predict.RLM,
       "Experimental: This class may change or be removed in a future release without warning.\n\nRecursive Language Model module.\n\n    Uses a sandboxed REPL to let the LLM programmatically explore large contexts\n    through code execution. The LLM writes Python code to examine data, call\n    sub-LLMs for semantic analysis, and build up answers iteratively.\n\n    The default interpreter is PythonInterpreter (Deno/Pyodide/WASM), but you\n    can provide any CodeInterpreter implementation (e.g., MockInterpreter, or write a custom one using E2B or Modal).\n\n    Note: RLM instances are not thread-safe when using a custom interpreter.\n    Create separate RLM instances for concurrent use, or use the default\n    PythonInterpreter which creates a fresh instance per forward() call.\n\n    Example:\n        ```python\n        # Basic usage\n        rlm = dspy.RLM(\"context, query -> output\", max_iterations=10)\n        result = rlm(context=\"...very long text...\", query=\"What is the magic number?\")\n        print(result.output)\n        ```\n    "},
      {Dspy.Adapters.Type,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Predict.Predict.Predict,
       "Basic DSPy module that maps inputs to outputs using a language model.\n\nArgs:\n    signature: The input/output signature describing the task.\n    callbacks: Optional list of callbacks for instrumentation.\n    **config: Default keyword arguments forwarded to the underlying\n        language model. These values can be overridden for a single\n        invocation by passing a ``config`` dictionary when calling the\n        module. For example::\n\n            predict = dspy.Predict(\"q -> a\", rollout_id=1, temperature=1.0)\n            predict(q=\"What is 1 + 52?\", config={\"rollout_id\": 2, \"temperature\": 1.0})"},
      {Dspy.Teleprompt.COPRO, ""},
      {Dspy.Adapters.Types.History,
       "Class representing the conversation history.\n\nThe conversation history is a list of messages, each message entity should have keys from the associated signature.\nFor example, if you have the following signature:\n\n```\nclass MySignature(dspy.Signature):\n    question: str = dspy.InputField()\n    history: dspy.History = dspy.InputField()\n    answer: str = dspy.OutputField()\n```\n\nThen the history should be a list of dictionaries with keys \"question\" and \"answer\".\n\nExample:\n    ```\n    import dspy\n\n    dspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\n    class MySignature(dspy.Signature):\n        question: str = dspy.InputField()\n        history: dspy.History = dspy.InputField()\n        answer: str = dspy.OutputField()\n\n    history = dspy.History(\n        messages=[\n            {\"question\": \"What is the capital of France?\", \"answer\": \"Paris\"},\n            {\"question\": \"What is the capital of Germany?\", \"answer\": \"Berlin\"},\n        ]\n    )\n\n    predict = dspy.Predict(MySignature)\n    outputs = predict(question=\"What is the capital of France?\", history=history)\n    ```\n\nExample of capturing the conversation history:\n    ```\n    import dspy\n\n    dspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\n    class MySignature(dspy.Signature):\n        question: str = dspy.InputField()\n        history: dspy.History = dspy.InputField()\n        answer: str = dspy.OutputField()\n\n    predict = dspy.Predict(MySignature)\n    outputs = predict(question=\"What is the capital of France?\")\n    history = dspy.History(messages=[{\"question\": \"What is the capital of France?\", **outputs}])\n    outputs_with_history = predict(question=\"Are you sure?\", history=history)\n    ```"},
      {Dspy.Adapters.Types.Citation.Citations,
       "Experimental: This class may change or be removed in a future release without warning (introduced in v3.0.4).\n\nCitations extracted from an LM response with source references.\n\n    This type represents citations returned by language models that support\n    citation extraction, particularly Anthropic's Citations API through LiteLLM.\n    Citations include the quoted text and source information.\n\n    Example:\n        ```python\n        import os\n        import dspy\n        from dspy.signatures import Signature\n        from dspy.experimental import Citations, Document\n        os.environ[\"ANTHROPIC_API_KEY\"] = \"YOUR_ANTHROPIC_API_KEY\"\n\n        class AnswerWithSources(Signature):\n            '''Answer questions using provided documents with citations.'''\n            documents: list[Document] = dspy.InputField()\n            question: str = dspy.InputField()\n            answer: str = dspy.OutputField()\n            citations: Citations = dspy.OutputField()\n\n        # Create documents to provide as sources\n        docs = [\n            Document(\n                data=\"The Earth orbits the Sun in an elliptical path.\",\n                title=\"Basic Astronomy Facts\"\n            ),\n            Document(\n                data=\"Water boils at 100C at standard atmospheric pressure.\",\n                title=\"Physics Fundamentals\",\n                metadata={\"author\": \"Dr. Smith\", \"year\": 2023}\n            )\n        ]\n\n        # Use with a model that supports citations like Claude\n        lm = dspy.LM(\"anthropic/claude-opus-4-1-20250805\")\n        predictor = dspy.Predict(AnswerWithSources)\n        result = predictor(documents=docs, question=\"What temperature does water boil?\", lm=lm)\n\n        for citation in result.citations.citations:\n            print(citation.format())\n        ```\n    "},
      {Dspy.Streaming.Messages.StreamResponse,
       "StreamResponse(predict_name: str, signature_field_name: str, chunk: str, is_last_chunk: bool)"},
      {Dspy.Signatures.Field.OldInputField,
       "A more ergonomic datatype that infers prefix and desc if omitted."},
      {Dspy.Adapters.Types.Tool.Tool,
       "Tool class.\n\nThis class is used to simplify the creation of tools for tool calling (function calling) in LLMs. Only supports\nfunctions for now."},
      {Dspy.Adapters.ToolCalls,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Adapters.Types.Tool.ToolCalls,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Primitives.CodeInterpreter.CodeInterpreterError,
       "Error raised during code execution in an interpreter.\n\nThis covers runtime errors, undefined variables, tool call failures, etc.\nSyntaxError is raised separately for invalid Python syntax."},
      {Dspy.Teleprompt.InferRules.RulesInductionProgram, ""},
      {Dspy.ToolCalls,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Datasets.Hotpotqa.HotPotQA, ""},
      {Dspy.BootstrapFewShotWithOptuna, ""},
      {Dspy.Teleprompt.Gepa.InstructionProposal.SingleComponentMultiModalProposer,
       "dspy.Module for proposing improved instructions based on feedback."},
      {Dspy.Primitives.ReplTypes.REPLVariable,
       "Metadata about a variable available in the REPL environment."},
      {Dspy.Adapters.JSONAdapter,
       "Default Adapter for most language models.\n\nThe ChatAdapter formats DSPy signatures into a format compatible with most language models.\nIt uses delimiter patterns like `[[ ## field_name ## ]]` to clearly separate input and output fields in\nthe message content.\n\nKey features:\n    - Structures inputs and outputs using field header markers for clear field delineation.\n    - Provides automatic fallback to JSONAdapter if the chat format fails."},
      {Dspy.Clients.Provider.TrainingJob,
       "Represents the result of an asynchronous computation."},
      {Dspy.Retrieve, ""},
      {Dspy.Predict.Avatar.Models.Action,
       "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."},
      {Dspy.Primitives.Prediction.Completions, ""},
      {Dspy.Retrievers.EmbeddingsClass, ""},
      {Dspy.Dsp.Colbertv2.ColBERTv2RerankerLocal, ""},
      {Dspy.Clients.UtilsFinetune.GRPOStatus,
       "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)"},
      {Dspy.Datasets.DatasetClass, ""},
      {Dspy.Type,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Primitives.Module.ProgramMeta,
       "Metaclass ensuring every ``dspy.Module`` instance is properly initialised."},
      {Dspy.Utils.StatusMessage, "Dataclass that wraps a status message for status streaming."},
      {Dspy.Clients.UtilsFinetune.GRPOGroup,
       "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)"},
      {Dspy.XMLAdapter,
       "Default Adapter for most language models.\n\nThe ChatAdapter formats DSPy signatures into a format compatible with most language models.\nIt uses delimiter patterns like `[[ ## field_name ## ]]` to clearly separate input and output fields in\nthe message content.\n\nKey features:\n    - Structures inputs and outputs using field header markers for clear field delineation.\n    - Provides automatic fallback to JSONAdapter if the chat format fails."},
      {Dspy.Datasets.Gsm8k.GSM8K, ""},
      {Dspy.Evaluate.AutoEvaluation.SemanticF1, ""},
      {Dspy.Utils.Exceptions.AdapterParseError,
       "Exception raised when adapter cannot parse the LM response."},
      {Dspy.Dsp.Utils.Tokens, "A class to represent a list of tokenized text."},
      {Dspy.Teleprompt.BootstrapFewShotWithRandomSearch, ""},
      {Dspy.Adapters.Audio,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Teleprompt.Gepa.InstructionProposal.GenerateEnhancedMultimodalInstructionFromFeedback,
       "I provided an assistant with instructions to perform a task involving visual content, but the assistant's performance needs improvement based on the examples and feedback below.\n\nYour task is to write a better instruction for the assistant that addresses the specific issues identified in the feedback, with particular attention to how visual and textual information should be analyzed and integrated.\n\n## Analysis Steps:\n1. **Read the inputs carefully** and identify both the visual and textual input formats, understanding how they work together\n2. **Read all the assistant responses and corresponding feedback** to understand what went wrong with visual analysis, text processing, or their integration\n3. **Identify visual analysis patterns** - what visual features, relationships, or details are important for this task\n4. **Identify domain-specific knowledge** about both visual and textual aspects, as this information may not be available to the assistant in the future\n5. **Look for successful visual-textual integration strategies** and include these patterns in the instruction\n6. **Address specific visual analysis issues** mentioned in the feedback\n\n## Instruction Requirements:\n- **Clear task definition** explaining how to process both visual and textual inputs\n- **Visual analysis guidance** specific to this task (what to look for, how to describe, what features matter)\n- **Integration strategies** for combining visual observations with textual information\n- **Domain-specific knowledge** about visual concepts, terminology, or relationships\n- **Error prevention guidance** for common visual analysis mistakes shown in the feedback\n- **Precise, actionable language** for both visual and textual processing\n\nFocus on creating an instruction that helps the assistant properly analyze visual content, integrate it with textual information, and avoid the specific visual analysis mistakes shown in the examples."},
      {Dspy.KNN, ""},
      {Dspy.Predict.PredictClass3,
       "Basic DSPy module that maps inputs to outputs using a language model.\n\nArgs:\n    signature: The input/output signature describing the task.\n    callbacks: Optional list of callbacks for instrumentation.\n    **config: Default keyword arguments forwarded to the underlying\n        language model. These values can be overridden for a single\n        invocation by passing a ``config`` dictionary when calling the\n        module. For example::\n\n            predict = dspy.Predict(\"q -> a\", rollout_id=1, temperature=1.0)\n            predict(q=\"What is 1 + 52?\", config={\"rollout_id\": 2, \"temperature\": 1.0})"},
      {Dspy.Teleprompt.Gepa.InstructionProposal.MultiModalInstructionProposer,
       "GEPA-compatible multimodal instruction proposer.\n\nThis class handles multimodal inputs (like dspy.Image) during GEPA optimization by using\na single-component proposer for each component that needs to be updated."},
      {Dspy.Embedder,
       "DSPy embedding class.\n\nThe class for computing embeddings for text inputs. This class provides a unified interface for both:\n\n1. Hosted embedding models (e.g. OpenAI's text-embedding-3-small) via litellm integration\n2. Custom embedding functions that you provide\n\nFor hosted models, simply pass the model name as a string (e.g., \"openai/text-embedding-3-small\"). The class will use\nlitellm to handle the API calls and caching.\n\nFor custom embedding models, pass a callable function that:\n- Takes a list of strings as input.\n- Returns embeddings as either:\n    - A 2D numpy array of float32 values\n    - A 2D list of float32 values\n- Each row should represent one embedding vector\n\nArgs:\n    model: The embedding model to use. This can be either a string (representing the name of the hosted embedding\n        model, must be an embedding model supported by litellm) or a callable that represents a custom embedding\n        model.\n    batch_size (int, optional): The default batch size for processing inputs in batches. Defaults to 200.\n    caching (bool, optional): Whether to cache the embedding response when using a hosted model. Defaults to True.\n    **kwargs: Additional default keyword arguments to pass to the embedding model.\n\nExamples:\n    Example 1: Using a hosted model.\n\n    ```python\n    import dspy\n\n    embedder = dspy.Embedder(\"openai/text-embedding-3-small\", batch_size=100)\n    embeddings = embedder([\"hello\", \"world\"])\n\n    assert embeddings.shape == (2, 1536)\n    ```\n\n    Example 2: Using any local embedding model, e.g. from https://huggingface.co/models?library=sentence-transformers.\n\n    ```python\n    # pip install sentence_transformers\n    import dspy\n    from sentence_transformers import SentenceTransformer\n\n    # Load an extremely efficient local model for retrieval\n    model = SentenceTransformer(\"sentence-transformers/static-retrieval-mrl-en-v1\", device=\"cpu\")\n\n    embedder = dspy.Embedder(model.encode)\n    embeddings = embedder([\"hello\", \"world\"], batch_size=1)\n\n    assert embeddings.shape == (2, 1024)\n    ```\n\n    Example 3: Using a custom function.\n\n    ```python\n    import dspy\n    import numpy as np\n\n    def my_embedder(texts):\n        return np.random.rand(len(texts), 10)\n\n    embedder = dspy.Embedder(my_embedder)\n    embeddings = embedder([\"hello\", \"world\"], batch_size=1)\n\n    assert embeddings.shape == (2, 10)\n    ```"},
      {Dspy.Tool,
       "Tool class.\n\nThis class is used to simplify the creation of tools for tool calling (function calling) in LLMs. Only supports\nfunctions for now."},
      {Dspy.Signatures.Field.OldField,
       "A more ergonomic datatype that infers prefix and desc if omitted."},
      {Dspy.Streaming.Messages.StatusStreamingCallback,
       "A base class for defining callback handlers for DSPy components.\n\nTo use a callback, subclass this class and implement the desired handlers. Each handler\nwill be called at the appropriate time before/after the execution of the corresponding component.  For example, if\nyou want to print a message before and after an LM is called, implement `the on_llm_start` and `on_lm_end` handler.\nUsers can set the callback globally using `dspy.configure` or locally by passing it to the component\nconstructor.\n\n\nExample 1: Set a global callback using `dspy.configure`.\n\n```\nimport dspy\nfrom dspy.utils.callback import BaseCallback\n\nclass LoggingCallback(BaseCallback):\n\n    def on_lm_start(self, call_id, instance, inputs):\n        print(f\"LM is called with inputs: {inputs}\")\n\n    def on_lm_end(self, call_id, outputs, exception):\n        print(f\"LM is finished with outputs: {outputs}\")\n\ndspy.configure(\n    callbacks=[LoggingCallback()]\n)\n\ncot = dspy.ChainOfThought(\"question -> answer\")\ncot(question=\"What is the meaning of life?\")\n\n# > LM is called with inputs: {'question': 'What is the meaning of life?'}\n# > LM is finished with outputs: {'answer': '42'}\n```\n\nExample 2: Set a local callback by passing it to the component constructor.\n\n```\nlm_1 = dspy.LM(\"gpt-3.5-turbo\", callbacks=[LoggingCallback()])\nlm_1(question=\"What is the meaning of life?\")\n\n# > LM is called with inputs: {'question': 'What is the meaning of life?'}\n# > LM is finished with outputs: {'answer': '42'}\n\nlm_2 = dspy.LM(\"gpt-3.5-turbo\")\nlm_2(question=\"What is the meaning of life?\")\n# No logging here because only `lm_1` has the callback set.\n```"},
      {Dspy.Code,
       "Code type in DSPy.\n\nThis type is useful for code generation and code analysis.\n\nExample 1: dspy.Code as output type in code generation:\n\n```python\nimport dspy\n\ndspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\n\nclass CodeGeneration(dspy.Signature):\n    '''Generate python code to answer the question.'''\n\n    question: str = dspy.InputField(description=\"The question to answer\")\n    code: dspy.Code[\"java\"] = dspy.OutputField(description=\"The code to execute\")\n\n\npredict = dspy.Predict(CodeGeneration)\n\nresult = predict(question=\"Given an array, find if any of the two numbers sum up to 10\")\nprint(result.code)\n```\n\nExample 2: dspy.Code as input type in code analysis:\n\n```python\nimport dspy\nimport inspect\n\ndspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\nclass CodeAnalysis(dspy.Signature):\n    '''Analyze the time complexity of the function.'''\n\n    code: dspy.Code[\"python\"] = dspy.InputField(description=\"The function to analyze\")\n    result: str = dspy.OutputField(description=\"The time complexity of the function\")\n\n\npredict = dspy.Predict(CodeAnalysis)\n\n\ndef sleepsort(x):\n    import time\n\n    for i in x:\n        time.sleep(i)\n        print(i)\n\nresult = predict(code=inspect.getsource(sleepsort))\nprint(result.result)\n```"},
      {Dspy.RLM,
       "Experimental: This class may change or be removed in a future release without warning.\n\nRecursive Language Model module.\n\n    Uses a sandboxed REPL to let the LLM programmatically explore large contexts\n    through code execution. The LLM writes Python code to examine data, call\n    sub-LLMs for semantic analysis, and build up answers iteratively.\n\n    The default interpreter is PythonInterpreter (Deno/Pyodide/WASM), but you\n    can provide any CodeInterpreter implementation (e.g., MockInterpreter, or write a custom one using E2B or Modal).\n\n    Note: RLM instances are not thread-safe when using a custom interpreter.\n    Create separate RLM instances for concurrent use, or use the default\n    PythonInterpreter which creates a fresh instance per forward() call.\n\n    Example:\n        ```python\n        # Basic usage\n        rlm = dspy.RLM(\"context, query -> output\", max_iterations=10)\n        result = rlm(context=\"...very long text...\", query=\"What is the magic number?\")\n        print(result.output)\n        ```\n    "},
      {Dspy.Dsp.Utils.NullContextManager, ""},
      {Dspy.Signatures.SignatureMeta,
       "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super())."},
      {Dspy.OldInputField, "A more ergonomic datatype that infers prefix and desc if omitted."},
      {Dspy.Clients.Openai.TrainingJobOpenAI,
       "Represents the result of an asynchronous computation."},
      {Dspy.Utils.Dummies.DummyLM,
       "Dummy language model for unit testing purposes.\n\nThree modes of operation:\n\nMode 1: List of dictionaries\n\nIf a list of dictionaries is provided, the dummy model will return the next dictionary\nin the list for each request, formatted according to the `format_field_with_value` function.\n\nExample:\n\n```\nlm = DummyLM([{\"answer\": \"red\"}, {\"answer\": \"blue\"}])\ndspy.configure(lm=lm)\npredictor(\"What color is the sky?\")\n# Output:\n# [[## answer ##]]\n# red\npredictor(\"What color is the sky?\")\n# Output:\n# [[## answer ##]]\n# blue\n```\n\nMode 2: Dictionary of dictionaries\n\nIf a dictionary of dictionaries is provided, the dummy model will return the value\ncorresponding to the key which is contained with the final message of the prompt,\nformatted according to the `format_field_with_value` function from the chat adapter.\n\n```\nlm = DummyLM({\"What color is the sky?\": {\"answer\": \"blue\"}})\ndspy.configure(lm=lm)\npredictor(\"What color is the sky?\")\n# Output:\n# [[## answer ##]]\n# blue\n```\n\nMode 3: Follow examples\n\nIf `follow_examples` is set to True, and the prompt contains an example input exactly equal to the prompt,\nthe dummy model will return the output from that example.\n\n```\nlm = DummyLM([{\"answer\": \"red\"}], follow_examples=True)\ndspy.configure(lm=lm)\npredictor(\"What color is the sky?, demos=dspy.Example(input=\"What color is the sky?\", output=\"blue\"))\n# Output:\n# [[## answer ##]]\n# blue\n```"},
      {Dspy.Utils.Hasher, "Hasher that accepts python objects as inputs."},
      {Dspy.Predict.RefineClass, ""},
      {Dspy.Teleprompt.BootstrapTrace.FailedPrediction,
       "FailedPrediction(completion_text: str, format_reward: float | None = None)"},
      {Dspy.Parallel, ""},
      {Dspy.Teleprompt.AvatarOptimizer.FeedbackBasedInstruction,
       "There is a task that needs to be completed for which one can use multiple tools to achieve the desired outcome. A group's performance was evaluated on a dataset of inputs, the inputs that did well are positive inputs, and the inputs that did not do well are negative inputs.\n\nYou received feedback on how they can better use the tools to improve your performance on the negative inputs. You have been provided with the previous instruction, that they followed to use tools to complete the task, and the feedback on your performance.\n\nYour task is to incorporate the feedback and generate a detailed instruction for the group to follow to improve their performance on the task.\n\nMake sure that the new instruction talks about how to use the tools effectively and should be no more than 3 paragraphs long. The previous instruction contains general guidelines that you must retain in the new instruction."},
      {Dspy.CodeInterpreterError,
       "Error raised during code execution in an interpreter.\n\nThis covers runtime errors, undefined variables, tool call failures, etc.\nSyntaxError is raised separately for invalid Python syntax."},
      {Dspy.Adapters.Types.FileClass,
       "A file input type for DSPy.\nSee https://platform.openai.com/docs/api-reference/chat/create#chat_create-messages-user_message-content-array_of_content_parts-file_content_part-file for specification.\n\nThe file_data field should be a data URI with the format:\n    data:<mime_type>;base64,<base64_encoded_data>\n\nExample:\n    ```python\n    import dspy\n\n    class QA(dspy.Signature):\n        file: dspy.File = dspy.InputField()\n        summary = dspy.OutputField()\n    program = dspy.Predict(QA)\n    result = program(file=dspy.File.from_path(\"./research.pdf\"))\n    print(result.summary)\n    ```"},
      {Dspy.PredictClass,
       "Basic DSPy module that maps inputs to outputs using a language model.\n\nArgs:\n    signature: The input/output signature describing the task.\n    callbacks: Optional list of callbacks for instrumentation.\n    **config: Default keyword arguments forwarded to the underlying\n        language model. These values can be overridden for a single\n        invocation by passing a ``config`` dictionary when calling the\n        module. For example::\n\n            predict = dspy.Predict(\"q -> a\", rollout_id=1, temperature=1.0)\n            predict(q=\"What is 1 + 52?\", config={\"rollout_id\": 2, \"temperature\": 1.0})"},
      {Dspy.Teleprompt.Gepa.Gepa.GEPAFeedbackMetric,
       "Experimental: This class may change or be removed in a future release without warning (introduced in v3.0.0)."},
      {Dspy.File,
       "A file input type for DSPy.\nSee https://platform.openai.com/docs/api-reference/chat/create#chat_create-messages-user_message-content-array_of_content_parts-file_content_part-file for specification.\n\nThe file_data field should be a data URI with the format:\n    data:<mime_type>;base64,<base64_encoded_data>\n\nExample:\n    ```python\n    import dspy\n\n    class QA(dspy.Signature):\n        file: dspy.File = dspy.InputField()\n        summary = dspy.OutputField()\n    program = dspy.Predict(QA)\n    result = program(file=dspy.File.from_path(\"./research.pdf\"))\n    print(result.summary)\n    ```"},
      {Dspy.Teleprompt.CoproOptimizer.BasicGenerateInstruction,
       "You are an instruction optimizer for large language models. I will give you a ``signature`` of fields (inputs and outputs) in English. Your task is to propose an instruction that will lead a good language model to perform the task well. Don't be afraid to be creative."},
      {Dspy.SignatureMeta,
       "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super())."},
      {Dspy.Dsp.Utils.Utils.DotdictLax,
       "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)"},
      {Dspy.Evaluate.Evaluate.Evaluate,
       "DSPy Evaluate class.\n\nThis class is used to evaluate the performance of a DSPy program. Users need to provide a evaluation dataset and\na metric function in order to use this class. This class supports parallel evaluation on the provided dataset."},
      {Dspy.Example,
       "A flexible data container for DSPy examples and training data.\n\nThe `Example` class is the standard data format used in DSPy evaluation and optimization.\n\nKey features:\n    - Dictionary-like access patterns (item access, iteration, etc.)\n    - Flexible initialization from dictionaries, other `Example` instances, or keyword arguments\n    - Input/output field separation for training data\n    - Serialization support for saving/loading `Example` instances\n    - Immutable operations that return new `Example` instances\n\nExamples:\n\n    Basic usage with keyword arguments:\n\n    ```python\n    import dspy\n\n    # Create an example with input and output fields\n    example = dspy.Example(\n        question=\"What is the capital of France?\",\n        answer=\"Paris\",\n    )\n    print(example.question)  # \"What is the capital of France?\"\n    print(example.answer)   # \"Paris\"\n    ```\n\n    Initialize from a dictionary:\n\n    ```python\n    data = {\"question\": \"What is 2+2?\", \"answer\": \"4\"}\n    example = dspy.Example(data)\n    print(example[\"question\"])  # \"What is 2+2?\"\n    ```\n\n    Copy from another Example:\n\n    ```python\n    original = dspy.Example(question=\"Hello\", answer=\"World\")\n    copy = dspy.Example(original)\n    print(copy.question)  # \"Hello\"\n    ```\n\n    Working with input/output separation:\n\n    ```python\n    # Mark which fields are inputs for training\n    example = dspy.Example(\n        question=\"What is the weather?\",\n        answer=\"It's sunny\",\n    ).with_inputs(\"question\")\n\n    # Get only input fields\n    inputs = example.inputs()\n    print(inputs.question)  # \"What is the weather?\"\n\n    # Get only output fields (labels)\n    labels = example.labels()\n    print(labels.answer)  # \"It's sunny\"\n    ```\n\n    Dictionary-like operations:\n\n    ```python\n    example = dspy.Example(name=\"Alice\", age=30)\n\n    # Check if key exists\n    if \"name\" in example:\n        print(\"Name field exists\")\n\n    # Get with default value\n    city = example.get(\"city\", \"Unknown\")\n    print(city)  # \"Unknown\"\n    ```"},
      {Dspy.Datasets.Alfworld.Alfworld.AlfWorld, ""},
      {Dspy.Propose.GroundedProposerClass3,
       "Helper class that provides a standard way to create an ABC using\ninheritance."},
      {Dspy.Adapters.JSONAdapterClass,
       "Default Adapter for most language models.\n\nThe ChatAdapter formats DSPy signatures into a format compatible with most language models.\nIt uses delimiter patterns like `[[ ## field_name ## ]]` to clearly separate input and output fields in\nthe message content.\n\nKey features:\n    - Structures inputs and outputs using field header markers for clear field delineation.\n    - Provides automatic fallback to JSONAdapter if the chat format fails."},
      {Dspy.BootstrapFinetune, ""},
      {Dspy.Datasets.MATHClass, ""},
      {Dspy.Adapters.Types.Reasoning,
       "Reasoning type in DSPy.\n\nThis type is useful when you want the DSPy output to include the reasoning of the LM. We build this type so that\nDSPy can support the reasoning model and non-reasoning model with the same code.\n\nThis is a str-like type, you can convert a string directly to a Reasoning object, and from DSPy adapters'\nperspective, `Reasoning` is treated as a string."},
      {Dspy.Adapters.Tool,
       "Tool class.\n\nThis class is used to simplify the creation of tools for tool calling (function calling) in LLMs. Only supports\nfunctions for now."},
      {Dspy.Teleprompt.Gepa.GepaUtils.ScoreWithFeedback,
       "A prediction object that contains the output of a DSPy module.\n\nPrediction inherits from Example.\n\nTo allow feedback-augmented scores, Prediction supports comparison operations\n(<, >, <=, >=) for Predictions with a `score` field. The comparison operations\ncompare the 'score' values as floats. For equality comparison, Predictions are equal\nif their underlying data stores are equal (inherited from Example).\n\nArithmetic operations (+, /, etc.) are also supported for Predictions with a 'score'\nfield, operating on the score value."},
      {Dspy.Teleprompt.InferRules, ""},
      {Dspy.Teleprompt.Vanilla.LabeledFewShot, ""},
      {Dspy.Teleprompt.Gepa.GEPA,
       "Experimental: This class may change or be removed in a future release without warning (introduced in v3.0.0).\n\n\nGEPA is an evolutionary optimizer, which uses reflection to evolve text components\nof complex systems. GEPA is proposed in the paper [GEPA: Reflective Prompt Evolution Can Outperform Reinforcement Learning](https://arxiv.org/abs/2507.19457).\nThe GEPA optimization engine is provided by the `gepa` package, available from [https://github.com/gepa-ai/gepa](https://github.com/gepa-ai/gepa).\n\nGEPA captures full traces of the DSPy module's execution, identifies the parts of the trace\ncorresponding to a specific predictor, and reflects on the behaviour of the predictor to\npropose a new instruction for the predictor. GEPA allows users to provide textual feedback\nto the optimizer, which is used to guide the evolution of the predictor. The textual feedback\ncan be provided at the granularity of individual predictors, or at the level of the entire system's\nexecution.\n\nTo provide feedback to the GEPA optimizer, implement a metric as follows:\n```\ndef metric(\n    gold: Example,\n    pred: Prediction,\n    trace: Optional[DSPyTrace] = None,\n    pred_name: Optional[str] = None,\n    pred_trace: Optional[DSPyTrace] = None,\n) -> float | ScoreWithFeedback:\n    \"\"\"\n    This function is called with the following arguments:\n    - gold: The gold example.\n    - pred: The predicted output.\n    - trace: Optional. The trace of the program's execution.\n    - pred_name: Optional. The name of the target predictor currently being optimized by GEPA, for which\n        the feedback is being requested.\n    - pred_trace: Optional. The trace of the target predictor's execution GEPA is seeking feedback for.\n\n    Note the `pred_name` and `pred_trace` arguments. During optimization, GEPA will call the metric to obtain\n    feedback for individual predictors being optimized. GEPA provides the name of the predictor in `pred_name`\n    and the sub-trace (of the trace) corresponding to the predictor in `pred_trace`.\n    If available at the predictor level, the metric should return {'score': float, 'feedback': str} corresponding\n    to the predictor.\n    If not available at the predictor level, the metric can also return a text feedback at the program level\n    (using just the gold, pred and trace).\n    If no feedback is returned, GEPA will use a simple text feedback consisting of just the score:\n    f\"This trajectory got a score of {score}.\"\n    \"\"\"\n    ...\n```\n\nGEPA can also be used as a batch inference-time search strategy, by passing `valset=trainset, track_stats=True, track_best_outputs=True`, and using the\n`detailed_results` attribute of the optimized program (returned by `compile`) to get the Pareto frontier of the batch. `optimized_program.detailed_results.best_outputs_valset` will contain the best outputs for each task in the batch.\n\nExample:\n```\ngepa = GEPA(metric=metric, track_stats=True)\nbatch_of_tasks = [dspy.Example(...) for task in tasks]\nnew_prog = gepa.compile(student, trainset=trainset, valset=batch_of_tasks)\npareto_frontier = new_prog.detailed_results.val_aggregate_scores\n# pareto_frontier is a list of scores, one for each task in the batch.\n```\n\nArgs:\n    metric: The metric function to use for feedback and evaluation.\n    auto: The auto budget to use for the run. Options: \"light\", \"medium\", \"heavy\".\n    max_full_evals: The maximum number of full evaluations to perform.\n    max_metric_calls: The maximum number of metric calls to perform.\n    reflection_minibatch_size: The number of examples to use for reflection in a single GEPA step. Default is 3.\n    candidate_selection_strategy: The strategy to use for candidate selection. Default is \"pareto\",\n        which stochastically selects candidates from the Pareto frontier of all validation scores.\n        Options: \"pareto\", \"current_best\".\n    reflection_lm: The language model to use for reflection. Required parameter. GEPA benefits from\n        a strong reflection model. Consider using `dspy.LM(model='gpt-5', temperature=1.0, max_tokens=32000)`\n        for optimal performance.\n    skip_perfect_score: Whether to skip examples with perfect scores during reflection. Default is True.\n    instruction_proposer: Optional custom instruction proposer implementing GEPA's ProposalFn protocol.\n        **Default: None (recommended for most users)** - Uses GEPA's proven instruction proposer from\n        the [GEPA library](https://github.com/gepa-ai/gepa), which implements the\n        [`ProposalFn`](https://github.com/gepa-ai/gepa/blob/main/src/gepa/core/adapter.py). This default\n        proposer is highly capable and was validated across diverse experiments reported in the GEPA\n        paper and tutorials.\n\n        See documentation on custom instruction proposers\n        [here](https://dspy.ai/api/optimizers/GEPA/GEPA_Advanced/#custom-instruction-proposers).\n\n        **Advanced Feature**: Only needed for specialized scenarios:\n        - **Multi-modal handling**: Processing dspy.Image inputs alongside textual information\n        - **Nuanced control over constraints**: Fine-grained control over instruction length, format,\n          and structural requirements beyond standard feedback mechanisms\n        - **Domain-specific knowledge injection**: Specialized terminology or context that cannot be\n          provided through feedback_func alone\n        - **Provider-specific prompting**: Optimizations for specific LLM providers (OpenAI, Anthropic)\n          with unique formatting preferences\n        - **Coupled component updates**: Coordinated updates of multiple components together rather\n          than independent optimization\n        - **External knowledge integration**: Runtime access to databases, APIs, or knowledge bases\n\n        The default proposer handles the vast majority of use cases effectively. Use\n        MultiModalInstructionProposer() from dspy.teleprompt.gepa.instruction_proposal for visual\n        content or implement custom ProposalFn for highly specialized requirements.\n\n        Note: When both instruction_proposer and reflection_lm are set, the instruction_proposer is called\n        in the reflection_lm context. However, reflection_lm is optional when using a custom instruction_proposer.\n        Custom instruction proposers can invoke their own LLMs if needed.\n    component_selector: Custom component selector implementing the [ReflectionComponentSelector](https://github.com/gepa-ai/gepa/blob/main/src/gepa/proposer/reflective_mutation/base.py) protocol,\n        or a string specifying a built-in selector strategy. Controls which components (predictors) are selected\n        for optimization at each iteration. Defaults to 'round_robin' strategy which cycles through components\n        one at a time. Available string options: 'round_robin' (cycles through components sequentially),\n        'all' (selects all components for simultaneous optimization). Custom selectors can implement strategies\n        using LLM-driven selection logic based on optimization state and trajectories.\n        See [gepa component selectors](https://github.com/gepa-ai/gepa/blob/main/src/gepa/strategies/component_selector.py)\n        for available built-in selectors and the ReflectionComponentSelector protocol for implementing custom selectors.\n    add_format_failure_as_feedback: Whether to add format failures as feedback. Default is False.\n    use_merge: Whether to use merge-based optimization. Default is True.\n    max_merge_invocations: The maximum number of merge invocations to perform. Default is 5.\n    num_threads: The number of threads to use for evaluation with `Evaluate`. Optional.\n    failure_score: The score to assign to failed examples. Default is 0.0.\n    perfect_score: The maximum score achievable by the metric. Default is 1.0. Used by GEPA\n        to determine if all examples in a minibatch are perfect.\n    log_dir: The directory to save the logs. GEPA saves elaborate logs, along with all candidate\n        programs, in this directory. Running G"},
      {Dspy.Streaming.StreamResponse,
       "StreamResponse(predict_name: str, signature_field_name: str, chunk: str, is_last_chunk: bool)"},
      {Dspy.Dsp.Utils.Settings.Settings,
       "A singleton class for DSPy configuration settings.\nThread-safe global configuration.\n- 'configure' can be called by only one 'owner' thread (the first thread that calls it).\n- Other threads see the configured global values from 'main_thread_config'.\n- 'context' sets thread-local overrides. These overrides propagate to threads spawned\n  inside that context block, when (and only when!) using a ParallelExecutor that copies overrides.\n\n  1. Only one unique thread (which can be any thread!) can call dspy.configure.\n  2. It affects a global state, visible to all. As a result, user threads work, but they shouldn't be\n     mixed with concurrent changes to dspy.configure from the \"main\" thread.\n     (TODO: In the future, add warnings: if there are near-in-time user-thread reads followed by .configure calls.)\n  3. Any thread can use dspy.context. It propagates to child threads created with DSPy primitives: Parallel, asyncify, etc."},
      {Dspy.Teleprompt.AvatarOptimizer.Comparator,
       "After executing the given actions on user inputs using the given instruction, some inputs have yielded good, results, while others have not. I'll provide you the inputs along with their, corresponding evaluation metrics:\n\nTask:\n(1) Firstly, identify and contrast the patterns of inputs that have achieved good results with those that have not.\n(2) Then, review the computational logic for any inconsistencies in the previous actions.\n(3) Lastly, specify the modification in tools used that can lead to improved performance on the negative inputs."},
      {Dspy.Propose.GroundedProposer.GenerateModuleInstruction, ""},
      {Dspy.Adapters.TwoStepAdapter,
       "A two-stage adapter that:\n    1. Uses a simpler, more natural prompt for the main LM\n    2. Uses a smaller LM with chat adapter to extract structured data from the response of main LM\nThis adapter uses a common __call__ logic defined in base Adapter class.\nThis class is particularly useful when interacting with reasoning models as the main LM since reasoning models\nare known to struggle with structured outputs.\n\nExample:\n```\nimport dspy\nlm = dspy.LM(model=\"openai/o3-mini\", max_tokens=16000, temperature = 1.0)\nadapter = dspy.TwoStepAdapter(dspy.LM(\"openai/gpt-4o-mini\"))\ndspy.configure(lm=lm, adapter=adapter)\nprogram = dspy.ChainOfThought(\"question->answer\")\nresult = program(\"What is the capital of France?\")\nprint(result)\n```"},
      {Dspy.Adapters.TwoStepAdapterClass,
       "A two-stage adapter that:\n    1. Uses a simpler, more natural prompt for the main LM\n    2. Uses a smaller LM with chat adapter to extract structured data from the response of main LM\nThis adapter uses a common __call__ logic defined in base Adapter class.\nThis class is particularly useful when interacting with reasoning models as the main LM since reasoning models\nare known to struggle with structured outputs.\n\nExample:\n```\nimport dspy\nlm = dspy.LM(model=\"openai/o3-mini\", max_tokens=16000, temperature = 1.0)\nadapter = dspy.TwoStepAdapter(dspy.LM(\"openai/gpt-4o-mini\"))\ndspy.configure(lm=lm, adapter=adapter)\nprogram = dspy.ChainOfThought(\"question->answer\")\nresult = program(\"What is the capital of France?\")\nprint(result)\n```"},
      {Dspy.Teleprompt.SIMBA,
       "SIMBA (Stochastic Introspective Mini-Batch Ascent) optimizer for DSPy.\n\nSIMBA is a DSPy optimizer that uses the LLM to analyze its own performance and \ngenerate improvement rules. It samples mini-batches, identifies challenging examples \nwith high output variability, then either creates self-reflective rules or adds \nsuccessful examples as demonstrations.\n\nFor more details, see: https://dspy.ai/api/optimizers/SIMBA/"},
      {Dspy.Teleprompt.RandomSearch.BootstrapFewShotWithRandomSearch, ""},
      {Dspy.Predict.Refine.Refine, ""},
      {Dspy.Signatures.OldField,
       "A more ergonomic datatype that infers prefix and desc if omitted."},
      {Dspy.Teleprompt.GRPO, ""},
      {Dspy.Primitives.Example,
       "A flexible data container for DSPy examples and training data.\n\nThe `Example` class is the standard data format used in DSPy evaluation and optimization.\n\nKey features:\n    - Dictionary-like access patterns (item access, iteration, etc.)\n    - Flexible initialization from dictionaries, other `Example` instances, or keyword arguments\n    - Input/output field separation for training data\n    - Serialization support for saving/loading `Example` instances\n    - Immutable operations that return new `Example` instances\n\nExamples:\n\n    Basic usage with keyword arguments:\n\n    ```python\n    import dspy\n\n    # Create an example with input and output fields\n    example = dspy.Example(\n        question=\"What is the capital of France?\",\n        answer=\"Paris\",\n    )\n    print(example.question)  # \"What is the capital of France?\"\n    print(example.answer)   # \"Paris\"\n    ```\n\n    Initialize from a dictionary:\n\n    ```python\n    data = {\"question\": \"What is 2+2?\", \"answer\": \"4\"}\n    example = dspy.Example(data)\n    print(example[\"question\"])  # \"What is 2+2?\"\n    ```\n\n    Copy from another Example:\n\n    ```python\n    original = dspy.Example(question=\"Hello\", answer=\"World\")\n    copy = dspy.Example(original)\n    print(copy.question)  # \"Hello\"\n    ```\n\n    Working with input/output separation:\n\n    ```python\n    # Mark which fields are inputs for training\n    example = dspy.Example(\n        question=\"What is the weather?\",\n        answer=\"It's sunny\",\n    ).with_inputs(\"question\")\n\n    # Get only input fields\n    inputs = example.inputs()\n    print(inputs.question)  # \"What is the weather?\"\n\n    # Get only output fields (labels)\n    labels = example.labels()\n    print(labels.answer)  # \"It's sunny\"\n    ```\n\n    Dictionary-like operations:\n\n    ```python\n    example = dspy.Example(name=\"Alice\", age=30)\n\n    # Check if key exists\n    if \"name\" in example:\n        print(\"Name field exists\")\n\n    # Get with default value\n    city = example.get(\"city\", \"Unknown\")\n    print(city)  # \"Unknown\"\n    ```"},
      {Dspy.Image,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Propose.DatasetSummaryGenerator.ObservationSummarizer,
       "Given a series of observations I have made about my dataset, please summarize them into a brief 2-3 sentence summary which highlights only the most important details."},
      {Dspy.FinalOutput,
       "Returned by interpreter.execute() when SUBMIT() is called.\n\nThis signals that the code execution loop should terminate and return\nthe contained output to the caller."},
      {Dspy.Teleprompt.MiproOptimizerV2.MIPROv2, ""},
      {Dspy.Primitives.ReplTypes.REPLEntry,
       "A single REPL interaction entry containing reasoning, code, and output."},
      {Dspy.Evaluate.AutoEvaluation.AnswerCompleteness,
       "Estimate the completeness of a system's responses, against the ground truth.\nYou will first enumerate key ideas in each response, discuss their overlap, and then report completeness."},
      {Dspy.Teleprompt.BootstrapFewShotWithOptuna, ""},
      {Dspy.Predict.ChainOfThought, ""},
      {Dspy.Teleprompt.CoproOptimizer.GenerateInstructionGivenAttempts,
       "You are an instruction optimizer for large language models. I will give some task instructions I've tried, along with their corresponding validation scores. The instructions are arranged in increasing order based on their scores, where higher scores indicate better quality.\n\nYour task is to propose a new instruction that will lead a good language model to perform the task even better. Don't be afraid to be creative."},
      {Dspy.Adapters.Types.File.File,
       "A file input type for DSPy.\nSee https://platform.openai.com/docs/api-reference/chat/create#chat_create-messages-user_message-content-array_of_content_parts-file_content_part-file for specification.\n\nThe file_data field should be a data URI with the format:\n    data:<mime_type>;base64,<base64_encoded_data>\n\nExample:\n    ```python\n    import dspy\n\n    class QA(dspy.Signature):\n        file: dspy.File = dspy.InputField()\n        summary = dspy.OutputField()\n    program = dspy.Predict(QA)\n    result = program(file=dspy.File.from_path(\"./research.pdf\"))\n    print(result.summary)\n    ```"},
      {Dspy.Utils.Dummies.DummyVectorizer, "Simple vectorizer based on n-grams."},
      {Dspy.Predict.Avatar.AvatarClass, ""},
      {Dspy.Ensemble, ""},
      {Dspy.Datasets.DataLoader, ""},
      {Dspy.ChatAdapter,
       "Default Adapter for most language models.\n\nThe ChatAdapter formats DSPy signatures into a format compatible with most language models.\nIt uses delimiter patterns like `[[ ## field_name ## ]]` to clearly separate input and output fields in\nthe message content.\n\nKey features:\n    - Structures inputs and outputs using field header markers for clear field delineation.\n    - Provides automatic fallback to JSONAdapter if the chat format fails."},
      {Dspy.Adapters.History,
       "Class representing the conversation history.\n\nThe conversation history is a list of messages, each message entity should have keys from the associated signature.\nFor example, if you have the following signature:\n\n```\nclass MySignature(dspy.Signature):\n    question: str = dspy.InputField()\n    history: dspy.History = dspy.InputField()\n    answer: str = dspy.OutputField()\n```\n\nThen the history should be a list of dictionaries with keys \"question\" and \"answer\".\n\nExample:\n    ```\n    import dspy\n\n    dspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\n    class MySignature(dspy.Signature):\n        question: str = dspy.InputField()\n        history: dspy.History = dspy.InputField()\n        answer: str = dspy.OutputField()\n\n    history = dspy.History(\n        messages=[\n            {\"question\": \"What is the capital of France?\", \"answer\": \"Paris\"},\n            {\"question\": \"What is the capital of Germany?\", \"answer\": \"Berlin\"},\n        ]\n    )\n\n    predict = dspy.Predict(MySignature)\n    outputs = predict(question=\"What is the capital of France?\", history=history)\n    ```\n\nExample of capturing the conversation history:\n    ```\n    import dspy\n\n    dspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\n    class MySignature(dspy.Signature):\n        question: str = dspy.InputField()\n        history: dspy.History = dspy.InputField()\n        answer: str = dspy.OutputField()\n\n    predict = dspy.Predict(MySignature)\n    outputs = predict(question=\"What is the capital of France?\")\n    history = dspy.History(messages=[{\"question\": \"What is the capital of France?\", **outputs}])\n    outputs_with_history = predict(question=\"Are you sure?\", history=history)\n    ```"},
      {Dspy.COPRO, ""},
      {Dspy.Teleprompt.MIPROv2, ""},
      {Dspy.Provider, ""},
      {Dspy.Utils.LoggingUtils.DSPyLoggingStream,
       "A Python stream for use with event logging APIs throughout DSPy (`eprint()`,\n`logger.info()`, etc.). This stream wraps `sys.stderr`, forwarding `write()` and\n`flush()` calls to the stream referred to by `sys.stderr` at the time of the call.\nIt also provides capabilities for disabling the stream to silence event logs."},
      {Dspy.Refine, ""},
      {Dspy.Completions, ""},
      {Dspy.MIPROv2, ""},
      {Dspy.Datasets.Dataloader.DataLoader, ""},
      {Dspy.Primitives.Module.Module, ""},
      {Dspy.Signatures.OldOutputField,
       "A more ergonomic datatype that infers prefix and desc if omitted."},
      {Dspy.Teleprompt.AvatarOptimizer, ""},
      {Dspy.Primitives.PythonInterpreter.CodeInterpreterError,
       "Error raised during code execution in an interpreter.\n\nThis covers runtime errors, undefined variables, tool call failures, etc.\nSyntaxError is raised separately for invalid Python syntax."},
      {Dspy.Adapters.Types.BaseType.Type,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Primitives.CodeInterpreter,
       "Protocol for code execution environments (interpreters).\n\nImplementations must provide:\n- start(): Initialize the interpreter (optional, can be lazy)\n- execute(): Run code and return results\n- shutdown(): Clean up resources\n\nThe interpreter maintains state across execute() calls within a session,\nallowing variables defined in one call to be used in subsequent calls.\n\nLifecycle:\n    1. Create instance (config only, no resources allocated)\n    2. start() - Initialize interpreter (explicit) or let execute() do it (lazy)\n    3. execute() - Run code (can be called many times)\n    4. shutdown() - Release resources\n\nExample implementations:\n    - LocalInterpreter: Deno/Pyodide WASM interpreter (local)\n    - MockInterpreter: Scriptable responses for testing\n\nPooling:\n    For interpreter pooling, call start() to pre-warm instances, then\n    distribute execute() calls across the pool."},
      {Dspy.Adapters.ChatAdapter,
       "Default Adapter for most language models.\n\nThe ChatAdapter formats DSPy signatures into a format compatible with most language models.\nIt uses delimiter patterns like `[[ ## field_name ## ]]` to clearly separate input and output fields in\nthe message content.\n\nKey features:\n    - Structures inputs and outputs using field header markers for clear field delineation.\n    - Provides automatic fallback to JSONAdapter if the chat format fails."},
      {Dspy.Adapters.BAMLAdapter,
       "A DSPy adapter that improves the rendering of complex/nested Pydantic models to help LMs.\n\nThis adapter generates a compact, human-readable schema representation for nested Pydantic output\nfields, inspired by the BAML project's JSON formatter (https://github.com/BoundaryML/baml).\nThe resulting rendered schema is more token-efficient and easier for smaller LMs to follow than a\nraw JSON schema. It also includes Pydantic field descriptions as comments in the schema, which\nprovide valuable additional context for the LM to understand the expected output.\n\nExample Usage:\n```python\nimport dspy\nfrom pydantic import BaseModel, Field\nfrom typing import Literal\nfrom baml_adapter import BAMLAdapter  # Import from your module\n\n# 1. Define your Pydantic models\nclass PatientAddress(BaseModel):\n    street: str\n    city: str\n    country: Literal[\"US\", \"CA\"]\n\nclass PatientDetails(BaseModel):\n    name: str = Field(description=\"Full name of the patient.\")\n    age: int\n    address: PatientAddress | None\n\n# 2. Define a signature using the Pydantic model as an output field\nclass ExtractPatientInfo(dspy.Signature):\n    '''Extract patient information from the clinical note.'''\n    clinical_note: str = dspy.InputField()\n    patient_info: PatientDetails = dspy.OutputField()\n\n# 3. Configure dspy to use the new adapter\nllm = dspy.OpenAI(model=\"gpt-4.1-mini\")\ndspy.configure(lm=llm, adapter=BAMLAdapter())\n\n# 4. Run your program\nextractor = dspy.Predict(ExtractPatientInfo)\nnote = \"John Doe, 45 years old, lives at 123 Main St, Anytown. Resident of the US.\"\nresult = extractor(clinical_note=note)\nprint(result.patient_info)\n\n# Expected output:\n# PatientDetails(name='John Doe', age=45, address=PatientAddress(street='123 Main St', city='Anytown', country='US'))\n```"},
      {Dspy.Teleprompt.SIMBAClass,
       "SIMBA (Stochastic Introspective Mini-Batch Ascent) optimizer for DSPy.\n\nSIMBA is a DSPy optimizer that uses the LLM to analyze its own performance and \ngenerate improvement rules. It samples mini-batches, identifies challenging examples \nwith high output variability, then either creates self-reflective rules or adds \nsuccessful examples as demonstrations.\n\nFor more details, see: https://dspy.ai/api/optimizers/SIMBA/"},
      {Dspy.ChainOfThoughtWithHint, ""},
      {Dspy.Predict.KNN, ""},
      {Dspy.Teleprompt.SimbaUtils.OfferFeedback,
       "You will be given two trajectories of an LLM-driven program's execution. Your goal is to help the program's modules\nbuild up experience on how to maximize the reward value assigned to the program's outputs if it were to receive\nsimilar inputs in the future.\n\nThe module won't see its own history. It will rely on your advice balancing being concrete and being generalizable.\n\nIn your advice:\n- Avoid boilerplate. Offer advice that would change the module's behavior for the better in the future.\n- Ensure that advice offered to a module M is specific to that M's specific sub-task, not the overall program.\n- Rely on contrasting the behavior of the worse trajectory against the better trajectory in making recommendations.\n- Ensure each unique module name appears exactly once as a key in the advice dictionary."},
      {Dspy.Teleprompt.BetterTogether, ""},
      {Dspy.Dsp.Utils.Dotdict,
       "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)"},
      {Dspy.Evaluate.EvaluateClass3,
       "DSPy Evaluate class.\n\nThis class is used to evaluate the performance of a DSPy program. Users need to provide a evaluation dataset and\na metric function in order to use this class. This class supports parallel evaluation on the provided dataset."},
      {Dspy.Predict.KNNClass, ""},
      {Dspy.Clients.Databricks.DatabricksProvider, ""},
      {Dspy.Adapters.ChatAdapter.FieldInfoWithName, "FieldInfoWithName(name, info)"},
      {Dspy.Primitives.PythonInterpreterClass,
       "Local interpreter for secure Python execution using Deno and Pyodide.\n\nImplements the Interpreter protocol for secure code execution in a\nWASM-based sandbox. Code runs in an isolated Pyodide environment with\nno access to the host filesystem, network, or environment by default.\n\nPrerequisites:\n    Deno must be installed: https://docs.deno.com/runtime/getting_started/installation/\n\nExample:\n    ```python\n    # Basic execution\n    with PythonInterpreter() as interp:\n        result = interp(\"print(1 + 2)\")  # Returns \"3\"\n\n    # With host-side tools\n    def my_tool(question: str) -> str:\n        return \"answer\"\n\n    with PythonInterpreter(tools={\"my_tool\": my_tool}) as interp:\n        result = interp(\"print(my_tool(question='test'))\")\n    ```"},
      {Dspy.Clients.LmLocal.LocalProvider, ""},
      {Dspy.Streaming.Messages.StatusMessage,
       "Dataclass that wraps a status message for status streaming."},
      {Dspy.Clients.LMClass,
       "A language model supporting chat or text completion requests for use with DSPy modules."},
      {Dspy.Teleprompt.CoproOptimizer.COPRO, ""},
      {Dspy.KNNFewShot, ""},
      {Dspy.OldField, "A more ergonomic datatype that infers prefix and desc if omitted."},
      {Dspy.Predict.ProgramOfThought,
       "A DSPy module that runs Python programs to solve a problem.\nThis module requires deno to be installed. Please install deno following https://docs.deno.com/runtime/getting_started/installation/\n\nExample:\n```\nimport dspy\n\nlm = dspy.LM('openai/gpt-4o-mini')\ndspy.configure(lm=lm)\npot = dspy.ProgramOfThought(\"question -> answer\")\npot(question=\"what is 1+1?\")\n```"},
      {Dspy.Datasets.HotPotQA, ""},
      {Dspy.ReAct, ""},
      {Dspy.Adapters.Types.ReasoningClass,
       "Reasoning type in DSPy.\n\nThis type is useful when you want the DSPy output to include the reasoning of the LM. We build this type so that\nDSPy can support the reasoning model and non-reasoning model with the same code.\n\nThis is a str-like type, you can convert a string directly to a Reasoning object, and from DSPy adapters'\nperspective, `Reasoning` is treated as a string."},
      {Dspy.Teleprompt.Gepa.Gepa.DspyGEPAResult,
       "Experimental: This class may change or be removed in a future release without warning (introduced in v3.0.0).\n\n\nAdditional data related to the GEPA run.\n\nFields:\n- candidates: list of proposed candidates (component_name -> component_text)\n- parents: lineage info; for each candidate i, parents[i] is a list of parent indices or None\n- val_aggregate_scores: per-candidate aggregate score on the validation set (higher is better)\n- val_subscores: per-candidate per-instance scores on the validation set (len == num_val_instances)\n- per_val_instance_best_candidates: for each val instance t, a set of candidate indices achieving the best score on t\n- discovery_eval_counts: Budget (number of metric calls / rollouts) consumed up to the discovery of each candidate\n\n- total_metric_calls: total number of metric calls made across the run\n- num_full_val_evals: number of full validation evaluations performed\n- log_dir: where artifacts were written (if any)\n- seed: RNG seed for reproducibility (if known)\n\n- best_idx: candidate index with the highest val_aggregate_scores\n- best_candidate: the program text mapping for best_idx"},
      {Dspy.Adapters.Types.ToolClass,
       "Tool class.\n\nThis class is used to simplify the creation of tools for tool calling (function calling) in LLMs. Only supports\nfunctions for now."},
      {Dspy.Evaluate.AutoEvaluation.CompleteAndGrounded, ""},
      {Dspy.Adapters.Image,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Adapters.Types.Document,
       "Experimental: This class may change or be removed in a future release without warning (introduced in v3.0.4).\n\nA document type for providing content that can be cited by language models.\n\n    This type represents documents that can be passed to language models for citation-enabled\n    responses, particularly useful with Anthropic's Citations API. Documents include the content\n    and metadata that helps the LM understand and reference the source material.\n\n    Attributes:\n        data: The text content of the document\n        title: Optional title for the document (used in citations)\n        media_type: MIME type of the document content (defaults to \"text/plain\")\n        context: Optional context information about the document\n\n    Example:\n        ```python\n        import dspy\n        from dspy.signatures import Signature\n        from dspy.experimental import Document, Citations\n\n        class AnswerWithSources(Signature):\n            '''Answer questions using provided documents with citations.'''\n            documents: list[Document] = dspy.InputField()\n            question: str = dspy.InputField()\n            answer: str = dspy.OutputField()\n            citations: Citations = dspy.OutputField()\n\n        # Create documents\n        docs = [\n            Document(\n                data=\"The Earth orbits the Sun in an elliptical path.\",\n                title=\"Basic Astronomy Facts\"\n            ),\n            Document(\n                data=\"Water boils at 100C at standard atmospheric pressure.\",\n                title=\"Physics Fundamentals\",\n            )\n        ]\n\n        # Use with a citation-supporting model\n        lm = dspy.LM(\"anthropic/claude-opus-4-1-20250805\")\n        predictor = dspy.Predict(AnswerWithSources)\n        result = predictor(documents=docs, question=\"What temperature does water boil?\", lm=lm)\n        print(result.citations)\n        ```\n    "},
      {Dspy.Primitives.CodeInterpreterError,
       "Error raised during code execution in an interpreter.\n\nThis covers runtime errors, undefined variables, tool call failures, etc.\nSyntaxError is raised separately for invalid Python syntax."},
      {Dspy.Clients.LM,
       "A language model supporting chat or text completion requests for use with DSPy modules."},
      {Dspy.Audio,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Predict.Avatar.Tool,
       "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."},
      {Dspy.Predict.MultiChainComparisonClass, ""},
      {Dspy.JSONAdapter,
       "Default Adapter for most language models.\n\nThe ChatAdapter formats DSPy signatures into a format compatible with most language models.\nIt uses delimiter patterns like `[[ ## field_name ## ]]` to clearly separate input and output fields in\nthe message content.\n\nKey features:\n    - Structures inputs and outputs using field header markers for clear field delineation.\n    - Provides automatic fallback to JSONAdapter if the chat format fails."},
      {Dspy.Utils.Callback.BaseCallback,
       "A base class for defining callback handlers for DSPy components.\n\nTo use a callback, subclass this class and implement the desired handlers. Each handler\nwill be called at the appropriate time before/after the execution of the corresponding component.  For example, if\nyou want to print a message before and after an LM is called, implement `the on_llm_start` and `on_lm_end` handler.\nUsers can set the callback globally using `dspy.configure` or locally by passing it to the component\nconstructor.\n\n\nExample 1: Set a global callback using `dspy.configure`.\n\n```\nimport dspy\nfrom dspy.utils.callback import BaseCallback\n\nclass LoggingCallback(BaseCallback):\n\n    def on_lm_start(self, call_id, instance, inputs):\n        print(f\"LM is called with inputs: {inputs}\")\n\n    def on_lm_end(self, call_id, outputs, exception):\n        print(f\"LM is finished with outputs: {outputs}\")\n\ndspy.configure(\n    callbacks=[LoggingCallback()]\n)\n\ncot = dspy.ChainOfThought(\"question -> answer\")\ncot(question=\"What is the meaning of life?\")\n\n# > LM is called with inputs: {'question': 'What is the meaning of life?'}\n# > LM is finished with outputs: {'answer': '42'}\n```\n\nExample 2: Set a local callback by passing it to the component constructor.\n\n```\nlm_1 = dspy.LM(\"gpt-3.5-turbo\", callbacks=[LoggingCallback()])\nlm_1(question=\"What is the meaning of life?\")\n\n# > LM is called with inputs: {'question': 'What is the meaning of life?'}\n# > LM is finished with outputs: {'answer': '42'}\n\nlm_2 = dspy.LM(\"gpt-3.5-turbo\")\nlm_2(question=\"What is the meaning of life?\")\n# No logging here because only `lm_1` has the callback set.\n```"},
      {Dspy.Evaluate.AutoEvaluation.SemanticRecallPrecision,
       "Compare a system's response to the ground truth to compute its recall and precision.\nIf asked to reason, enumerate key ideas in each response, and whether they are present in the other response."},
      {Dspy.Teleprompt.Gepa.GepaUtils.LoggerAdapter, ""},
      {Dspy.Datasets.Alfworld.Alfworld.EnvPool,
       "Pool of processes, each with a unique env_worker.\nAcquire a worker using a context manager for safe usage:\n    with pool.session() as sess:\n        sess.init(5)              # init with idx=5\n        obs, rew, done, info = sess.step(\"go north\")\n        ..."},
      {Dspy.Teleprompt.GEPAClass,
       "Experimental: This class may change or be removed in a future release without warning (introduced in v3.0.0).\n\n\nGEPA is an evolutionary optimizer, which uses reflection to evolve text components\nof complex systems. GEPA is proposed in the paper [GEPA: Reflective Prompt Evolution Can Outperform Reinforcement Learning](https://arxiv.org/abs/2507.19457).\nThe GEPA optimization engine is provided by the `gepa` package, available from [https://github.com/gepa-ai/gepa](https://github.com/gepa-ai/gepa).\n\nGEPA captures full traces of the DSPy module's execution, identifies the parts of the trace\ncorresponding to a specific predictor, and reflects on the behaviour of the predictor to\npropose a new instruction for the predictor. GEPA allows users to provide textual feedback\nto the optimizer, which is used to guide the evolution of the predictor. The textual feedback\ncan be provided at the granularity of individual predictors, or at the level of the entire system's\nexecution.\n\nTo provide feedback to the GEPA optimizer, implement a metric as follows:\n```\ndef metric(\n    gold: Example,\n    pred: Prediction,\n    trace: Optional[DSPyTrace] = None,\n    pred_name: Optional[str] = None,\n    pred_trace: Optional[DSPyTrace] = None,\n) -> float | ScoreWithFeedback:\n    \"\"\"\n    This function is called with the following arguments:\n    - gold: The gold example.\n    - pred: The predicted output.\n    - trace: Optional. The trace of the program's execution.\n    - pred_name: Optional. The name of the target predictor currently being optimized by GEPA, for which\n        the feedback is being requested.\n    - pred_trace: Optional. The trace of the target predictor's execution GEPA is seeking feedback for.\n\n    Note the `pred_name` and `pred_trace` arguments. During optimization, GEPA will call the metric to obtain\n    feedback for individual predictors being optimized. GEPA provides the name of the predictor in `pred_name`\n    and the sub-trace (of the trace) corresponding to the predictor in `pred_trace`.\n    If available at the predictor level, the metric should return {'score': float, 'feedback': str} corresponding\n    to the predictor.\n    If not available at the predictor level, the metric can also return a text feedback at the program level\n    (using just the gold, pred and trace).\n    If no feedback is returned, GEPA will use a simple text feedback consisting of just the score:\n    f\"This trajectory got a score of {score}.\"\n    \"\"\"\n    ...\n```\n\nGEPA can also be used as a batch inference-time search strategy, by passing `valset=trainset, track_stats=True, track_best_outputs=True`, and using the\n`detailed_results` attribute of the optimized program (returned by `compile`) to get the Pareto frontier of the batch. `optimized_program.detailed_results.best_outputs_valset` will contain the best outputs for each task in the batch.\n\nExample:\n```\ngepa = GEPA(metric=metric, track_stats=True)\nbatch_of_tasks = [dspy.Example(...) for task in tasks]\nnew_prog = gepa.compile(student, trainset=trainset, valset=batch_of_tasks)\npareto_frontier = new_prog.detailed_results.val_aggregate_scores\n# pareto_frontier is a list of scores, one for each task in the batch.\n```\n\nArgs:\n    metric: The metric function to use for feedback and evaluation.\n    auto: The auto budget to use for the run. Options: \"light\", \"medium\", \"heavy\".\n    max_full_evals: The maximum number of full evaluations to perform.\n    max_metric_calls: The maximum number of metric calls to perform.\n    reflection_minibatch_size: The number of examples to use for reflection in a single GEPA step. Default is 3.\n    candidate_selection_strategy: The strategy to use for candidate selection. Default is \"pareto\",\n        which stochastically selects candidates from the Pareto frontier of all validation scores.\n        Options: \"pareto\", \"current_best\".\n    reflection_lm: The language model to use for reflection. Required parameter. GEPA benefits from\n        a strong reflection model. Consider using `dspy.LM(model='gpt-5', temperature=1.0, max_tokens=32000)`\n        for optimal performance.\n    skip_perfect_score: Whether to skip examples with perfect scores during reflection. Default is True.\n    instruction_proposer: Optional custom instruction proposer implementing GEPA's ProposalFn protocol.\n        **Default: None (recommended for most users)** - Uses GEPA's proven instruction proposer from\n        the [GEPA library](https://github.com/gepa-ai/gepa), which implements the\n        [`ProposalFn`](https://github.com/gepa-ai/gepa/blob/main/src/gepa/core/adapter.py). This default\n        proposer is highly capable and was validated across diverse experiments reported in the GEPA\n        paper and tutorials.\n\n        See documentation on custom instruction proposers\n        [here](https://dspy.ai/api/optimizers/GEPA/GEPA_Advanced/#custom-instruction-proposers).\n\n        **Advanced Feature**: Only needed for specialized scenarios:\n        - **Multi-modal handling**: Processing dspy.Image inputs alongside textual information\n        - **Nuanced control over constraints**: Fine-grained control over instruction length, format,\n          and structural requirements beyond standard feedback mechanisms\n        - **Domain-specific knowledge injection**: Specialized terminology or context that cannot be\n          provided through feedback_func alone\n        - **Provider-specific prompting**: Optimizations for specific LLM providers (OpenAI, Anthropic)\n          with unique formatting preferences\n        - **Coupled component updates**: Coordinated updates of multiple components together rather\n          than independent optimization\n        - **External knowledge integration**: Runtime access to databases, APIs, or knowledge bases\n\n        The default proposer handles the vast majority of use cases effectively. Use\n        MultiModalInstructionProposer() from dspy.teleprompt.gepa.instruction_proposal for visual\n        content or implement custom ProposalFn for highly specialized requirements.\n\n        Note: When both instruction_proposer and reflection_lm are set, the instruction_proposer is called\n        in the reflection_lm context. However, reflection_lm is optional when using a custom instruction_proposer.\n        Custom instruction proposers can invoke their own LLMs if needed.\n    component_selector: Custom component selector implementing the [ReflectionComponentSelector](https://github.com/gepa-ai/gepa/blob/main/src/gepa/proposer/reflective_mutation/base.py) protocol,\n        or a string specifying a built-in selector strategy. Controls which components (predictors) are selected\n        for optimization at each iteration. Defaults to 'round_robin' strategy which cycles through components\n        one at a time. Available string options: 'round_robin' (cycles through components sequentially),\n        'all' (selects all components for simultaneous optimization). Custom selectors can implement strategies\n        using LLM-driven selection logic based on optimization state and trajectories.\n        See [gepa component selectors](https://github.com/gepa-ai/gepa/blob/main/src/gepa/strategies/component_selector.py)\n        for available built-in selectors and the ReflectionComponentSelector protocol for implementing custom selectors.\n    add_format_failure_as_feedback: Whether to add format failures as feedback. Default is False.\n    use_merge: Whether to use merge-based optimization. Default is True.\n    max_merge_invocations: The maximum number of merge invocations to perform. Default is 5.\n    num_threads: The number of threads to use for evaluation with `Evaluate`. Optional.\n    failure_score: The score to assign to failed examples. Default is 0.0.\n    perfect_score: The maximum score achievable by the metric. Default is 1.0. Used by GEPA\n        to determine if all examples in a minibatch are perfect.\n    log_dir: The directory to save the logs. GEPA saves elaborate logs, along with all candidate\n        programs, in this directory. Running G"},
      {Dspy.Adapters.File,
       "A file input type for DSPy.\nSee https://platform.openai.com/docs/api-reference/chat/create#chat_create-messages-user_message-content-array_of_content_parts-file_content_part-file for specification.\n\nThe file_data field should be a data URI with the format:\n    data:<mime_type>;base64,<base64_encoded_data>\n\nExample:\n    ```python\n    import dspy\n\n    class QA(dspy.Signature):\n        file: dspy.File = dspy.InputField()\n        summary = dspy.OutputField()\n    program = dspy.Predict(QA)\n    result = program(file=dspy.File.from_path(\"./research.pdf\"))\n    print(result.summary)\n    ```"},
      {Dspy.CodeAct,
       "CodeAct is a module that utilizes the Code Interpreter and predefined tools to solve the problem."},
      {Dspy.Teleprompt.Ensemble, ""},
      {Dspy.History,
       "Class representing the conversation history.\n\nThe conversation history is a list of messages, each message entity should have keys from the associated signature.\nFor example, if you have the following signature:\n\n```\nclass MySignature(dspy.Signature):\n    question: str = dspy.InputField()\n    history: dspy.History = dspy.InputField()\n    answer: str = dspy.OutputField()\n```\n\nThen the history should be a list of dictionaries with keys \"question\" and \"answer\".\n\nExample:\n    ```\n    import dspy\n\n    dspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\n    class MySignature(dspy.Signature):\n        question: str = dspy.InputField()\n        history: dspy.History = dspy.InputField()\n        answer: str = dspy.OutputField()\n\n    history = dspy.History(\n        messages=[\n            {\"question\": \"What is the capital of France?\", \"answer\": \"Paris\"},\n            {\"question\": \"What is the capital of Germany?\", \"answer\": \"Berlin\"},\n        ]\n    )\n\n    predict = dspy.Predict(MySignature)\n    outputs = predict(question=\"What is the capital of France?\", history=history)\n    ```\n\nExample of capturing the conversation history:\n    ```\n    import dspy\n\n    dspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\n    class MySignature(dspy.Signature):\n        question: str = dspy.InputField()\n        history: dspy.History = dspy.InputField()\n        answer: str = dspy.OutputField()\n\n    predict = dspy.Predict(MySignature)\n    outputs = predict(question=\"What is the capital of France?\")\n    history = dspy.History(messages=[{\"question\": \"What is the capital of France?\", **outputs}])\n    outputs_with_history = predict(question=\"Are you sure?\", history=history)\n    ```"},
      {Dspy.Clients.UtilsFinetune.TrainingStatus,
       "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'."},
      {Dspy.LabeledFewShot, ""},
      {Dspy.Evaluate.EvaluationResult,
       "A class that represents the result of an evaluation.\nIt is a subclass of `dspy.Prediction` that contains the following fields\n\n- score: An float value (e.g., 67.30) representing the overall performance\n- results: a list of (example, prediction, score) tuples for each example in devset"},
      {Dspy.Teleprompt.Gepa.GepaUtils.DspyAdapter,
       "GEPAAdapter is the single integration point between your system\nand the GEPA optimization engine. Implementers provide three responsibilities:\n\nThe following are user-defined types that are not interpreted by GEPA but are used by the user's code\n    to define the adapter:\nDataInst: User-defined type of input data to the program under optimization.\nTrajectory: User-defined type of trajectory data, which typically captures the\n    different steps of the program candidate execution.\nRolloutOutput: User-defined type of output data from the program candidate.\n\nThe following are the responsibilities of the adapter:\n1) Program construction and evaluation (evaluate):\n   Given a batch of DataInst and a \"candidate\" program (mapping from named components\n   -> component text), execute the program to produce per-example scores and\n   optionally rich trajectories (capturing intermediate states) needed for reflection.\n\n2) Reflective dataset construction (make_reflective_dataset):\n   Given the candidate, EvaluationBatch (trajectories, outputs, scores), and the list of components to update,\n   produce a small JSON-serializable dataset for each component that you want to update. This\n   dataset is fed to the teacher LM to propose improved component text.\n\n3) Optional instruction proposal (propose_new_texts):\n   GEPA provides a default implementation (instruction_proposal.py) that serializes the reflective dataset\n   to propose new component texts. However, users can implement their own proposal logic by implementing this method.\n   This method receives the current candidate, the reflective dataset, and the list of components to update,\n   and returns a mapping from component name to new component text.\n\nKey concepts and contracts:\n- candidate: Dict[str, str] mapping a named component of the system to its corresponding text.\n- scores: higher is better. GEPA uses:\n  - minibatch: sum(scores) to compare old vs. new candidate (acceptance test),\n  - full valset: mean(scores) for tracking and Pareto-front selection.\n  Ensure your metric is calibrated accordingly or normalized to a consistent scale.\n- trajectories: opaque to GEPA (the engine never inspects them). They must be\n  consumable by your own make_reflective_dataset implementation to extract the\n  minimal context needed to produce meaningful feedback for every component of\n  the system under optimization.\n- error handling: Never raise for individual example failures. Instead:\n  - Return a valid `EvaluationBatch` with per-example failure scores (e.g., 0.0)\n    when formatting/parsing fails. Even better if the trajectories are also populated\n    with the failed example, including the error message, identifying the reason for the failure.\n  - Reserve exceptions for unrecoverable, systemic failures (e.g., missing model,\n    misconfigured program, schema mismatch).\n  - If an exception is raised, the engine will log the error and proceed to the next iteration."},
      {Dspy.Experimental.Citations,
       "Experimental: This class may change or be removed in a future release without warning (introduced in v3.0.4).\n\nCitations extracted from an LM response with source references.\n\n    This type represents citations returned by language models that support\n    citation extraction, particularly Anthropic's Citations API through LiteLLM.\n    Citations include the quoted text and source information.\n\n    Example:\n        ```python\n        import os\n        import dspy\n        from dspy.signatures import Signature\n        from dspy.experimental import Citations, Document\n        os.environ[\"ANTHROPIC_API_KEY\"] = \"YOUR_ANTHROPIC_API_KEY\"\n\n        class AnswerWithSources(Signature):\n            '''Answer questions using provided documents with citations.'''\n            documents: list[Document] = dspy.InputField()\n            question: str = dspy.InputField()\n            answer: str = dspy.OutputField()\n            citations: Citations = dspy.OutputField()\n\n        # Create documents to provide as sources\n        docs = [\n            Document(\n                data=\"The Earth orbits the Sun in an elliptical path.\",\n                title=\"Basic Astronomy Facts\"\n            ),\n            Document(\n                data=\"Water boils at 100C at standard atmospheric pressure.\",\n                title=\"Physics Fundamentals\",\n                metadata={\"author\": \"Dr. Smith\", \"year\": 2023}\n            )\n        ]\n\n        # Use with a model that supports citations like Claude\n        lm = dspy.LM(\"anthropic/claude-opus-4-1-20250805\")\n        predictor = dspy.Predict(AnswerWithSources)\n        result = predictor(documents=docs, question=\"What temperature does water boil?\", lm=lm)\n\n        for citation in result.citations.citations:\n            print(citation.format())\n        ```\n    "},
      {Dspy.Clients.UtilsFinetune.GRPOChatData,
       "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)"},
      {Dspy.Predict.ProgramOfThoughtClass,
       "A DSPy module that runs Python programs to solve a problem.\nThis module requires deno to be installed. Please install deno following https://docs.deno.com/runtime/getting_started/installation/\n\nExample:\n```\nimport dspy\n\nlm = dspy.LM('openai/gpt-4o-mini')\ndspy.configure(lm=lm)\npot = dspy.ProgramOfThought(\"question -> answer\")\npot(question=\"what is 1+1?\")\n```"},
      {Dspy.BaseLM,
       "Base class for handling LLM calls.\n\nMost users can directly use the `dspy.LM` class, which is a subclass of `BaseLM`. Users can also implement their\nown subclasses of `BaseLM` to support custom LLM providers and inject custom logic. To do so, simply override the\n`forward` method and make sure the return format is identical to the\n[OpenAI response format](https://platform.openai.com/docs/api-reference/responses/object).\n\nExample:\n\n```python\nfrom openai import OpenAI\n\nimport dspy\n\n\nclass MyLM(dspy.BaseLM):\n    def forward(self, prompt, messages=None, **kwargs):\n        client = OpenAI()\n        return client.chat.completions.create(\n            model=self.model,\n            messages=messages or [{\"role\": \"user\", \"content\": prompt}],\n            **self.kwargs,\n        )\n\n\nlm = MyLM(model=\"gpt-4o-mini\")\ndspy.configure(lm=lm)\nprint(dspy.Predict(\"q->a\")(q=\"Why did the chicken cross the kitchen?\"))\n```"},
      {Dspy.Signatures.Signature.SignatureMeta,
       "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super())."},
      {Dspy.Adapters.Types.Image.Image,
       "Base class to support creating custom types for DSPy signatures.\n\nThis is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to\nreturn a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).\n\nExample:\n\n    ```python\n    class Image(Type):\n        url: str\n\n        def format(self) -> list[dict[str, Any]]:\n            return [{\"type\": \"image_url\", \"image_url\": {\"url\": self.url}}]\n    ```"},
      {Dspy.Primitives.Prediction,
       "A prediction object that contains the output of a DSPy module.\n\nPrediction inherits from Example.\n\nTo allow feedback-augmented scores, Prediction supports comparison operations\n(<, >, <=, >=) for Predictions with a `score` field. The comparison operations\ncompare the 'score' values as floats. For equality comparison, Predictions are equal\nif their underlying data stores are equal (inherited from Example).\n\nArithmetic operations (+, /, etc.) are also supported for Predictions with a 'score'\nfield, operating on the score value."},
      {Dspy.Teleprompt.KNNFewShot, ""},
      {Dspy.Teleprompt.KnnFewshot.KNNFewShot, ""},
      {Dspy.Teleprompt.Gepa.GepaUtils.ReflectiveExample,
       "Structure of individual examples in the reflective dataset.\n\nEach example contains the predictor inputs, generated outputs, and feedback from evaluation."},
      {Dspy.Adapters.Types.HistoryClass,
       "Class representing the conversation history.\n\nThe conversation history is a list of messages, each message entity should have keys from the associated signature.\nFor example, if you have the following signature:\n\n```\nclass MySignature(dspy.Signature):\n    question: str = dspy.InputField()\n    history: dspy.History = dspy.InputField()\n    answer: str = dspy.OutputField()\n```\n\nThen the history should be a list of dictionaries with keys \"question\" and \"answer\".\n\nExample:\n    ```\n    import dspy\n\n    dspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\n    class MySignature(dspy.Signature):\n        question: str = dspy.InputField()\n        history: dspy.History = dspy.InputField()\n        answer: str = dspy.OutputField()\n\n    history = dspy.History(\n        messages=[\n            {\"question\": \"What is the capital of France?\", \"answer\": \"Paris\"},\n            {\"question\": \"What is the capital of Germany?\", \"answer\": \"Berlin\"},\n        ]\n    )\n\n    predict = dspy.Predict(MySignature)\n    outputs = predict(question=\"What is the capital of France?\", history=history)\n    ```\n\nExample of capturing the conversation history:\n    ```\n    import dspy\n\n    dspy.configure(lm=dspy.LM(\"openai/gpt-4o-mini\"))\n\n    class MySignature(dspy.Signature):\n        question: str = dspy.InputField()\n        history: dspy.History = dspy.InputField()\n        answer: str = dspy.OutputField()\n\n    predict = dspy.Predict(MySignature)\n    outputs = predict(question=\"What is the capital of France?\")\n    history = dspy.History(messages=[{\"question\": \"What is the capital of France?\", **outputs}])\n    outputs_with_history = predict(question=\"Are you sure?\", history=history)\n    ```"},
      {Dspy.BootstrapRS, ""},
      {Dspy.Predict.ReAct, ""},
      {Dspy.Primitives.Completions, ""},
      {Dspy.Utils.DummyLM,
       "Dummy language model for unit testing purposes.\n\nThree modes of operation:\n\nMode 1: List of dictionaries\n\nIf a list of dictionaries is provided, the dummy model will return the next dictionary\nin the list for each request, formatted according to the `format_field_with_value` function.\n\nExample:\n\n```\nlm = DummyLM([{\"answer\": \"red\"}, {\"answer\": \"blue\"}])\ndspy.configure(lm=lm)\npredictor(\"What color is the sky?\")\n# Output:\n# [[## answer ##]]\n# red\npredictor(\"What color is the sky?\")\n# Output:\n# [[## answer ##]]\n# blue\n```\n\nMode 2: Dictionary of dictionaries\n\nIf a dictionary of dictionaries is provided, the dummy model will return the value\ncorresponding to the key which is contained with the final message of the prompt,\nformatted according to the `format_field_with_value` function from the chat adapter.\n\n```\nlm = DummyLM({\"What color is the sky?\": {\"answer\": \"blue\"}})\ndspy.configure(lm=lm)\npredictor(\"What color is the sky?\")\n# Output:\n# [[## answer ##]]\n# blue\n```\n\nMode 3: Follow examples\n\nIf `follow_examples` is set to True, and the prompt contains an example input exactly equal to the prompt,\nthe dummy model will return the output from that example.\n\n```\nlm = DummyLM([{\"answer\": \"red\"}], follow_examples=True)\ndspy.configure(lm=lm)\npredictor(\"What color is the sky?, demos=dspy.Example(input=\"What color is the sky?\", output=\"blue\"))\n# Output:\n# [[## answer ##]]\n# blue\n```"},
      {Dspy.Retrievers.RetrieveClass3, ""},
      {Dspy.Dsp.Colbertv2.ColBERTv2RetrieverLocal, ""},
      {Dspy.TrainingJob, "Represents the result of an asynchronous computation."},
      {Dspy.Adapters.XMLAdapter,
       "Default Adapter for most language models.\n\nThe ChatAdapter formats DSPy signatures into a format compatible with most language models.\nIt uses delimiter patterns like `[[ ## field_name ## ]]` to clearly separate input and output fields in\nthe message content.\n\nKey features:\n    - Structures inputs and outputs using field header markers for clear field delineation.\n    - Provides automatic fallback to JSONAdapter if the chat format fails."},
      {Dspy.Primitives.BaseModule, ""},
      {Dspy.Propose.DatasetSummaryGenerator.DatasetDescriptorWithPriorObservations,
       "Given several examples from a dataset please write observations about trends that hold for most or all of the samples. I will also provide you with a few observations I have already made.  Please add your own observations or if you feel the observations are comprehensive say 'COMPLETE' Some areas you may consider in your observations: topics, content, syntax, conciceness, etc. It will be useful to make an educated guess as to the nature of the task this dataset will enable. Don't be afraid to be creative"}
    ]
  end

  @doc false
  def __search__(query) do
    SnakeBridge.Docs.search(__MODULE__, query)
  end

  @doc false
  def doc(function) do
    SnakeBridge.Docs.get(__MODULE__, function)
  end
end
