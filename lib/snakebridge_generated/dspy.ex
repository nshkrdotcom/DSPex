# Generated by SnakeBridge v0.8.1 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 2.6.5

defmodule Dspy do
  @moduledoc """
  SnakeBridge bindings for `dspy`.

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Elixir.Dspy.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Elixir.Dspy.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Elixir.Dspy.predict(data, __runtime__: [timeout: 600_000])

  See `SnakeBridge.Defaults` for global timeout configuration.
  """

  def __snakebridge_python_name__, do: "dspy"
  def __snakebridge_library__, do: "dspy"

  @doc """
  Wraps a DSPy program so that it can be called asynchronously. This is useful for running a

  program in parallel with another task (e.g., another DSPy program).

  This implementation propagates the current thread's configuration context to the worker thread.

  ## Parameters

  - `program` - The DSPy program to be wrapped for asynchronous execution.

  Parameters:
  - `program` (term())

  Returns:
  - `term()`
  """
  @spec asyncify(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def asyncify(program, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :asyncify, [program], opts)
  end

  @doc """

  """
  @spec configure(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def configure(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :configure, [], opts)
  end

  @doc """

  """
  @spec configure_dspy_loggers(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def configure_dspy_loggers(root_module_name, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :configure_dspy_loggers, [root_module_name], opts)
  end

  @doc """
  Context manager for temporary configuration changes at the thread level.

  Does not affect global configuration. Changes only apply to the current thread.
  If threads are spawned inside this block using ParallelExecutor, they will inherit these overrides.

  Parameters:
  - `kwargs` (term())

  Returns:
  - `term()`
  """
  @spec context(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def context(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :context, [], opts)
  end

  @doc """

  """
  @spec disable_litellm_logging(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_litellm_logging(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :disable_litellm_logging, [], opts)
  end

  @doc """
  Disables the `DSPyLoggingStream` used by event logging APIs throughout DSPy

  (`eprint()`, `logger.info()`, etc), silencing all subsequent event logs.

  Returns:
  - `term()`
  """
  @spec disable_logging(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_logging(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :disable_logging, [], opts)
  end

  @doc """

  """
  @spec enable_litellm_logging(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_litellm_logging(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :enable_litellm_logging, [], opts)
  end

  @doc """
  Enables the `DSPyLoggingStream` used by event logging APIs throughout DSPy

  (`eprint()`, `logger.info()`, etc), emitting all subsequent event logs. This
  reverses the effects of `disable_logging()`.

  Returns:
  - `term()`
  """
  @spec enable_logging(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_logging(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :enable_logging, [], opts)
  end

  @doc """

  """
  @spec ensure_signature(String.t() | term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def ensure_signature(signature, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call(__MODULE__, :ensure_signature, [signature] ++ List.wrap(args), opts)
  end

  @doc """
  Infer a prefix from an attribute name by converting it to a human-readable format.



  ## Examples

    "camelCaseText" -> "Camel Case Text"
    "snake_case_text" -> "Snake Case Text"
    "text2number" -> "Text 2 Number"
    "HTMLParser" -> "HTML Parser"

  Parameters:
  - `attribute_name` (String.t())

  Returns:
  - `String.t()`
  """
  @spec infer_prefix(String.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def infer_prefix(attribute_name, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :infer_prefix, [attribute_name], opts)
  end

  @doc """

  """
  @spec input_field(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def input_field(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, "InputField", [], opts)
  end

  @doc """
  The global history shared across all LMs.

  Parameters:
  - `n` (integer() default: 1)

  Returns:
  - `term()`
  """
  @spec inspect_history(list(term()), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def inspect_history(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call(__MODULE__, :inspect_history, [] ++ List.wrap(args), opts)
  end

  @doc """
  Load saved DSPy model.

  This method is used to load a saved DSPy model with `save_program=True`, i.e., the model is saved with cloudpickle.

  ## Parameters

  - `path` - Path to the saved model. (type: `String.t()`)

  Parameters:
  - `path` (term())

  Returns:
  - `term()`
  """
  @spec load(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def load(path, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :load, [path], opts)
  end

  @doc """
  Returns the most common completion for the target field (or the last field) in the signature.

  When normalize returns None, that completion is ignored.
  In case of a tie, earlier completion are prioritized.

  Parameters:
  - `prediction_or_completions` (term())
  - `normalize` (term() default: <function default_normalize at 0x7fa54c7a1c60>)
  - `field` (term())

  Returns:
  - `term()`
  """
  @spec majority(term(), list(term()), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def majority(prediction_or_completions, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call(
      __MODULE__,
      :majority,
      [prediction_or_completions] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Create a new Signature subclass with the specified fields and instructions.



  ## Parameters

  - `signature` - Either a string in the format "input1, input2 -> output1, output2" or a dictionary mapping field names to tuples of (type, FieldInfo).
  - `instructions` - Optional string containing instructions/prompt for the signature. If not provided, defaults to a basic description of inputs and outputs.
  - `signature_name` - Optional string to name the generated Signature subclass. Defaults to "StringSignature".

  Parameters:
  - `signature` (String.t() | %{optional(String.t()) => {term(), term()}})
  - `instructions` (String.t())
  - `signature_name` (String.t() default: StringSignature)

  Returns:
  - `term()`
  """
  @spec make_signature(
          String.t() | %{optional(String.t()) => {term(), term()}},
          list(term()),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def make_signature(signature, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call(__MODULE__, :make_signature, [signature] ++ List.wrap(args), opts)
  end

  @doc """

  """
  @spec output_field(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def output_field(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, "OutputField", [], opts)
  end

  @doc """
  A singleton class for DSPy configuration settings.

  Thread-safe global configuration.
  - 'configure' can be called by only one 'owner' thread (the first thread that calls it).
  - Other threads see the configured global values from 'main_thread_config'.
  - 'context' sets thread-local overrides. These overrides propagate to threads spawned
  inside that context block, when (and only when!) using a ParallelExecutor that copies overrides.

  1. Only one unique thread (which can be any thread!) can call dspy.configure.
  2. It affects a global state, visible to all. As a result, user threads work, but they shouldn't be
     mixed with concurrent changes to dspy.configure from the "main" thread.
     (TODO: In the future, add warnings: if there are near-in-time user-thread reads followed by .configure calls.)
  3. Any thread can use dspy.context. It propagates to child threads created with DSPy primitives: Parallel, asyncify, etc.

  Returns:
  - `term()`
  """
  @spec settings() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def settings() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :settings)
  end

  @doc """
  Wrap a DSPy program so that it streams its outputs incrementally, rather than returning them

  all at once. It also provides status messages to the user to indicate the progress of the program, and users
  can implement their own status message provider to customize the status messages and what module to generate
  status messages for.

  ## Parameters

  - `program` - The DSPy program to wrap with streaming functionality.
  - `status_message_provider` - A custom status message generator to use instead of the default one. Users can implement their own status message generator to customize the status messages and what module to generate status messages for.

  Parameters:
  - `program` (term())
  - `status_message_provider` (term() | nil)

  Returns:
  - `term()`
  """
  @spec streamify(term(), list(term()), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def streamify(program, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call(__MODULE__, :streamify, [program] ++ List.wrap(args), opts)
  end

  defmodule Adapter do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Adapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_finetune_data(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_finetune_data,
        [signature, demos, inputs, outputs],
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end
  end

  defmodule AvatarOptimizer do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "AvatarOptimizer"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec process_example(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def process_example(ref, actor, example, return_outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :process_example,
        [actor, example, return_outputs],
        opts
      )
    end

    @spec thread_safe_evaluator(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def thread_safe_evaluator(ref, devset, actor, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :thread_safe_evaluator,
        [devset, actor] ++ List.wrap(args),
        opts
      )
    end
  end

  defmodule BaseLM do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BaseLM"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [model] ++ List.wrap(args), opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec update_global_history(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_global_history(ref, entry, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_global_history, [entry], opts)
    end
  end

  defmodule BaseModule do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BaseModule"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end
  end

  defmodule BetterTogether do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BetterTogether"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), list(term()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, trainset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :compile, [student, trainset] ++ List.wrap(args), opts)
    end
  end

  defmodule BootstrapFewShot do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BootstrapFewShot"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end
  end

  defmodule BootstrapFewShotWithOptuna do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BootstrapFewShotWithOptuna"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["max_demos", "trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end

    @spec objective(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def objective(ref, trial, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :objective, [trial], opts)
    end
  end

  defmodule BootstrapFewShotWithRandomSearch do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BootstrapFewShotWithRandomSearch"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end
  end

  defmodule BootstrapFinetune do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BootstrapFinetune"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), list(term()), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, trainset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :compile, [student, trainset] ++ List.wrap(args), opts)
    end

    @spec convert_to_lm_dict(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, %{optional(term()) => term()}} | {:error, Snakepit.Error.t()}
    def convert_to_lm_dict(ref, arg, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :convert_to_lm_dict, [arg], opts)
    end

    @spec finetune_lms(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, %{optional(term()) => term()}} | {:error, Snakepit.Error.t()}
    def finetune_lms(ref, finetune_dict, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finetune_lms, [finetune_dict], opts)
    end
  end

  defmodule BootstrapRS do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "BootstrapRS"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end
  end

  defmodule COPRO do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "COPRO"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset", "eval_kwargs"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end
  end

  defmodule ChainOfThought do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "ChainOfThought"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule ChainOfThoughtWithHint do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "ChainOfThoughtWithHint"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule ChatAdapter do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "ChatAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec format(
            SnakeBridge.Ref.t(),
            term(),
            list(%{optional(String.t()) => term()}),
            %{optional(String.t()) => term()},
            keyword()
          ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_fields(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_fields(ref, signature, values, role, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_fields, [signature, values, role], opts)
    end

    @spec format_finetune_data(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_finetune_data,
        [signature, demos, inputs, outputs],
        opts
      )
    end

    @spec format_turn(SnakeBridge.Ref.t(), term(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_turn(ref, signature, values, role, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_turn,
        [signature, values, role] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end
  end

  defmodule ColBERTv2 do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "ColBERTv2"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end
  end

  defmodule Completions do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Completions"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(list_or_dict, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [list_or_dict] ++ List.wrap(args),
        opts
      )
    end

    @spec get(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__getitem__", [key], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :items, [], opts)
    end

    @spec length(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def length(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__len__", [], opts)
    end

    @spec member?(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def member?(ref, key, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__contains__", [key], opts)
    end

    @spec to_string(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_string(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__str__", [], opts)
    end
  end

  defmodule Embedder do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Embedder"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [model] ++ List.wrap(args), opts)
    end
  end

  defmodule Ensemble do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Ensemble"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, programs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :compile, [programs], opts)
    end
  end

  defmodule Evaluate do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Evaluate"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["devset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end
  end

  defmodule Example do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Example"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec inputs(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inputs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :inputs, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec items(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :items, [] ++ List.wrap(args), opts)
    end

    @spec keys(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :keys, [] ++ List.wrap(args), opts)
    end

    @spec labels(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def labels(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :labels, [], opts)
    end

    @spec length(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def length(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__len__", [], opts)
    end

    @spec member?(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def member?(ref, key, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__contains__", [key], opts)
    end

    @spec put(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def put(ref, key, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__setitem__", [key, value], opts)
    end

    @spec to_dict(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "toDict", [], opts)
    end

    @spec to_string(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_string(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__str__", [], opts)
    end

    @spec values(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :values, [] ++ List.wrap(args), opts)
    end

    @spec with_inputs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_inputs(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_inputs, [] ++ List.wrap(args), opts)
    end

    @spec without(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def without(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :without, [] ++ List.wrap(args), opts)
    end
  end

  defmodule Image do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Image"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def serialize_model(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
    end

    @spec to_string(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_string(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__str__", [], opts)
    end
  end

  defmodule JSONAdapter do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "JSONAdapter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec format(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format(ref, signature, demos, inputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
    end

    @spec format_fields(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_fields(ref, signature, values, role, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :format_fields, [signature, values, role], opts)
    end

    @spec format_finetune_data(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
      SnakeBridge.Runtime.call_method(
        ref,
        :format_finetune_data,
        [signature, demos, inputs, outputs],
        opts
      )
    end

    @spec format_turn(SnakeBridge.Ref.t(), term(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def format_turn(ref, signature, values, role, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :format_turn,
        [signature, values, role] ++ List.wrap(args),
        opts
      )
    end

    @spec parse(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse(ref, signature, completion, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
    end
  end

  defmodule KNN do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "KNN"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(integer(), list(term()), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(k, trainset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [k, trainset] ++ List.wrap(args),
        opts
      )
    end
  end

  defmodule KNNFewShot do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "KNNFewShot"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(integer(), list(term()), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(k, trainset, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [k, trainset] ++ List.wrap(args),
        opts
      )
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end
  end

  defmodule LM do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "LM"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(String.t(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(model, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [model] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec finetune(
            SnakeBridge.Ref.t(),
            list(%{optional(String.t()) => term()}),
            term() | nil,
            list(term()),
            keyword()
          ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def finetune(ref, train_data, train_data_format, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :finetune,
        [train_data, train_data_format] ++ List.wrap(args),
        opts
      )
    end

    @spec infer_adapter(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def infer_adapter(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :infer_adapter, [], opts)
    end

    @spec infer_provider(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def infer_provider(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :infer_provider, [], opts)
    end

    @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect_history(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
    end

    @spec kill(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :kill, [] ++ List.wrap(args), opts)
    end

    @spec launch(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :launch, [] ++ List.wrap(args), opts)
    end

    @spec update_global_history(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_global_history(ref, entry, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_global_history, [entry], opts)
    end
  end

  defmodule LabeledFewShot do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "LabeledFewShot"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end
  end

  defmodule MIPROv2 do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "MIPROv2"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(metric, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [metric] ++ List.wrap(args), opts)
    end

    @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compile(ref, student, opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
    end
  end

  defmodule Module do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Module"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule MultiChainComparison do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "MultiChainComparison"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, completions, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [completions], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule OldField do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "OldField"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
      missing_kw = ["input"] |> Enum.reject(&(&1 in kw_keys))

      if missing_kw != [] do
        raise ArgumentError,
              "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
      end

      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finalize(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, key, inferred_prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [key, inferred_prefix], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end
  end

  defmodule OldInputField do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "OldInputField"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finalize(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, key, inferred_prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [key, inferred_prefix], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end
  end

  defmodule OldOutputField do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "OldOutputField"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finalize(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def finalize(ref, key, inferred_prefix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :finalize, [key, inferred_prefix], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end
  end

  defmodule Parallel do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Parallel"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec forward(SnakeBridge.Ref.t(), list({term(), term()}), list(term()), keyword()) ::
            {:ok, list(term())} | {:error, Snakepit.Error.t()}
    def forward(ref, exec_pairs, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [exec_pairs] ++ List.wrap(args), opts)
    end
  end

  defmodule Predict do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Predict"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_config(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_config(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_config, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec update_config(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def update_config(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :update_config, [], opts)
    end
  end

  defmodule Prediction do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Prediction"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def get(ref, key, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
    end

    @spec inputs(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inputs(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :inputs, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec items(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def items(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :items, [] ++ List.wrap(args), opts)
    end

    @spec keys(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def keys(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :keys, [] ++ List.wrap(args), opts)
    end

    @spec labels(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def labels(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :labels, [], opts)
    end

    @spec length(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def length(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__len__", [], opts)
    end

    @spec member?(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def member?(ref, key, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__contains__", [key], opts)
    end

    @spec put(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def put(ref, key, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__setitem__", [key, value], opts)
    end

    @spec to_dict(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "toDict", [], opts)
    end

    @spec to_string(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_string(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__str__", [], opts)
    end

    @spec values(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def values(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :values, [] ++ List.wrap(args), opts)
    end

    @spec with_inputs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_inputs(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_inputs, [] ++ List.wrap(args), opts)
    end

    @spec without(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def without(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :without, [] ++ List.wrap(args), opts)
    end
  end

  defmodule Program do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Program"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule ProgramOfThought do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "ProgramOfThought"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
    end

    @spec batch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec execute_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def execute_code(ref, code, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :execute_code, [code], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec parse_code(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parse_code(ref, code_data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parse_code, [code_data], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end
  end

  defmodule Provider do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Provider"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec finetune(
            SnakeBridge.Ref.t(),
            term(),
            String.t(),
            list(%{optional(String.t()) => term()}),
            (term() | String.t()) | nil,
            list(term()),
            keyword()
          ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def finetune(ref, job, model, train_data, train_data_format, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_method(
        ref,
        :finetune,
        [job, model, train_data, train_data_format] ++ List.wrap(args),
        opts
      )
    end

    @spec is_provider_model(SnakeBridge.Ref.t(), String.t(), keyword()) ::
            {:ok, boolean()} | {:error, Snakepit.Error.t()}
    def is_provider_model(ref, model, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_provider_model, [model], opts)
    end

    @spec kill(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def kill(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :kill, [lm] ++ List.wrap(args), opts)
    end

    @spec launch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def launch(ref, lm, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :launch, [lm] ++ List.wrap(args), opts)
    end
  end

  defmodule PythonInterpreter do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "PythonInterpreter"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec execute(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def execute(ref, code, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :execute, [code] ++ List.wrap(args), opts)
    end

    @spec shutdown(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
    def shutdown(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :shutdown, [], opts)
    end
  end

  defmodule ReAct do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "ReAct"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(signature, tools, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

      SnakeBridge.Runtime.call_class(
        __MODULE__,
        :__init__,
        [signature, tools] ++ List.wrap(args),
        opts
      )
    end

    @spec batch(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def batch(ref, examples, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
    end

    @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def deepcopy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def forward(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
    end

    @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def get_lm(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec load(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load, [path], opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def map_named_predictors(ref, func, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
    end

    @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
    end

    @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
    end

    @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def named_sub_modules(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
    end

    @spec parameters(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def parameters(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
    end

    @spec predictors(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def predictors(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
    end

    @spec reset_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
    end

    @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def save(ref, path, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
    end

    @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_lm(ref, lm, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
    end

    @spec truncate_trajectory(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def truncate_trajectory(ref, trajectory, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :truncate_trajectory, [trajectory], opts)
    end
  end

  defmodule Retrieve do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Retrieve"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec dump_state(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump_state(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
    end

    @spec forward(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
            {:ok, (list(String.t()) | term()) | list(term())} | {:error, Snakepit.Error.t()}
    def forward(ref, query, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :forward, [query] ++ List.wrap(args), opts)
    end

    @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def load_state(ref, state, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
    end

    @spec reset(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def reset(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :reset, [], opts)
    end
  end

  defmodule Signature do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Signature"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
    end

    @spec dict(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def dict(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :json, [], opts)
    end

    @spec model_copy(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def model_copy(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
    end

    @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
    def model_dump(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
    end

    @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def model_dump_json(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
    end

    @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, nil} | {:error, Snakepit.Error.t()}
    def model_post_init(ref, context, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
    end

    @spec to_string(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, String.t()} | {:error, Snakepit.Error.t()}
    def to_string(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__str__", [], opts)
    end
  end

  defmodule SignatureMeta do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "SignatureMeta"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec register(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def register(ref, subclass, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :register, [subclass], opts)
    end
  end

  defmodule Tool do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "Tool"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(term(), list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(func, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [func] ++ List.wrap(args), opts)
    end
  end

  defmodule TrainingJob do
    def __snakebridge_python_name__, do: "dspy"
    def __snakebridge_python_class__, do: "TrainingJob"
    def __snakebridge_library__, do: "dspy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec add_done_callback(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def add_done_callback(ref, py_fn, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :add_done_callback, [py_fn], opts)
    end

    @spec cancel(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancel(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cancel, [], opts)
    end

    @spec cancelled(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def cancelled(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cancelled, [], opts)
    end

    @spec done(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def done(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :done, [], opts)
    end

    @spec exception(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def exception(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :exception, [] ++ List.wrap(args), opts)
    end

    @spec inspect(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def inspect(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, "__repr__", [], opts)
    end

    @spec result(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def result(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :result, [] ++ List.wrap(args), opts)
    end

    @spec running(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def running(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :running, [], opts)
    end

    @spec set_exception(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_exception(ref, exception, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_exception, [exception], opts)
    end

    @spec set_result(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_result(ref, result, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_result, [result], opts)
    end

    @spec set_running_or_notify_cancel(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def set_running_or_notify_cancel(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :set_running_or_notify_cancel, [], opts)
    end

    @spec status(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def status(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :status, [], opts)
    end
  end

  @doc false
  def __functions__ do
    [
      {:asyncify, 1, __MODULE__,
       "Wraps a DSPy program so that it can be called asynchronously. This is useful for running a"},
      {:configure, 0, __MODULE__, ""},
      {:configure_dspy_loggers, 1, __MODULE__, ""},
      {:context, 0, __MODULE__,
       "Context manager for temporary configuration changes at the thread level."},
      {:disable_litellm_logging, 0, __MODULE__, ""},
      {:disable_logging, 0, __MODULE__,
       "Disables the `DSPyLoggingStream` used by event logging APIs throughout DSPy"},
      {:enable_litellm_logging, 0, __MODULE__, ""},
      {:enable_logging, 0, __MODULE__,
       "Enables the `DSPyLoggingStream` used by event logging APIs throughout DSPy"},
      {:ensure_signature, 1, __MODULE__, ""},
      {:infer_prefix, 1, __MODULE__,
       "Infer a prefix from an attribute name by converting it to a human-readable format."},
      {:input_field, 0, __MODULE__, ""},
      {:inspect_history, 0, __MODULE__, "The global history shared across all LMs."},
      {:load, 1, __MODULE__, "Load saved DSPy model."},
      {:majority, 1, __MODULE__,
       "Returns the most common completion for the target field (or the last field) in the signature."},
      {:make_signature, 1, __MODULE__,
       "Create a new Signature subclass with the specified fields and instructions."},
      {:output_field, 0, __MODULE__, ""},
      {:settings, 0, __MODULE__, "A singleton class for DSPy configuration settings."},
      {:streamify, 1, __MODULE__,
       "Wrap a DSPy program so that it streams its outputs incrementally, rather than returning them"}
    ]
  end

  @doc false
  def __classes__ do
    [
      {Dspy.Prediction, ""},
      {Dspy.OldOutputField, "A more ergonomic datatype that infers prefix and desc if omitted."},
      {Dspy.BootstrapFewShotWithRandomSearch, ""},
      {Dspy.BootstrapFewShot, ""},
      {Dspy.AvatarOptimizer, ""},
      {Dspy.Module, ""},
      {Dspy.ColBERTv2, "Wrapper for the ColBERTv2 Retrieval."},
      {Dspy.LM,
       "A language model supporting chat or text completion requests for use with DSPy modules."},
      {Dspy.Adapter,
       "Helper class that provides a standard way to create an ABC using\ninheritance."},
      {Dspy.ChainOfThought, ""},
      {Dspy.BaseModule, ""},
      {Dspy.MultiChainComparison, ""},
      {Dspy.PythonInterpreter,
       "PythonInterpreter that runs code in a sandboxed environment using Deno and Pyodide.\n\nPrerequisites:\n- Deno (https://docs.deno.com/runtime/getting_started/installation/).\n\nExample Usage:\n```python\ncode_string = \"print('Hello'); 1 + 2\"\ninterp = PythonInterpreter()\noutput = interp(code_string)\nprint(output)  # If final statement is non-None, prints the numeric result, else prints captured output\ninterp.shutdown()\n```"},
      {Dspy.Program, ""},
      {Dspy.Signature, ""},
      {Dspy.BetterTogether, ""},
      {Dspy.ProgramOfThought, ""},
      {Dspy.BootstrapFewShotWithOptuna, ""},
      {Dspy.Retrieve, ""},
      {Dspy.KNN, ""},
      {Dspy.Embedder,
       "DSPy embedding class.\n\nThe class for computing embeddings for text inputs. This class provides a unified interface for both:\n\n1. Hosted embedding models (e.g. OpenAI's text-embedding-3-small) via litellm integration\n2. Custom embedding functions that you provide\n\nFor hosted models, simply pass the model name as a string (e.g., \"openai/text-embedding-3-small\"). The class will use\nlitellm to handle the API calls and caching.\n\nFor custom embedding models, pass a callable function that:\n- Takes a list of strings as input.\n- Returns embeddings as either:\n    - A 2D numpy array of float32 values\n    - A 2D list of float32 values\n- Each row should represent one embedding vector\n\nArgs:\n    model: The embedding model to use. This can be either a string (representing the name of the hosted embedding\n        model, must be an embedding model supported by litellm) or a callable that represents a custom embedding\n        model.\n    batch_size (int, optional): The default batch size for processing inputs in batches. Defaults to 200.\n    caching (bool, optional): Whether to cache the embedding response when using a hosted model. Defaults to True.\n    **kwargs: Additional default keyword arguments to pass to the embedding model.\n\nExamples:\n    Example 1: Using a hosted model.\n\n    ```python\n    import dspy\n\n    embedder = dspy.Embedder(\"openai/text-embedding-3-small\", batch_size=100)\n    embeddings = embedder([\"hello\", \"world\"])\n\n    assert embeddings.shape == (2, 1536)\n    ```\n\n    Example 2: Using any local embedding model, e.g. from https://huggingface.co/models?library=sentence-transformers.\n\n    ```python\n    # pip install sentence_transformers\n    import dspy\n    from sentence_transformers import SentenceTransformer\n\n    # Load an extremely efficient local model for retrieval\n    model = SentenceTransformer(\"sentence-transformers/static-retrieval-mrl-en-v1\", device=\"cpu\")\n\n    embedder = dspy.Embedder(model.encode)\n    embeddings = embedder([\"hello\", \"world\"], batch_size=1)\n\n    assert embeddings.shape == (2, 1024)\n    ```\n\n    Example 3: Using a custom function.\n\n    ```python\n    import dspy\n    import numpy as np\n\n    def my_embedder(texts):\n        return np.random.rand(len(texts), 10)\n\n    embedder = dspy.Embedder(my_embedder)\n    embeddings = embedder([\"hello\", \"world\"], batch_size=1)\n\n    assert embeddings.shape == (2, 10)\n    ```"},
      {Dspy.Tool,
       "Tool class.\n\nThis class is used to simplify the creation of tools for tool calling (function calling) in LLMs. Only supports\nfunctions for now."},
      {Dspy.OldInputField, "A more ergonomic datatype that infers prefix and desc if omitted."},
      {Dspy.Parallel, ""},
      {Dspy.SignatureMeta,
       "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super())."},
      {Dspy.Example, ""},
      {Dspy.BootstrapFinetune, ""},
      {Dspy.Predict, ""},
      {Dspy.Image,
       "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance."},
      {Dspy.Ensemble, ""},
      {Dspy.ChatAdapter,
       "Helper class that provides a standard way to create an ABC using\ninheritance."},
      {Dspy.COPRO, ""},
      {Dspy.Provider, ""},
      {Dspy.Completions, ""},
      {Dspy.MIPROv2, ""},
      {Dspy.ChainOfThoughtWithHint, ""},
      {Dspy.KNNFewShot, ""},
      {Dspy.OldField, "A more ergonomic datatype that infers prefix and desc if omitted."},
      {Dspy.ReAct, ""},
      {Dspy.Evaluate,
       "DSPy Evaluate class.\n\nThis class is used to evaluate the performance of a DSPy program. Users need to provide a evaluation dataset and \na metric function in order to use this class. This class supports parallel evaluation on the provided dataset."},
      {Dspy.JSONAdapter,
       "Helper class that provides a standard way to create an ABC using\ninheritance."},
      {Dspy.LabeledFewShot, ""},
      {Dspy.BaseLM,
       "Helper class that provides a standard way to create an ABC using\ninheritance."},
      {Dspy.BootstrapRS, ""},
      {Dspy.TrainingJob, "Represents the result of an asynchronous computation."}
    ]
  end

  @doc false
  def __search__(query) do
    SnakeBridge.Docs.search(__MODULE__, query)
  end

  @doc false
  def doc(function) do
    SnakeBridge.Docs.get(__MODULE__, function)
  end
end
