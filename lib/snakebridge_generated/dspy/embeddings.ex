# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy
# Python class: Embeddings

defmodule Dspy.Embeddings do
  def __snakebridge_python_name__, do: "dspy"
  def __snakebridge_python_class__, do: "Embeddings"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @spec new(list(String.t()), term(), list(term()), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(corpus, embedder, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_class(
      __MODULE__,
      :__init__,
      [corpus, embedder] ++ List.wrap(args),
      opts
    )
  end

  @spec _batch_forward(SnakeBridge.Ref.t(), list(String.t()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _batch_forward(ref, queries, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_batch_forward, [queries], opts)
  end

  @spec _build_faiss(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _build_faiss(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_build_faiss, [], opts)
  end

  @spec _faiss_search(SnakeBridge.Ref.t(), term(), integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _faiss_search(ref, query_embeddings, num_candidates, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_faiss_search, [query_embeddings, num_candidates], opts)
  end

  @spec _normalize(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _normalize(ref, embeddings, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_normalize, [embeddings], opts)
  end

  @spec _rerank_and_predict(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _rerank_and_predict(ref, q_embeds, candidate_indices, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_rerank_and_predict,
      [q_embeds, candidate_indices],
      opts
    )
  end

  @spec forward(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def forward(ref, query, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :forward, [query], opts)
  end

  @spec from_saved(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def from_saved(ref, path, embedder, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :from_saved, [path, embedder], opts)
  end

  @spec load(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def load(ref, path, embedder, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :load, [path, embedder], opts)
  end

  @spec save(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def save(ref, path, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :save, [path], opts)
  end
end
