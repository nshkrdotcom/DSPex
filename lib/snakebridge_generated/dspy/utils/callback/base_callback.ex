# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.utils.callback
# Python class: BaseCallback

defmodule Dspy.Utils.Callback.BaseCallback do
  def __snakebridge_python_name__, do: "dspy.utils.callback"
  def __snakebridge_python_class__, do: "BaseCallback"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @spec on_adapter_format_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def on_adapter_format_end(ref, call_id, outputs, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :on_adapter_format_end,
      [call_id, outputs] ++ List.wrap(args),
      opts
    )
  end

  @spec on_adapter_format_start(
          SnakeBridge.Ref.t(),
          String.t(),
          term(),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def on_adapter_format_start(ref, call_id, instance, inputs, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :on_adapter_format_start,
      [call_id, instance, inputs],
      opts
    )
  end

  @spec on_adapter_parse_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def on_adapter_parse_end(ref, call_id, outputs, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :on_adapter_parse_end,
      [call_id, outputs] ++ List.wrap(args),
      opts
    )
  end

  @spec on_adapter_parse_start(
          SnakeBridge.Ref.t(),
          String.t(),
          term(),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def on_adapter_parse_start(ref, call_id, instance, inputs, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :on_adapter_parse_start,
      [call_id, instance, inputs],
      opts
    )
  end

  @spec on_evaluate_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def on_evaluate_end(ref, call_id, outputs, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :on_evaluate_end,
      [call_id, outputs] ++ List.wrap(args),
      opts
    )
  end

  @spec on_evaluate_start(
          SnakeBridge.Ref.t(),
          String.t(),
          term(),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def on_evaluate_start(ref, call_id, instance, inputs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :on_evaluate_start, [call_id, instance, inputs], opts)
  end

  @spec on_lm_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def on_lm_end(ref, call_id, outputs, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :on_lm_end, [call_id, outputs] ++ List.wrap(args), opts)
  end

  @spec on_lm_start(
          SnakeBridge.Ref.t(),
          String.t(),
          term(),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def on_lm_start(ref, call_id, instance, inputs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :on_lm_start, [call_id, instance, inputs], opts)
  end

  @spec on_module_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def on_module_end(ref, call_id, outputs, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :on_module_end,
      [call_id, outputs] ++ List.wrap(args),
      opts
    )
  end

  @spec on_module_start(
          SnakeBridge.Ref.t(),
          String.t(),
          term(),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def on_module_start(ref, call_id, instance, inputs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :on_module_start, [call_id, instance, inputs], opts)
  end

  @spec on_tool_end(SnakeBridge.Ref.t(), String.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def on_tool_end(ref, call_id, outputs, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :on_tool_end,
      [call_id, outputs] ++ List.wrap(args),
      opts
    )
  end

  @spec on_tool_start(
          SnakeBridge.Ref.t(),
          String.t(),
          term(),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def on_tool_start(ref, call_id, instance, inputs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :on_tool_start, [call_id, instance, inputs], opts)
  end
end
