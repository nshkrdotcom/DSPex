# Generated by SnakeBridge v0.13.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.primitives.base_module
# Python class: BaseModule

defmodule Dspy.Primitives.BaseModule do
  @moduledoc """
  Wrapper for Python class BaseModule.
  """
  def __snakebridge_python_name__, do: "dspy.primitives.base_module"
  def __snakebridge_python_class__, do: "BaseModule"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.
  """
  @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
  end

  @doc """
  Deep copy the module.

  This is a tweak to the default python deepcopy that only deep copies `self.parameters()`, and for other
  attributes, we just do the shallow copy.

  ## Returns

  - `term()`
  """
  @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def deepcopy(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
  end

  @doc """
  Python method `BaseModule.dump_state`.

  ## Parameters

  - `json_mode` (term() default: True)

  ## Returns

  - `term()`
  """
  @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def dump_state(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
  end

  @doc """
  Load the saved module. You may also want to check out dspy.load, if you want to

  load an entire program, not just the state for an existing program.

  ## Parameters

  - `path` - Path to the saved state file, which should be a .json or a .pkl file (type: `String.t()`)
  - `allow_pickle` - If True, allow loading .pkl files, which can run arbitrary code. This is dangerous and should only be used if you are sure about the source of the file and in a trusted environment. (type: `boolean()`)

  ## Returns

  - `term()`
  """
  @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def load(ref, path, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `BaseModule.load_state`.

  ## Parameters

  - `state` (term())

  ## Returns

  - `term()`
  """
  @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def load_state(ref, state, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
  end

  @doc """
  Unlike PyTorch, handles (non-recursive) lists of parameters too.

  ## Returns

  - `term()`
  """
  @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def named_parameters(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
  end

  @doc """
  Find all sub-modules in the module, as well as their names.

  Say `self.children[4]['key'].sub_module` is a sub-module. Then the name will be
  `children[4]['key'].sub_module`. But if the sub-module is accessible at different
  paths, only one of the paths will be returned.

  ## Parameters

  - `type_` (term() default: None)
  - `skip_compiled` (term() default: False)

  ## Returns

  - `term()`
  """
  @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def named_sub_modules(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `BaseModule.parameters`.

  ## Returns

  - `term()`
  """
  @spec parameters(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def parameters(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
  end

  @doc """
  Deep copy the module and reset all parameters.

  ## Returns

  - `term()`
  """
  @spec reset_copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def reset_copy(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
  end

  @doc """
  Save the module.

  Save the module to a directory or a file. There are two modes:
  - `save_program=False`: Save only the state of the module to a json or pickle file, based on the value of
      the file extension.
  - `save_program=True`: Save the whole module to a directory via cloudpickle, which contains both the state and
      architecture of the model.

  If `save_program=True` and `modules_to_serialize` are provided, it will register those modules for serialization
  with cloudpickle's `register_pickle_by_value`. This causes cloudpickle to serialize the module by value rather
  than by reference, ensuring the module is fully preserved along with the saved program. This is useful
  when you have custom modules that need to be serialized alongside your program. If None, then no modules
  will be registered for serialization.

  We also save the dependency versions, so that the loaded model can check if there is a version mismatch on
  critical dependencies or DSPy version.

  ## Parameters

  - `path` - Path to the saved state file, which should be a .json or .pkl file when `save_program=False`, and a directory when `save_program=True`. (type: `String.t()`)
  - `save_program` - If True, save the whole module to a directory via cloudpickle, otherwise only save the state. (type: `boolean()`)
  - `modules_to_serialize` - A list of modules to serialize with cloudpickle's `register_pickle_by_value`. If None, then no modules will be registered for serialization. (type: `list()`)

  ## Returns

  - `term()`
  """
  @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def save(ref, path, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
  end
end
