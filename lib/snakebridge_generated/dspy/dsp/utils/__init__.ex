# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.dsp.utils

defmodule Dspy.Dsp.Utils do
  @moduledoc """
  Submodule bindings for `dspy.dsp.utils`.
  """

  def __snakebridge_python_name__, do: "dspy.dsp.utils"
  def __snakebridge_library__, do: "dspy"

  @doc """

  """
  @spec batch(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec batch(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec batch(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec batch(term(), term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def batch(group, bsize) do
    SnakeBridge.Runtime.call(__MODULE__, :batch, [group, bsize], [])
  end

  def batch(group, bsize, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :batch, [group, bsize], opts)
  end

  def batch(group, bsize, provide_offset) do
    SnakeBridge.Runtime.call(__MODULE__, :batch, [group, bsize, provide_offset], [])
  end

  def batch(group, bsize, provide_offset, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :batch, [group, bsize, provide_offset], opts)
  end

  @doc """

  """
  @spec create_directory(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def create_directory(path, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :create_directory, [path], opts)
  end

  @doc """
  From Raymond Hettinger

  https://twitter.com/raymondh/status/944125570534621185
  Since Python 3.6 Dict are ordered
  Benchmark: https://gist.github.com/peterbe/67b9e40af60a1d5bcb1cfb4b2937b088

  Parameters:
  - `seq` (list(String.t()))

  Returns:
  - `list(String.t())`
  """
  @spec deduplicate(list(String.t()), keyword()) ::
          {:ok, list(String.t())} | {:error, Snakepit.Error.t()}
  def deduplicate(seq, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :deduplicate, [seq], opts)
  end

  @doc """

  """
  @spec default_config() :: {:ok, Dspy.Dsp.Utils.Utils.Dotdict.t()} | {:error, Snakepit.Error.t()}
  def default_config() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, "DEFAULT_CONFIG")
  end

  @doc """

  """
  @spec dpr_normalize(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dpr_normalize(text, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, "DPR_normalize", [text], opts)
  end

  @doc """

  """
  @spec dpr_tokenize(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dpr_tokenize(text, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, "DPR_tokenize", [text], opts)
  end

  @doc """

  """
  @spec file_tqdm(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def file_tqdm(file, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :file_tqdm, [file], opts)
  end

  @doc """

  """
  @spec flatten(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def flatten(data_list, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :flatten, [data_list], opts)
  end

  @doc """

  """
  @spec groupby_first_item(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def groupby_first_item(lst, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :groupby_first_item, [lst], opts)
  end

  @doc """
  Collect data into fixed-length chunks or blocks

  Example: grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
    Source: https://docs.python.org/3/library/itertools.html#itertools-recipes

  Parameters:
  - `iterable` (term())
  - `n` (term())
  - `fillvalue` (term() default: None)

  Returns:
  - `term()`
  """
  @spec grouper(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec grouper(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec grouper(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec grouper(term(), term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def grouper(iterable, n) do
    SnakeBridge.Runtime.call(__MODULE__, :grouper, [iterable, n], [])
  end

  def grouper(iterable, n, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :grouper, [iterable, n], opts)
  end

  def grouper(iterable, n, fillvalue) do
    SnakeBridge.Runtime.call(__MODULE__, :grouper, [iterable, n, fillvalue], [])
  end

  def grouper(iterable, n, fillvalue, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :grouper, [iterable, n, fillvalue], opts)
  end

  @doc """

  """
  @spec has_answer(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def has_answer(tokenized_answers, text, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :has_answer, [tokenized_answers, text], opts)
  end

  @doc """

  """
  @spec int_or_float(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def int_or_float(val, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :int_or_float, [val], opts)
  end

  @doc """

  """
  @spec lengths2offsets(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def lengths2offsets(lengths, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :lengths2offsets, [lengths], opts)
  end

  @doc """

  """
  @spec load_batch_backgrounds(term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def load_batch_backgrounds(args, qids, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :load_batch_backgrounds, [args, qids], opts)
  end

  @doc """
  Returns each occurrence of an answer as (offset, endpos) in terms of *characters*.

  Parameters:
  - `tokenized_answers` (term())
  - `text` (term())

  Returns:
  - `term()`
  """
  @spec locate_answers(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def locate_answers(tokenized_answers, text, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :locate_answers, [tokenized_answers, text], opts)
  end

  @doc """

  """
  @spec main_thread_config() ::
          {:ok, Dspy.Dsp.Utils.Utils.Dotdict.t()} | {:error, Snakepit.Error.t()}
  def main_thread_config() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :main_thread_config)
  end

  @doc """

  """
  @spec print_message(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def print_message(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :print_message, [], opts)
  end

  @doc """
  Requires items in list to already be grouped by first item.

  Parameters:
  - `lst` (term())

  Returns:
  - `term()`
  """
  @spec process_grouped_by_first_item(term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def process_grouped_by_first_item(lst, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :process_grouped_by_first_item, [lst], opts)
  end

  @doc """

  """
  @spec s_tokenizer() ::
          {:ok, Dspy.Dsp.Utils.Dpr.SimpleTokenizer.t()} | {:error, Snakepit.Error.t()}
  def s_tokenizer() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, "STokenizer")
  end

  @doc """
  A singleton class for DSPy configuration settings.

  Thread-safe global configuration.
  - 'configure' can be called by only one 'owner' thread (the first thread that calls it).
  - Other threads see the configured global values from 'main_thread_config'.
  - 'context' sets thread-local overrides. These overrides propagate to threads spawned
  inside that context block, when (and only when!) using a ParallelExecutor that copies overrides.

  1. Only one unique thread (which can be any thread!) can call dspy.configure.
  2. It affects a global state, visible to all. As a result, user threads work, but they shouldn't be
     mixed with concurrent changes to dspy.configure from the "main" thread.
     (TODO: In the future, add warnings: if there are near-in-time user-thread reads followed by .configure calls.)
  3. Any thread can use dspy.context. It propagates to child threads created with DSPy primitives: Parallel, asyncify, etc.

  Returns:
  - `Dspy.Dsp.Utils.Settings.Settings.t()`
  """
  @spec settings() :: {:ok, Dspy.Dsp.Utils.Settings.Settings.t()} | {:error, Snakepit.Error.t()}
  def settings() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :settings)
  end

  @doc """
  Strips accents from a piece of text.

  Parameters:
  - `text` (term())

  Returns:
  - `term()`
  """
  @spec strip_accents(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def strip_accents(text, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :strip_accents, [text], opts)
  end

  @doc """

  """
  @spec timestamp() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec timestamp(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec timestamp(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec timestamp(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def timestamp() do
    SnakeBridge.Runtime.call(__MODULE__, :timestamp, [], [])
  end

  def timestamp(opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :timestamp, [], opts)
  end

  def timestamp(daydir) do
    SnakeBridge.Runtime.call(__MODULE__, :timestamp, [daydir], [])
  end

  def timestamp(daydir, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :timestamp, [daydir], opts)
  end

  @doc """

  """
  @spec zip_first(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def zip_first(list1, list2, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :zip_first, [list1, list2], opts)
  end

  @doc """
  A much faster A, B, C = zip(*[(a, b, c), (a, b, c), ...])

  May return lists or tuples.

  Parameters:
  - `data_list` (term())
  - `lazy` (term() default: False)

  Returns:
  - `term()`
  """
  @spec zipstar(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec zipstar(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec zipstar(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec zipstar(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def zipstar(data_list) do
    SnakeBridge.Runtime.call(__MODULE__, :zipstar, [data_list], [])
  end

  def zipstar(data_list, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :zipstar, [data_list], opts)
  end

  def zipstar(data_list, lazy) do
    SnakeBridge.Runtime.call(__MODULE__, :zipstar, [data_list, lazy], [])
  end

  def zipstar(data_list, lazy, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :zipstar, [data_list, lazy], opts)
  end
end
