# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.clients.lm_local

defmodule Dspy.Clients.LmLocal do
  @moduledoc """
  Submodule bindings for `dspy.clients.lm_local`.
  """

  def __snakebridge_python_name__, do: "dspy.clients.lm_local"
  def __snakebridge_library__, do: "dspy"

  @doc """

  """
  @spec create_output_dir(term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def create_output_dir(model_name, data_path, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :create_output_dir, [model_name, data_path], opts)
  end

  @doc """
  This function encodes a single example into a format that can be used for sft training.

  Here, we assume each example has a 'messages' field. Each message in it is a dict with 'role' and 'content' fields.
  We use the `apply_chat_template` function from the tokenizer to tokenize the messages and prepare the input and label tensors.

  Code obtained from the allenai/open-instruct repository: https://github.com/allenai/open-instruct/blob/4365dea3d1a6111e8b2712af06b22a4512a0df88/open_instruct/finetune.py

  Parameters:
  - `example` (term())
  - `tokenizer` (term())
  - `max_seq_length` (term())

  Returns:
  - `term()`
  """
  @spec encode_sft_example(term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def encode_sft_example(example, tokenizer, max_seq_length, opts \\ []) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :encode_sft_example,
      [example, tokenizer, max_seq_length],
      opts
    )
  end

  @doc """
  Return a free TCP port on localhost.

  Returns:
  - `integer()`
  """
  @spec get_free_port(keyword()) :: {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_free_port(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_free_port, [], opts)
  end

  @doc """

  """
  @spec train_sft_locally(term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def train_sft_locally(model_name, train_data, train_kwargs, opts \\ []) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :train_sft_locally,
      [model_name, train_data, train_kwargs],
      opts
    )
  end

  @doc """
  Wait for the server to be ready by polling the /v1/models endpoint.



  ## Parameters

  - `base_url` - The base URL of the server (e.g. http://localhost:1234)
  - `timeout` - Maximum time to wait in seconds. None means wait forever.

  Parameters:
  - `base_url` (String.t())
  - `timeout` (term() default: None)

  Returns:
  - `nil`
  """
  @spec wait_for_server(String.t()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
  @spec wait_for_server(String.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
  @spec wait_for_server(String.t(), term()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
  @spec wait_for_server(String.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def wait_for_server(base_url) do
    SnakeBridge.Runtime.call(__MODULE__, :wait_for_server, [base_url], [])
  end

  def wait_for_server(base_url, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :wait_for_server, [base_url], opts)
  end

  def wait_for_server(base_url, timeout) do
    SnakeBridge.Runtime.call(__MODULE__, :wait_for_server, [base_url, timeout], [])
  end

  def wait_for_server(base_url, timeout, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :wait_for_server, [base_url, timeout], opts)
  end
end
