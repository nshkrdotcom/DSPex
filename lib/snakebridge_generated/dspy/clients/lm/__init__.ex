# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.clients.lm

defmodule Dspy.Clients.Lm do
  @moduledoc """
  Submodule bindings for `dspy.clients.lm`.
  """

  def __snakebridge_python_name__, do: "dspy.clients.lm"
  def __snakebridge_library__, do: "dspy"

  @doc """

  """
  @spec alitellm_completion(%{optional(String.t()) => term()}, integer()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec alitellm_completion(%{optional(String.t()) => term()}, integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec alitellm_completion(%{optional(String.t()) => term()}, integer(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec alitellm_completion(%{optional(String.t()) => term()}, integer(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def alitellm_completion(request, num_retries) do
    SnakeBridge.Runtime.call(__MODULE__, :alitellm_completion, [request, num_retries], [])
  end

  def alitellm_completion(request, num_retries, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :alitellm_completion, [request, num_retries], opts)
  end

  def alitellm_completion(request, num_retries, cache) do
    SnakeBridge.Runtime.call(__MODULE__, :alitellm_completion, [request, num_retries, cache], [])
  end

  def alitellm_completion(request, num_retries, cache, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :alitellm_completion,
      [request, num_retries, cache],
      opts
    )
  end

  @doc """

  """
  @spec alitellm_responses_completion(%{optional(String.t()) => term()}, integer()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec alitellm_responses_completion(%{optional(String.t()) => term()}, integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec alitellm_responses_completion(%{optional(String.t()) => term()}, integer(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec alitellm_responses_completion(
          %{optional(String.t()) => term()},
          integer(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def alitellm_responses_completion(request, num_retries) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :alitellm_responses_completion,
      [request, num_retries],
      []
    )
  end

  def alitellm_responses_completion(request, num_retries, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :alitellm_responses_completion,
      [request, num_retries],
      opts
    )
  end

  def alitellm_responses_completion(request, num_retries, cache) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :alitellm_responses_completion,
      [request, num_retries, cache],
      []
    )
  end

  def alitellm_responses_completion(request, num_retries, cache, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :alitellm_responses_completion,
      [request, num_retries, cache],
      opts
    )
  end

  @doc """

  """
  @spec alitellm_text_completion(%{optional(String.t()) => term()}, integer()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec alitellm_text_completion(%{optional(String.t()) => term()}, integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec alitellm_text_completion(%{optional(String.t()) => term()}, integer(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec alitellm_text_completion(%{optional(String.t()) => term()}, integer(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def alitellm_text_completion(request, num_retries) do
    SnakeBridge.Runtime.call(__MODULE__, :alitellm_text_completion, [request, num_retries], [])
  end

  def alitellm_text_completion(request, num_retries, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :alitellm_text_completion, [request, num_retries], opts)
  end

  def alitellm_text_completion(request, num_retries, cache) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :alitellm_text_completion,
      [request, num_retries, cache],
      []
    )
  end

  def alitellm_text_completion(request, num_retries, cache, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :alitellm_text_completion,
      [request, num_retries, cache],
      opts
    )
  end

  @doc """

  """
  @spec litellm_completion(%{optional(String.t()) => term()}, integer()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec litellm_completion(%{optional(String.t()) => term()}, integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec litellm_completion(%{optional(String.t()) => term()}, integer(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec litellm_completion(%{optional(String.t()) => term()}, integer(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def litellm_completion(request, num_retries) do
    SnakeBridge.Runtime.call(__MODULE__, :litellm_completion, [request, num_retries], [])
  end

  def litellm_completion(request, num_retries, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :litellm_completion, [request, num_retries], opts)
  end

  def litellm_completion(request, num_retries, cache) do
    SnakeBridge.Runtime.call(__MODULE__, :litellm_completion, [request, num_retries, cache], [])
  end

  def litellm_completion(request, num_retries, cache, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :litellm_completion, [request, num_retries, cache], opts)
  end

  @doc """

  """
  @spec litellm_responses_completion(%{optional(String.t()) => term()}, integer()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec litellm_responses_completion(%{optional(String.t()) => term()}, integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec litellm_responses_completion(%{optional(String.t()) => term()}, integer(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec litellm_responses_completion(
          %{optional(String.t()) => term()},
          integer(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def litellm_responses_completion(request, num_retries) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :litellm_responses_completion,
      [request, num_retries],
      []
    )
  end

  def litellm_responses_completion(request, num_retries, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :litellm_responses_completion,
      [request, num_retries],
      opts
    )
  end

  def litellm_responses_completion(request, num_retries, cache) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :litellm_responses_completion,
      [request, num_retries, cache],
      []
    )
  end

  def litellm_responses_completion(request, num_retries, cache, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :litellm_responses_completion,
      [request, num_retries, cache],
      opts
    )
  end

  @doc """

  """
  @spec litellm_text_completion(%{optional(String.t()) => term()}, integer()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec litellm_text_completion(%{optional(String.t()) => term()}, integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec litellm_text_completion(%{optional(String.t()) => term()}, integer(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec litellm_text_completion(%{optional(String.t()) => term()}, integer(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def litellm_text_completion(request, num_retries) do
    SnakeBridge.Runtime.call(__MODULE__, :litellm_text_completion, [request, num_retries], [])
  end

  def litellm_text_completion(request, num_retries, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :litellm_text_completion, [request, num_retries], opts)
  end

  def litellm_text_completion(request, num_retries, cache) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :litellm_text_completion,
      [request, num_retries, cache],
      []
    )
  end

  def litellm_text_completion(request, num_retries, cache, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :litellm_text_completion,
      [request, num_retries, cache],
      opts
    )
  end
end
