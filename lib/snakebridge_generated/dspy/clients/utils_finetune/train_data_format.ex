# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.clients.utils_finetune
# Python class: TrainDataFormat

defmodule Dspy.Clients.UtilsFinetune.TrainDataFormat do
  def __snakebridge_python_name__, do: "dspy.clients.utils_finetune"
  def __snakebridge_python_class__, do: "TrainDataFormat"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @spec format_map(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format_map(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def format_map(ref) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [], [])
  end

  def format_map(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [], opts)
  end

  def format_map(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [arg1], [])
  end

  def format_map(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [arg1], opts)
  end

  def format_map(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2], [])
  end

  def format_map(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2], opts)
  end

  def format_map(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3], [])
  end

  def format_map(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3], opts)
  end

  def format_map(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4], [])
  end

  def format_map(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4], opts)
  end

  def format_map(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def format_map(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format_map, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(
      ref,
      :format_map,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      []
    )
  end

  def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :format_map,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :format_map,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def format_map(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :format_map,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @spec isascii(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def isascii(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :isascii, [], opts)
  end

  @spec rsplit(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def rsplit(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :rsplit, [] ++ List.wrap(args), opts)
  end

  @spec title(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def title(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :title, [], opts)
  end

  @spec upper(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def upper(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :upper, [], opts)
  end

  @spec maketrans(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec maketrans(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def maketrans(ref) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [], [])
  end

  def maketrans(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [], opts)
  end

  def maketrans(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1], [])
  end

  def maketrans(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1], opts)
  end

  def maketrans(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2], [])
  end

  def maketrans(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2], opts)
  end

  def maketrans(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3], [])
  end

  def maketrans(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3], opts)
  end

  def maketrans(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4], [])
  end

  def maketrans(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4], opts)
  end

  def maketrans(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def maketrans(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :maketrans, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(
      ref,
      :maketrans,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      []
    )
  end

  def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :maketrans,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :maketrans,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def maketrans(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :maketrans,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @spec count(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec count(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def count(ref) do
    SnakeBridge.Runtime.call_method(ref, :count, [], [])
  end

  def count(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :count, [], opts)
  end

  def count(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1], [])
  end

  def count(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1], opts)
  end

  def count(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2], [])
  end

  def count(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2], opts)
  end

  def count(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3], [])
  end

  def count(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3], opts)
  end

  def count(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4], [])
  end

  def count(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4], opts)
  end

  def count(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def count(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def count(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
  end

  def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :count, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
  end

  def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :count,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def count(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :count,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @spec encode(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def encode(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :encode, [] ++ List.wrap(args), opts)
  end

  @spec isalpha(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def isalpha(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :isalpha, [], opts)
  end

  @spec casefold(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def casefold(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :casefold, [], opts)
  end

  @spec rfind(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rfind(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def rfind(ref) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [], [])
  end

  def rfind(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [], opts)
  end

  def rfind(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1], [])
  end

  def rfind(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1], opts)
  end

  def rfind(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2], [])
  end

  def rfind(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2], opts)
  end

  def rfind(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3], [])
  end

  def rfind(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3], opts)
  end

  def rfind(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4], [])
  end

  def rfind(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4], opts)
  end

  def rfind(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def rfind(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
  end

  def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rfind, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
  end

  def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :rfind,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def rfind(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :rfind,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @spec translate(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def translate(ref, table, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :translate, [table], opts)
  end

  @spec startswith(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec startswith(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def startswith(ref) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [], [])
  end

  def startswith(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [], opts)
  end

  def startswith(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [arg1], [])
  end

  def startswith(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [arg1], opts)
  end

  def startswith(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2], [])
  end

  def startswith(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2], opts)
  end

  def startswith(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3], [])
  end

  def startswith(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3], opts)
  end

  def startswith(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4], [])
  end

  def startswith(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4], opts)
  end

  def startswith(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def startswith(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :startswith, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(
      ref,
      :startswith,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      []
    )
  end

  def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :startswith,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :startswith,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def startswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :startswith,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @spec isalnum(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def isalnum(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :isalnum, [], opts)
  end

  @spec isdecimal(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def isdecimal(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :isdecimal, [], opts)
  end

  @spec isprintable(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def isprintable(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :isprintable, [], opts)
  end

  @spec rstrip(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def rstrip(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :rstrip, [] ++ List.wrap(args), opts)
  end

  @spec removeprefix(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def removeprefix(ref, prefix, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :removeprefix, [prefix], opts)
  end

  @spec split(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def split(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :split, [] ++ List.wrap(args), opts)
  end

  @spec rindex(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec rindex(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def rindex(ref) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [], [])
  end

  def rindex(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [], opts)
  end

  def rindex(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [arg1], [])
  end

  def rindex(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [arg1], opts)
  end

  def rindex(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2], [])
  end

  def rindex(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2], opts)
  end

  def rindex(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3], [])
  end

  def rindex(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3], opts)
  end

  def rindex(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4], [])
  end

  def rindex(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4], opts)
  end

  def rindex(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def rindex(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(ref, :rindex, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
  end

  def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :rindex,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :rindex,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def rindex(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :rindex,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @spec lower(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def lower(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :lower, [], opts)
  end

  @spec isspace(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def isspace(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :isspace, [], opts)
  end

  @spec expandtabs(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def expandtabs(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :expandtabs, [] ++ List.wrap(args), opts)
  end

  @spec strip(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def strip(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :strip, [] ++ List.wrap(args), opts)
  end

  @spec format(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec format(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def format(ref) do
    SnakeBridge.Runtime.call_method(ref, :format, [], [])
  end

  def format(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format, [], opts)
  end

  def format(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :format, [arg1], [])
  end

  def format(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format, [arg1], opts)
  end

  def format(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2], [])
  end

  def format(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2], opts)
  end

  def format(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3], [])
  end

  def format(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3], opts)
  end

  def format(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4], [])
  end

  def format(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4], opts)
  end

  def format(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def format(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def format(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(ref, :format, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
  end

  def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :format,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :format,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def format(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :format,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @spec removesuffix(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def removesuffix(ref, suffix, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :removesuffix, [suffix], opts)
  end

  @spec center(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def center(ref, width, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :center, [width] ++ List.wrap(args), opts)
  end

  @spec find(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec find(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def find(ref) do
    SnakeBridge.Runtime.call_method(ref, :find, [], [])
  end

  def find(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :find, [], opts)
  end

  def find(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1], [])
  end

  def find(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1], opts)
  end

  def find(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2], [])
  end

  def find(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2], opts)
  end

  def find(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3], [])
  end

  def find(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3], opts)
  end

  def find(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4], [])
  end

  def find(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4], opts)
  end

  def find(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def find(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def find(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
  end

  def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :find, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
  end

  def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :find,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def find(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :find,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @spec replace(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def replace(ref, old, new, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :replace, [old, new] ++ List.wrap(args), opts)
  end

  @spec ljust(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def ljust(ref, width, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :ljust, [width] ++ List.wrap(args), opts)
  end

  @spec istitle(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def istitle(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :istitle, [], opts)
  end

  @spec partition(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def partition(ref, sep, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :partition, [sep], opts)
  end

  @spec isupper(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def isupper(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :isupper, [], opts)
  end

  @spec endswith(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec endswith(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def endswith(ref) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [], [])
  end

  def endswith(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [], opts)
  end

  def endswith(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [arg1], [])
  end

  def endswith(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [arg1], opts)
  end

  def endswith(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2], [])
  end

  def endswith(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2], opts)
  end

  def endswith(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3], [])
  end

  def endswith(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3], opts)
  end

  def endswith(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4], [])
  end

  def endswith(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4], opts)
  end

  def endswith(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def endswith(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :endswith, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(
      ref,
      :endswith,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      []
    )
  end

  def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :endswith,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :endswith,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def endswith(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :endswith,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @spec rpartition(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def rpartition(ref, sep, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :rpartition, [sep], opts)
  end

  @spec swapcase(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def swapcase(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :swapcase, [], opts)
  end

  @spec join(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def join(ref, iterable, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :join, [iterable], opts)
  end

  @spec isdigit(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def isdigit(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :isdigit, [], opts)
  end

  @spec index(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec index(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def index(ref) do
    SnakeBridge.Runtime.call_method(ref, :index, [], [])
  end

  def index(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :index, [], opts)
  end

  def index(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1], [])
  end

  def index(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1], opts)
  end

  def index(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2], [])
  end

  def index(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2], opts)
  end

  def index(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3], [])
  end

  def index(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3], opts)
  end

  def index(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4], [])
  end

  def index(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4], opts)
  end

  def index(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def index(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def index(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], [])
  end

  def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :index, [arg1, arg2, arg3, arg4, arg5, arg6, arg7], opts)
  end

  def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :index,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def index(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :index,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @spec lstrip(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def lstrip(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :lstrip, [] ++ List.wrap(args), opts)
  end

  @spec splitlines(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def splitlines(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :splitlines, [] ++ List.wrap(args), opts)
  end

  @spec zfill(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def zfill(ref, width, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :zfill, [width], opts)
  end

  @spec islower(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def islower(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :islower, [], opts)
  end

  @spec capitalize(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def capitalize(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :capitalize, [], opts)
  end

  @spec isnumeric(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def isnumeric(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :isnumeric, [], opts)
  end

  @spec rjust(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def rjust(ref, width, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :rjust, [width] ++ List.wrap(args), opts)
  end

  @spec isidentifier(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def isidentifier(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :isidentifier, [], opts)
  end

  @spec chat(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def chat(ref) do
    SnakeBridge.Runtime.get_attr(ref, :CHAT)
  end

  @spec completion(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def completion(ref) do
    SnakeBridge.Runtime.get_attr(ref, :COMPLETION)
  end

  @spec grpo_chat(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def grpo_chat(ref) do
    SnakeBridge.Runtime.get_attr(ref, :GRPO_CHAT)
  end

  @spec name(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def name(ref) do
    SnakeBridge.Runtime.get_attr(ref, :name)
  end

  @spec value(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def value(ref) do
    SnakeBridge.Runtime.get_attr(ref, :value)
  end
end
