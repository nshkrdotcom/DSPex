# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.adapters
# Python class: Type

defmodule Dspy.Adapters.Type do
  @moduledoc """
  Base class to support creating custom types for DSPy signatures.

  This is the parent class of DSPy custom types, e.g, dspy.Image. Subclasses must implement the `format` method to
  return a list of dictionaries (same as the Array of content parts in the OpenAI API user message's content field).

  ## Examples

      ```python
      class Image(Type):
      url: str

      def format(self) -> list[dict[str, Any]]:
      return [{"type": "image_url", "image_url": {"url": self.url}}]
      ```
  """
  def __snakebridge_python_name__, do: "dspy.adapters"
  def __snakebridge_python_class__, do: "Type"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Create a new model by parsing and validating input data from keyword arguments.

  Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be
  validated to form a valid model.

  `self` is explicitly positional-only to allow `self` as a field name.

  ## Parameters

  - `data` (term())
  """
  @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
  end

  @doc """
  Extract all custom types from the annotation.

  This is used to extract all custom types from the annotation of a field, while the annotation can
  have arbitrary level of nesting. For example, we detect `Tool` is in `list[dict[str, Tool]]`.

  ## Parameters

  - `annotation` (term())

  ## Returns

  - `term()`
  """
  @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :extract_custom_type_from_annotation, [annotation], opts)
  end

  @doc """
  !!! abstract "Usage Documentation"

  JSON Parsing

  Validate the given JSON data against the Pydantic model.

  ## Parameters

  - `json_data` - The JSON data to validate.
  - `strict` - Whether to enforce types strictly.
  - `extra` - Whether to ignore, allow, or forbid extra data during model validation. See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.
  - `context` - Extra variables to pass to the validator.
  - `by_alias` - Whether to use the field's alias when validating against the provided input data.
  - `by_name` - Whether to use the field's name when validating against the provided input data.

  ## Raises

  - `ValidationError` - If `json_data` is not a JSON string or the object could not be validated.

  ## Returns

  - `term()`
  """
  @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_validate_json(ref, json_data, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
  end

  @doc """
  Python method `Type.parse_raw`.

  ## Parameters

  - `b` (term())
  - `content_type` (term())
  - `encoding` (term())
  - `proto` (term())
  - `allow_pickle` (term())

  ## Returns

  - `term()`
  """
  @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :parse_raw,
      [b, content_type, encoding, proto, allow_pickle],
      opts
    )
  end

  @doc """
  !!! abstract "Usage Documentation"

  `model_dump`

  Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

  ## Parameters

  - `mode` - The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.
  - `include` - A set of fields to include in the output.
  - `exclude` - A set of fields to exclude from the output.
  - `context` - Additional context to pass to the serializer.
  - `by_alias` - Whether to use the field's alias in the dictionary key if defined.
  - `exclude_unset` - Whether to exclude fields that have not been explicitly set.
  - `exclude_defaults` - Whether to exclude fields that are set to their default value.
  - `exclude_none` - Whether to exclude fields that have a value of `None`.
  - `exclude_computed_fields` - Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated `round_trip` parameter instead.
  - `round_trip` - If True, dumped values should be valid as input for non-idempotent types such as Json[T].
  - `warnings` - How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
  - `fallback` - A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
  - `serialize_as_any` - Whether to serialize fields with duck-typing serialization behavior.

  ## Returns

  - `%{optional(String.t()) => term()}`
  """
  @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def model_dump(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
  end

  @doc """
  Python method `Type.parse_obj`.

  ## Parameters

  - `obj` (term())

  ## Returns

  - `term()`
  """
  @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def parse_obj(ref, obj, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
  end

  @doc """
  Python method `Type._get_value`.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _get_value(ref, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
  end

  @doc """
  Python method `Type.dict`.

  ## Parameters

  - `include` ((((MapSet.t(integer()) | MapSet.t(String.t())) | term()) | term()) | nil keyword-only default: None)
  - `exclude` ((((MapSet.t(integer()) | MapSet.t(String.t())) | term()) | term()) | nil keyword-only default: None)
  - `by_alias` (boolean() keyword-only default: False)
  - `exclude_unset` (boolean() keyword-only default: False)
  - `exclude_defaults` (boolean() keyword-only default: False)
  - `exclude_none` (boolean() keyword-only default: False)

  ## Returns

  - `%{optional(String.t()) => term()}`
  """
  @spec dict(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def dict(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
  end

  @doc """
  Creates a new instance of the `Model` class with validated data.

  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
  Default values are respected, but no other validation is performed.

  !!! note
      `model_construct()` generally respects the `model_config.extra` setting on the provided model.
      That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
      and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
      Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
      an error if extra values are passed, but they will be ignored.

  ## Parameters

  - `_fields_set` - A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.
  - `values` - Trusted or pre-validated data dictionary.

  ## Returns

  - `term()`
  """
  @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_construct(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `Type._calculate_keys`.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _calculate_keys(ref, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
  end

  @doc """
  Python method `Type.schema_json`.

  ## Parameters

  - `by_alias` (boolean() keyword-only default: True)
  - `ref_template` (String.t() keyword-only default: '#/$defs/{model}')
  - `dumps_kwargs` (term())

  ## Returns

  - `String.t()`
  """
  @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def schema_json(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
  end

  @doc """
  Returns a copy of the model.

  !!! warning "Deprecated"
      This method is now deprecated; use `model_copy` instead.

  If you need `include` or `exclude`, use:

  ```python {test="skip" lint="skip"}
  data = self.model_dump(include=include, exclude=exclude, round_trip=True)
  data = {**data, **(update or {})}
  copied = self.model_validate(data)
  ```

  ## Parameters

  - `include` - Optional set or mapping specifying which fields to include in the copied model.
  - `exclude` - Optional set or mapping specifying which fields to exclude in the copied model.
  - `update` - Optional dictionary of field-value pairs to override field values in the copied model.
  - `deep` - If True, the values of fields that are Pydantic models will be deep-copied.

  ## Returns

  - `term()`
  """
  @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def copy(ref, include, exclude, update, deep, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
  end

  @doc """
  Validate the given object with string data against the Pydantic model.



  ## Parameters

  - `obj` - The object containing string data to validate.
  - `strict` - Whether to enforce types strictly.
  - `extra` - Whether to ignore, allow, or forbid extra data during model validation. See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.
  - `context` - Extra variables to pass to the validator.
  - `by_alias` - Whether to use the field's alias when validating against the provided input data.
  - `by_name` - Whether to use the field's name when validating against the provided input data.

  ## Returns

  - `term()`
  """
  @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_validate_strings(ref, obj, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
  end

  @doc """
  Try to rebuild the pydantic-core schema for the model.

  This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
  the initial attempt to build the schema, and automatic rebuilding fails.

  ## Parameters

  - `force` - Whether to force the rebuilding of the model schema, defaults to `False`.
  - `raise_errors` - Whether to raise errors, defaults to `True`.
  - `_parent_namespace_depth` - The depth level of the parent namespace, defaults to 2.
  - `_types_namespace` - The types namespace, defaults to `None`.

  ## Returns

  - `term()`
  """
  @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_rebuild(ref, force, raise_errors, parent_namespace_depth, types_namespace, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :model_rebuild,
      [force, raise_errors, parent_namespace_depth, types_namespace],
      opts
    )
  end

  @doc """
  Python method `Type._iter`.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _iter(ref, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
  end

  @doc """
  Validate a pydantic model instance.



  ## Parameters

  - `obj` - The object to validate.
  - `strict` - Whether to enforce types strictly.
  - `extra` - Whether to ignore, allow, or forbid extra data during model validation. See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.
  - `from_attributes` - Whether to extract data from object attributes.
  - `context` - Additional context to pass to the validator.
  - `by_alias` - Whether to use the field's alias when validating against the provided input data.
  - `by_name` - Whether to use the field's name when validating against the provided input data.

  ## Raises

  - `ValidationError` - If the object could not be validated.

  ## Returns

  - `term()`
  """
  @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_validate(ref, obj, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
  end

  @doc """
  !!! abstract "Usage Documentation"

  `model_dump_json`

  Generates a JSON representation of the model using Pydantic's `to_json` method.

  ## Parameters

  - `indent` - Indentation to use in the JSON output. If None is passed, the output will be compact.
  - `ensure_ascii` - If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped. If `False` (the default), these characters will be output as-is.
  - `include` - Field(s) to include in the JSON output.
  - `exclude` - Field(s) to exclude from the JSON output.
  - `context` - Additional context to pass to the serializer.
  - `by_alias` - Whether to serialize using field aliases.
  - `exclude_unset` - Whether to exclude fields that have not been explicitly set.
  - `exclude_defaults` - Whether to exclude fields that are set to their default value.
  - `exclude_none` - Whether to exclude fields that have a value of `None`.
  - `exclude_computed_fields` - Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated `round_trip` parameter instead.
  - `round_trip` - If True, dumped values should be valid as input for non-idempotent types such as Json[T].
  - `warnings` - How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
  - `fallback` - A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.
  - `serialize_as_any` - Whether to serialize fields with duck-typing serialization behavior.

  ## Returns

  - `String.t()`
  """
  @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def model_dump_json(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
  end

  @doc """
  Python method `Type.serialize_model`.

  ## Returns

  - `term()`
  """
  @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def serialize_model(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
  end

  @doc """
  Python method `Type.construct`.

  ## Parameters

  - `fields_set` (term() default: None)
  - `values` (term())

  ## Returns

  - `term()`
  """
  @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def construct(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `Type.from_orm`.

  ## Parameters

  - `obj` (term())

  ## Returns

  - `term()`
  """
  @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def from_orm(ref, obj, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
  end

  @doc """
  Adapt the custom type to the native LM feature if possible.

  When the LM and configuration supports the related native LM feature, e.g., native tool calling, native
  reasoning, etc., we adapt the signature and `lm_kwargs` to enable the native LM feature.

  ## Parameters

  - `signature` - The DSPy signature for the LM call.
  - `field_name` - The name of the field in the signature to adapt to the native LM feature.
  - `lm` - The LM instance.
  - `lm_kwargs` - The keyword arguments for the LM call, subject to in-place updates if adaptation if required.

  ## Returns

  - `term()`
  """
  @spec adapt_to_native_lm_feature(
          SnakeBridge.Ref.t(),
          term(),
          String.t(),
          term(),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :adapt_to_native_lm_feature,
      [signature, field_name, lm, lm_kwargs],
      opts
    )
  end

  @doc """
  Description of the custom type

  ## Returns

  - `String.t()`
  """
  @spec description(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def description(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :description, [], opts)
  end

  @doc """
  Python method `Type.format`.

  ## Returns

  - `term()`
  """
  @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def format(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :format, [], opts)
  end

  @doc """
  Python method `Type._copy_and_set_values`.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
  end

  @doc """
  Parse a LM response into the custom type.



  ## Parameters

  - `response` - A LM response.

  ## Returns

  - `term() | nil`
  """
  @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term() | nil} | {:error, Snakepit.Error.t()}
  def parse_lm_response(ref, response, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
  end

  @doc """
  Whether the custom type is streamable.

  ## Returns

  - `boolean()`
  """
  @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_streamable(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
  end

  @doc """
  Override this method to perform additional initialization after `__init__` and `model_construct`.

  This is useful if you want to do some validation that requires the entire model to be initialized.

  ## Parameters

  - `context` (term())

  ## Returns

  - `nil`
  """
  @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def model_post_init(ref, context, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
  end

  @doc """
  Parse a stream chunk into the custom type.



  ## Parameters

  - `chunk` - A stream chunk.

  ## Returns

  - `term() | nil`
  """
  @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term() | nil} | {:error, Snakepit.Error.t()}
  def parse_stream_chunk(ref, chunk, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
  end

  @doc """
  Compute the class name for parametrizations of generic classes.

  This method can be overridden to achieve a custom naming scheme for generic BaseModels.

  ## Parameters

  - `params` - Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

  ## Raises

  - `ArgumentError` - Raised when trying to generate concrete names for non-generic models.

  ## Returns

  - `String.t()`
  """
  @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def model_parametrized_name(ref, params, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
  end

  @doc """
  Python method `Type.json`.

  ## Parameters

  - `include` ((((MapSet.t(integer()) | MapSet.t(String.t())) | term()) | term()) | nil keyword-only default: None)
  - `exclude` ((((MapSet.t(integer()) | MapSet.t(String.t())) | term()) | term()) | nil keyword-only default: None)
  - `by_alias` (boolean() keyword-only default: False)
  - `exclude_unset` (boolean() keyword-only default: False)
  - `exclude_defaults` (boolean() keyword-only default: False)
  - `exclude_none` (boolean() keyword-only default: False)
  - `encoder` (term() | nil keyword-only default: PydanticUndefined)
  - `models_as_dict` (boolean() keyword-only default: PydanticUndefined)
  - `dumps_kwargs` (term())

  ## Returns

  - `String.t()`
  """
  @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def json(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :json, [], opts)
  end

  @doc """
  Generates a JSON schema for a model class.



  ## Parameters

  - `by_alias` - Whether to use attribute aliases or not.
  - `ref_template` - The reference template.
  - `union_format` - The format to use when combining schemas from unions together. Can be one of:
  - `schema_generator` - To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications
  - `mode` - The mode in which to generate the schema.

  ## Returns

  - `%{optional(String.t()) => term()}`
  """
  @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def model_json_schema(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
  end

  @doc """
  !!! abstract "Usage Documentation"

  `model_copy`

  Returns a copy of the model.

  !!! note
      The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
      might have unexpected side effects if you store anything in it, on top of the model
      fields (e.g. the value of [cached properties][functools.cached_property]).

  ## Parameters

  - `update` - Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.
  - `deep` - Set to `True` to make a deep copy of the model.

  ## Returns

  - `term()`
  """
  @spec model_copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_copy(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
  end

  @doc """
  Python method `Type.validate`.

  ## Parameters

  - `value` (term())

  ## Returns

  - `term()`
  """
  @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def validate(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
  end

  @doc """
  Python method `Type.schema`.

  ## Parameters

  - `by_alias` (boolean() default: True)
  - `ref_template` (String.t() default: '#/$defs/{model}')

  ## Returns

  - `%{optional(String.t()) => term()}`
  """
  @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def schema(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
  end

  @doc """
  Get a handler for setting an attribute on the model instance.

  ## Parameters

  - `name` (String.t())
  - `value` (term())

  ## Returns

  - `term() | nil`
  """
  @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
          {:ok, term() | nil} | {:error, Snakepit.Error.t()}
  def _setattr_handler(ref, name, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
  end

  @doc """
  Python method `Type.update_forward_refs`.

  ## Parameters

  - `localns` (term())

  ## Returns

  - `nil`
  """
  @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def update_forward_refs(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
  end

  @doc """
  Python method `Type.parse_file`.

  ## Parameters

  - `path` (term())
  - `content_type` (term())
  - `encoding` (term())
  - `proto` (term())
  - `allow_pickle` (term())

  ## Returns

  - `term()`
  """
  @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :parse_file,
      [path, content_type, encoding, proto, allow_pickle],
      opts
    )
  end

  @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _abc_impl(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
  end

  @spec model_computed_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_computed_fields(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
  end

  @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_config(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_config)
  end

  @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_extra(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_extra)
  end

  @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_fields(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_fields)
  end

  @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_fields_set(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
  end
end
