# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy
# Python class: JSONAdapter

defmodule Dspy.JSONAdapter do
  def __snakebridge_python_name__, do: "dspy"
  def __snakebridge_python_class__, do: "JSONAdapter"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @spec _call_postprocess(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          list(term()),
          term(),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
  def _call_postprocess(
        ref,
        processed_signature,
        original_signature,
        outputs,
        lm,
        lm_kwargs,
        opts \\ []
      ) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_call_postprocess,
      [processed_signature, original_signature, outputs, lm, lm_kwargs],
      opts
    )
  end

  @spec _call_preprocess(
          SnakeBridge.Ref.t(),
          term(),
          %{optional(String.t()) => term()},
          term(),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _call_preprocess(ref, lm, lm_kwargs, signature, inputs, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_call_preprocess,
      [lm, lm_kwargs, signature, inputs],
      opts
    )
  end

  @spec _get_history_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def _get_history_field_name(ref, signature, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_history_field_name, [signature], opts)
  end

  @spec _get_tool_call_input_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def _get_tool_call_input_field_name(ref, signature, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_tool_call_input_field_name, [signature], opts)
  end

  @spec _get_tool_call_output_field_name(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def _get_tool_call_output_field_name(ref, signature, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_tool_call_output_field_name, [signature], opts)
  end

  @spec _json_adapter_call_common(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _json_adapter_call_common(ref, lm, lm_kwargs, signature, demos, inputs, call_fn, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_json_adapter_call_common,
      [lm, lm_kwargs, signature, demos, inputs, call_fn],
      opts
    )
  end

  @spec acall(
          SnakeBridge.Ref.t(),
          Dspy.Clients.LMClass.t(),
          %{optional(String.t()) => term()},
          term(),
          list(%{optional(String.t()) => term()}),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
  def acall(ref, lm, lm_kwargs, signature, demos, inputs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :acall, [lm, lm_kwargs, signature, demos, inputs], opts)
  end

  @spec format(
          SnakeBridge.Ref.t(),
          term(),
          list(%{optional(String.t()) => term()}),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
  def format(ref, signature, demos, inputs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :format, [signature, demos, inputs], opts)
  end

  @spec format_assistant_message_content(
          SnakeBridge.Ref.t(),
          term(),
          %{optional(String.t()) => term()},
          list(term()),
          keyword()
        ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def format_assistant_message_content(ref, signature, outputs, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :format_assistant_message_content,
      [signature, outputs] ++ List.wrap(args),
      opts
    )
  end

  @spec format_conversation_history(
          SnakeBridge.Ref.t(),
          term(),
          String.t(),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
  def format_conversation_history(ref, signature, history_field_name, inputs, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :format_conversation_history,
      [signature, history_field_name, inputs],
      opts
    )
  end

  @spec format_demos(
          SnakeBridge.Ref.t(),
          term(),
          list(%{optional(String.t()) => term()}),
          keyword()
        ) :: {:ok, list(%{optional(String.t()) => term()})} | {:error, Snakepit.Error.t()}
  def format_demos(ref, signature, demos, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :format_demos, [signature, demos], opts)
  end

  @spec format_field_description(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def format_field_description(ref, signature, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :format_field_description, [signature], opts)
  end

  @spec format_field_structure(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def format_field_structure(ref, signature, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :format_field_structure, [signature], opts)
  end

  @spec format_field_with_value(
          SnakeBridge.Ref.t(),
          %{optional(Dspy.Adapters.ChatAdapter.FieldInfoWithName.t()) => term()},
          list(term()),
          keyword()
        ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def format_field_with_value(ref, fields_with_values, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :format_field_with_value,
      [fields_with_values] ++ List.wrap(args),
      opts
    )
  end

  @spec format_finetune_data(
          SnakeBridge.Ref.t(),
          term(),
          list(%{optional(String.t()) => term()}),
          %{optional(String.t()) => term()},
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, %{optional(String.t()) => list(term())}} | {:error, Snakepit.Error.t()}
  def format_finetune_data(ref, signature, demos, inputs, outputs, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :format_finetune_data,
      [signature, demos, inputs, outputs],
      opts
    )
  end

  @spec format_system_message(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def format_system_message(ref, signature, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :format_system_message, [signature], opts)
  end

  @spec format_task_description(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def format_task_description(ref, signature, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :format_task_description, [signature], opts)
  end

  @spec format_user_message_content(
          SnakeBridge.Ref.t(),
          term(),
          %{optional(String.t()) => term()},
          list(term()),
          keyword()
        ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def format_user_message_content(ref, signature, inputs, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :format_user_message_content,
      [signature, inputs] ++ List.wrap(args),
      opts
    )
  end

  @spec parse(SnakeBridge.Ref.t(), term(), String.t(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def parse(ref, signature, completion, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :parse, [signature, completion], opts)
  end

  @spec user_message_output_requirements(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def user_message_output_requirements(ref, signature, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :user_message_output_requirements, [signature], opts)
  end
end
