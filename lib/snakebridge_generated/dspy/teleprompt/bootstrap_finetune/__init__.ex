# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.teleprompt.bootstrap_finetune

defmodule Dspy.Teleprompt.BootstrapFinetune do
  @moduledoc """
  Submodule bindings for `dspy.teleprompt.bootstrap_finetune`.
  """

  def __snakebridge_python_name__, do: "dspy.teleprompt.bootstrap_finetune"
  def __snakebridge_library__, do: "dspy"

  @doc """
  Return True if all predictors in the program have an LM set.

  Parameters:
  - `program` (Dspy.Primitives.Module.Module.t())

  Returns:
  - `boolean()`
  """
  @spec all_predictors_have_lms(Dspy.Primitives.Module.Module.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def all_predictors_have_lms(program, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :all_predictors_have_lms, [program], opts)
  end

  @doc """

  """
  @spec assert_no_shared_predictor(
          Dspy.Primitives.Module.Module.t(),
          Dspy.Primitives.Module.Module.t(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def assert_no_shared_predictor(program1, program2, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :assert_no_shared_predictor, [program1, program2], opts)
  end

  @doc """

  """
  @spec assert_structural_equivalency(term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def assert_structural_equivalency(program1, program2, opts \\ []) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :assert_structural_equivalency,
      [program1, program2],
      opts
    )
  end

  @doc """

  """
  @spec build_call_data_from_trace(
          list(%{optional(term()) => term()}),
          integer(),
          Dspy.Adapters.Base.Adapter.t()
        ) ::
          {:ok, %{optional(String.t()) => list(%{optional(String.t()) => term()})}}
          | {:error, Snakepit.Error.t()}
  @spec build_call_data_from_trace(
          list(%{optional(term()) => term()}),
          integer(),
          Dspy.Adapters.Base.Adapter.t(),
          keyword()
        ) ::
          {:ok, %{optional(String.t()) => list(%{optional(String.t()) => term()})}}
          | {:error, Snakepit.Error.t()}
  @spec build_call_data_from_trace(
          list(%{optional(term()) => term()}),
          integer(),
          Dspy.Adapters.Base.Adapter.t(),
          boolean()
        ) ::
          {:ok, %{optional(String.t()) => list(%{optional(String.t()) => term()})}}
          | {:error, Snakepit.Error.t()}
  @spec build_call_data_from_trace(
          list(%{optional(term()) => term()}),
          integer(),
          Dspy.Adapters.Base.Adapter.t(),
          boolean(),
          keyword()
        ) ::
          {:ok, %{optional(String.t()) => list(%{optional(String.t()) => term()})}}
          | {:error, Snakepit.Error.t()}
  def build_call_data_from_trace(trace, pred_ind, adapter) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :build_call_data_from_trace,
      [trace, pred_ind, adapter],
      []
    )
  end

  def build_call_data_from_trace(trace, pred_ind, adapter, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :build_call_data_from_trace,
      [trace, pred_ind, adapter],
      opts
    )
  end

  def build_call_data_from_trace(trace, pred_ind, adapter, exclude_demos) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :build_call_data_from_trace,
      [trace, pred_ind, adapter, exclude_demos],
      []
    )
  end

  def build_call_data_from_trace(trace, pred_ind, adapter, exclude_demos, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :build_call_data_from_trace,
      [trace, pred_ind, adapter, exclude_demos],
      opts
    )
  end

  @doc """

  """
  @spec copy_program_with_lms(Dspy.Primitives.Module.Module.t(), keyword()) ::
          {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
  def copy_program_with_lms(program, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :copy_program_with_lms, [program], opts)
  end

  @doc """

  """
  @spec get_unique_lms(Dspy.Primitives.Module.Module.t(), keyword()) ::
          {:ok, list(Dspy.Clients.LMClass.t())} | {:error, Snakepit.Error.t()}
  def get_unique_lms(program, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_unique_lms, [program], opts)
  end

  @doc """

  """
  @spec kill_lms(Dspy.Primitives.Module.Module.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def kill_lms(program, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :kill_lms, [program], opts)
  end

  @doc """

  """
  @spec launch_lms(Dspy.Primitives.Module.Module.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def launch_lms(program, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :launch_lms, [program], opts)
  end

  @doc """

  """
  @spec prepare_student(Dspy.Primitives.Module.Module.t(), keyword()) ::
          {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
  def prepare_student(student, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :prepare_student, [student], opts)
  end

  @doc """

  """
  @spec prepare_teacher(Dspy.Primitives.Module.Module.t()) ::
          {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
  @spec prepare_teacher(Dspy.Primitives.Module.Module.t(), keyword()) ::
          {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
  @spec prepare_teacher(Dspy.Primitives.Module.Module.t(), term()) ::
          {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
  @spec prepare_teacher(Dspy.Primitives.Module.Module.t(), term(), keyword()) ::
          {:ok, Dspy.Primitives.Module.Module.t()} | {:error, Snakepit.Error.t()}
  def prepare_teacher(student) do
    SnakeBridge.Runtime.call(__MODULE__, :prepare_teacher, [student], [])
  end

  def prepare_teacher(student, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :prepare_teacher, [student], opts)
  end

  def prepare_teacher(student, teacher) do
    SnakeBridge.Runtime.call(__MODULE__, :prepare_teacher, [student, teacher], [])
  end

  def prepare_teacher(student, teacher, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :prepare_teacher, [student, teacher], opts)
  end
end
