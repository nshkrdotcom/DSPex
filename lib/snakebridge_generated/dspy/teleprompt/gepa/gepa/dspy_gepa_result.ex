# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.teleprompt.gepa.gepa
# Python class: DspyGEPAResult

defmodule Dspy.Teleprompt.Gepa.Gepa.DspyGEPAResult do
  def __snakebridge_python_name__, do: "dspy.teleprompt.gepa.gepa"
  def __snakebridge_python_class__, do: "DspyGEPAResult"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @spec new(
          list(Dspy.Primitives.Module.Module.t()),
          list(list(term())),
          list(float()),
          list(list(float())),
          list(MapSet.t(integer())),
          list(integer()),
          list(term()),
          keyword()
        ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(
        candidates,
        parents,
        val_aggregate_scores,
        val_subscores,
        per_val_instance_best_candidates,
        discovery_eval_counts,
        args,
        opts \\ []
      ) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_class(
      __MODULE__,
      :__init__,
      [
        candidates,
        parents,
        val_aggregate_scores,
        val_subscores,
        per_val_instance_best_candidates,
        discovery_eval_counts
      ] ++ List.wrap(args),
      opts
    )
  end

  @spec from_gepa_result(
          SnakeBridge.Ref.t(),
          term(),
          Dspy.Teleprompt.Gepa.GepaUtils.DspyAdapter.t(),
          keyword()
        ) :: {:ok, Dspy.Teleprompt.Gepa.Gepa.DspyGEPAResult.t()} | {:error, Snakepit.Error.t()}
  def from_gepa_result(ref, gepa_result, adapter, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :from_gepa_result, [gepa_result, adapter], opts)
  end

  @spec to_dict(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def to_dict(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :to_dict, [], opts)
  end

  @spec best_candidate(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def best_candidate(ref) do
    SnakeBridge.Runtime.get_attr(ref, :best_candidate)
  end

  @spec best_idx(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def best_idx(ref) do
    SnakeBridge.Runtime.get_attr(ref, :best_idx)
  end

  @spec best_outputs_valset(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def best_outputs_valset(ref) do
    SnakeBridge.Runtime.get_attr(ref, :best_outputs_valset)
  end

  @spec highest_score_achieved_per_val_task(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def highest_score_achieved_per_val_task(ref) do
    SnakeBridge.Runtime.get_attr(ref, :highest_score_achieved_per_val_task)
  end

  @spec log_dir(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def log_dir(ref) do
    SnakeBridge.Runtime.get_attr(ref, :log_dir)
  end

  @spec num_full_val_evals(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def num_full_val_evals(ref) do
    SnakeBridge.Runtime.get_attr(ref, :num_full_val_evals)
  end

  @spec seed(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def seed(ref) do
    SnakeBridge.Runtime.get_attr(ref, :seed)
  end

  @spec total_metric_calls(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def total_metric_calls(ref) do
    SnakeBridge.Runtime.get_attr(ref, :total_metric_calls)
  end
end
