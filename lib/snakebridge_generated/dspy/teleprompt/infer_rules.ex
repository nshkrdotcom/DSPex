# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.teleprompt
# Python class: InferRules

defmodule Dspy.Teleprompt.InferRules do
  @moduledoc """
  Wrapper for Python class InferRules.
  """
  def __snakebridge_python_name__, do: "dspy.teleprompt"
  def __snakebridge_python_class__, do: "InferRules"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  A Teleprompter class that composes a set of demos/examples to go into a predictor's prompt.

  These demos come from a combination of labeled examples in the training set, and bootstrapped demos.

  Each bootstrap round copies the LM with a new ``rollout_id`` at ``temperature=1.0`` to
  bypass caches and gather diverse traces.

  ## Parameters

  - `metric` - A function that compares an expected value and predicted value, outputting the result of that comparison. (type: `Callable`)
  - `metric_threshold` - If the metric yields a numerical value, then check it against this threshold when deciding whether or not to accept a bootstrap example. Defaults to None. (type: `float()`)
  - `teacher_settings` - Settings for the `teacher` model. Defaults to None. (type: `map()`)
  - `max_bootstrapped_demos` - Maximum number of bootstrapped demonstrations to include. Defaults to 4. (type: `integer()`)
  - `max_labeled_demos` - Maximum number of labeled demonstrations to include. Defaults to 16. (type: `integer()`)
  - `max_rounds` - Number of iterations to attempt generating the required bootstrap examples. If unsuccessful after `max_rounds`, the program ends. Defaults to 1. (type: `integer()`)
  - `max_errors` - Maximum number of errors until program ends. If ``None``, inherits from ``dspy.settings.max_errors``. (type: `integer() | nil`)
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `InferRules._bootstrap`.

  ## Parameters

  - `max_bootstraps` (term() keyword-only default: None)

  ## Returns

  - `term()`
  """
  @spec _bootstrap(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _bootstrap(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_bootstrap, [], opts)
  end

  @doc """
  Python method `InferRules._bootstrap_one_example`.

  ## Parameters

  - `example` (term())
  - `round_idx` (term() default: 0)

  ## Returns

  - `term()`
  """
  @spec _bootstrap_one_example(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _bootstrap_one_example(ref, example, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :_bootstrap_one_example,
      [example] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Python method `InferRules._prepare_predictor_mappings`.

  ## Returns

  - `term()`
  """
  @spec _prepare_predictor_mappings(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _prepare_predictor_mappings(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_prepare_predictor_mappings, [], opts)
  end

  @doc """
  Python method `InferRules._prepare_student_and_teacher`.

  ## Parameters

  - `student` (term())
  - `teacher` (term())

  ## Returns

  - `term()`
  """
  @spec _prepare_student_and_teacher(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _prepare_student_and_teacher(ref, student, teacher, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_prepare_student_and_teacher, [student, teacher], opts)
  end

  @doc """
  Python method `InferRules._train`.

  ## Returns

  - `term()`
  """
  @spec _train(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _train(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_train, [], opts)
  end

  @doc """
  Optimize the student program.



  ## Parameters

  - `student` - The student program to optimize.
  - `trainset` - The training set to use for optimization.
  - `teacher` - The teacher program to use for optimization.
  - `valset` - The validation set to use for optimization.

  ## Returns

  - `term()`
  """
  @spec compile(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def compile(ref, student, opts \\ []) do
    kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
    missing_kw = ["trainset"] |> Enum.reject(&(&1 in kw_keys))

    if missing_kw != [] do
      raise ArgumentError,
            "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
    end

    SnakeBridge.Runtime.call_method(ref, :compile, [student], opts)
  end

  @doc """
  Python method `InferRules.evaluate_program`.

  ## Parameters

  - `program` (term())
  - `dataset` (term())

  ## Returns

  - `term()`
  """
  @spec evaluate_program(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def evaluate_program(ref, program, dataset, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :evaluate_program, [program, dataset], opts)
  end

  @doc """
  Python method `InferRules.format_examples`.

  ## Parameters

  - `demos` (term())
  - `signature` (term())

  ## Returns

  - `term()`
  """
  @spec format_examples(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def format_examples(ref, demos, signature, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :format_examples, [demos, signature], opts)
  end

  @doc """
  Get the parameters of the teleprompter.

  ## Returns

  - `%{optional(String.t()) => term()}`
  """
  @spec get_params(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def get_params(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_params, [], opts)
  end

  @doc """
  Python method `InferRules.get_predictor_demos`.

  ## Parameters

  - `trainset` (term())
  - `predictor` (term())

  ## Returns

  - `term()`
  """
  @spec get_predictor_demos(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_predictor_demos(ref, trainset, predictor, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_predictor_demos, [trainset, predictor], opts)
  end

  @doc """
  Python method `InferRules.induce_natural_language_rules`.

  ## Parameters

  - `predictor` (term())
  - `trainset` (term())

  ## Returns

  - `term()`
  """
  @spec induce_natural_language_rules(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def induce_natural_language_rules(ref, predictor, trainset, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :induce_natural_language_rules,
      [predictor, trainset],
      opts
    )
  end

  @doc """
  Python method `InferRules.update_program_instructions`.

  ## Parameters

  - `predictor` (term())
  - `natural_language_rules` (term())

  ## Returns

  - `term()`
  """
  @spec update_program_instructions(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def update_program_instructions(ref, predictor, natural_language_rules, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :update_program_instructions,
      [predictor, natural_language_rules],
      opts
    )
  end
end
