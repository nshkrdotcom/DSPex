# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy
# Python class: Image

defmodule Dspy.Image do
  def __snakebridge_python_name__, do: "dspy"
  def __snakebridge_python_class__, do: "Image"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @spec extract_custom_type_from_annotation(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def extract_custom_type_from_annotation(ref, annotation, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :extract_custom_type_from_annotation, [annotation], opts)
  end

  @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_validate_json(ref, json_data, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
  end

  @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :parse_raw,
      [b, content_type, encoding, proto, allow_pickle],
      opts
    )
  end

  @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def model_dump(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
  end

  @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def parse_obj(ref, obj, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
  end

  @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _get_value(ref, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
  end

  @spec dict(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def dict(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
  end

  @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_construct(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
  end

  @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _calculate_keys(ref, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
  end

  @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def schema_json(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
  end

  @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def copy(ref, include, exclude, update, deep, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
  end

  @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_validate_strings(ref, obj, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
  end

  @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_rebuild(ref, force, raise_errors, parent_namespace_depth, types_namespace, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :model_rebuild,
      [force, raise_errors, parent_namespace_depth, types_namespace],
      opts
    )
  end

  @spec from_pil(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def from_pil(ref, pil_image, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "from_PIL", [pil_image], opts)
  end

  @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _iter(ref, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
  end

  @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_validate(ref, obj, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
  end

  @spec from_file(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def from_file(ref, file_path, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :from_file, [file_path], opts)
  end

  @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def model_dump_json(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
  end

  @spec serialize_model(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def serialize_model(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :serialize_model, [], opts)
  end

  @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def construct(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
  end

  @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def from_orm(ref, obj, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
  end

  @spec adapt_to_native_lm_feature(
          SnakeBridge.Ref.t(),
          term(),
          String.t(),
          term(),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def adapt_to_native_lm_feature(ref, signature, field_name, lm, lm_kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :adapt_to_native_lm_feature,
      [signature, field_name, lm, lm_kwargs],
      opts
    )
  end

  @spec description(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def description(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :description, [], opts)
  end

  @spec format(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def format(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :format, [], opts)
  end

  @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
  end

  @spec from_url(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def from_url(ref, url, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :from_url, [url] ++ List.wrap(args), opts)
  end

  @spec parse_lm_response(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
  def parse_lm_response(ref, response, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :parse_lm_response, [response], opts)
  end

  @spec is_streamable(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_streamable(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_streamable, [], opts)
  end

  @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def model_post_init(ref, context, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
  end

  @spec parse_stream_chunk(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, Dspy.Adapters.Types.BaseType.Type.t() | nil} | {:error, Snakepit.Error.t()}
  def parse_stream_chunk(ref, chunk, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :parse_stream_chunk, [chunk], opts)
  end

  @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def model_parametrized_name(ref, params, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
  end

  @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def json(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :json, [], opts)
  end

  @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def model_json_schema(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
  end

  @spec model_copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_copy(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
  end

  @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def validate(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
  end

  @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def schema(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
  end

  @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
          {:ok, term() | nil} | {:error, Snakepit.Error.t()}
  def _setattr_handler(ref, name, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
  end

  @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def update_forward_refs(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
  end

  @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :parse_file,
      [path, content_type, encoding, proto, allow_pickle],
      opts
    )
  end

  @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _abc_impl(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
  end

  @spec model_computed_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_computed_fields(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
  end

  @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_config(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_config)
  end

  @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_extra(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_extra)
  end

  @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_fields(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_fields)
  end

  @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_fields_set(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
  end
end
