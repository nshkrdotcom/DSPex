# Generated by SnakeBridge v0.13.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy
# Python class: Predict

defmodule Dspy.PredictClass do
  @moduledoc """
  Basic DSPy module that maps inputs to outputs using a language model.



  ## Parameters

  - `signature` - The input/output signature describing the task.
  - `callbacks` - Optional list of callbacks for instrumentation. **config: Default keyword arguments forwarded to the underlying language model. These values can be overridden for a single invocation by passing a ``config`` dictionary when calling the module. For example::
  """
  def __snakebridge_python_name__, do: "dspy"
  def __snakebridge_python_class__, do: "Predict"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `signature` (term())
  - `callbacks` (term() default: None)
  - `config` (term())
  """
  @spec new(term(), list(term()), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(signature, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [signature] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `Predict._base_init`.

  ## Returns

  - `term()`
  """
  @spec _base_init(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _base_init(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_base_init, [], opts)
  end

  @doc """
  Python method `Predict._forward_postprocess`.

  ## Parameters

  - `completions` (term())
  - `signature` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec _forward_postprocess(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _forward_postprocess(ref, completions, signature, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_forward_postprocess, [completions, signature], opts)
  end

  @doc """
  Python method `Predict._forward_preprocess`.

  ## Parameters

  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec _forward_preprocess(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _forward_preprocess(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_forward_preprocess, [], opts)
  end

  @doc """
  Python method `Predict._get_positional_args_error_message`.

  ## Returns

  - `term()`
  """
  @spec _get_positional_args_error_message(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _get_positional_args_error_message(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_positional_args_error_message, [], opts)
  end

  @doc """
  Python method `Predict._set_lm_usage`.

  ## Parameters

  - `tokens` (%{optional(String.t()) => term()})
  - `output` (term())

  ## Returns

  - `term()`
  """
  @spec _set_lm_usage(SnakeBridge.Ref.t(), %{optional(String.t()) => term()}, term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _set_lm_usage(ref, tokens, output, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_set_lm_usage, [tokens, output], opts)
  end

  @doc """
  Python method `Predict._should_stream`.

  ## Returns

  - `term()`
  """
  @spec _should_stream(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _should_stream(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_should_stream, [], opts)
  end

  @doc """
  Python method `Predict.acall`.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec acall(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def acall(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :acall, [] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `Predict.aforward`.

  ## Parameters

  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec aforward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def aforward(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :aforward, [], opts)
  end

  @doc """
  Processes a list of dspy.Example instances in parallel using the Parallel module.



  ## Parameters

  - `examples` - List of dspy.Example instances to process.
  - `num_threads` - Number of threads to use for parallel processing.
  - `max_errors` - Maximum number of errors allowed before stopping execution. If ``None``, inherits from ``dspy.settings.max_errors``.
  - `return_failed_examples` - Whether to return failed examples and exceptions.
  - `provide_traceback` - Whether to include traceback information in error logs.
  - `disable_progress_bar` - Whether to display the progress bar.
  - `timeout` - Seconds before a straggler task is resubmitted. Set to 0 to disable.
  - `straggler_limit` - Only check for stragglers when this many or fewer tasks remain.

  ## Returns

  - `term()`
  """
  @spec batch(SnakeBridge.Ref.t(), list(Dspy.Primitives.Example.t()), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def batch(ref, examples, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :batch, [examples] ++ List.wrap(args), opts)
  end

  @doc """
  Deep copy the module.

  This is a tweak to the default python deepcopy that only deep copies `self.parameters()`, and for other
  attributes, we just do the shallow copy.

  ## Returns

  - `term()`
  """
  @spec deepcopy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def deepcopy(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :deepcopy, [], opts)
  end

  @doc """
  Python method `Predict.dump_state`.

  ## Parameters

  - `json_mode` (term() default: True)

  ## Returns

  - `term()`
  """
  @spec dump_state(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def dump_state(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :dump_state, [] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `Predict.forward`.

  ## Parameters

  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec forward(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def forward(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :forward, [], opts)
  end

  @doc """
  Python method `Predict.get_config`.

  ## Returns

  - `term()`
  """
  @spec get_config(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_config(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_config, [], opts)
  end

  @doc """
  Python method `Predict.get_lm`.

  ## Returns

  - `term()`
  """
  @spec get_lm(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_lm(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_lm, [], opts)
  end

  @doc """
  Python method `Predict.inspect_history`.

  ## Parameters

  - `n` (integer() default: 1)

  ## Returns

  - `term()`
  """
  @spec inspect_history(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def inspect_history(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :inspect_history, [] ++ List.wrap(args), opts)
  end

  @doc """
  Load the saved module. You may also want to check out dspy.load, if you want to

  load an entire program, not just the state for an existing program.

  ## Parameters

  - `path` - Path to the saved state file, which should be a .json or a .pkl file (type: `String.t()`)
  - `allow_pickle` - If True, allow loading .pkl files, which can run arbitrary code. This is dangerous and should only be used if you are sure about the source of the file and in a trusted environment. (type: `boolean()`)

  ## Returns

  - `term()`
  """
  @spec load(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def load(ref, path, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :load, [path] ++ List.wrap(args), opts)
  end

  @doc """
  Load the saved state of a `Predict` object.



  ## Parameters

  - `state` - The saved state of a `Predict` object.

  ## Returns

  - `Dspy.Predict.Predict.Predict.t()`
  """
  @spec load_state(SnakeBridge.Ref.t(), %{optional(term()) => term()}, keyword()) ::
          {:ok, Dspy.Predict.Predict.Predict.t()} | {:error, Snakepit.Error.t()}
  def load_state(ref, state, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
  end

  @doc """
  Applies a function to all named predictors.

  ## Parameters

  - `func` (term())

  ## Returns

  - `term()`
  """
  @spec map_named_predictors(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def map_named_predictors(ref, func, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :map_named_predictors, [func], opts)
  end

  @doc """
  Unlike PyTorch, handles (non-recursive) lists of parameters too.

  ## Returns

  - `term()`
  """
  @spec named_parameters(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def named_parameters(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :named_parameters, [], opts)
  end

  @doc """
  Python method `Predict.named_predictors`.

  ## Returns

  - `term()`
  """
  @spec named_predictors(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def named_predictors(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :named_predictors, [], opts)
  end

  @doc """
  Find all sub-modules in the module, as well as their names.

  Say `self.children[4]['key'].sub_module` is a sub-module. Then the name will be
  `children[4]['key'].sub_module`. But if the sub-module is accessible at different
  paths, only one of the paths will be returned.

  ## Parameters

  - `type_` (term() default: None)
  - `skip_compiled` (term() default: False)

  ## Returns

  - `term()`
  """
  @spec named_sub_modules(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def named_sub_modules(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :named_sub_modules, [] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `Predict.parameters`.

  ## Returns

  - `term()`
  """
  @spec parameters(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def parameters(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :parameters, [], opts)
  end

  @doc """
  Python method `Predict.predictors`.

  ## Returns

  - `term()`
  """
  @spec predictors(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def predictors(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :predictors, [], opts)
  end

  @doc """
  Python method `Predict.reset`.

  ## Returns

  - `term()`
  """
  @spec reset(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def reset(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :reset, [], opts)
  end

  @doc """
  Deep copy the module and reset all parameters.

  ## Returns

  - `term()`
  """
  @spec reset_copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def reset_copy(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :reset_copy, [], opts)
  end

  @doc """
  Save the module.

  Save the module to a directory or a file. There are two modes:
  - `save_program=False`: Save only the state of the module to a json or pickle file, based on the value of
      the file extension.
  - `save_program=True`: Save the whole module to a directory via cloudpickle, which contains both the state and
      architecture of the model.

  If `save_program=True` and `modules_to_serialize` are provided, it will register those modules for serialization
  with cloudpickle's `register_pickle_by_value`. This causes cloudpickle to serialize the module by value rather
  than by reference, ensuring the module is fully preserved along with the saved program. This is useful
  when you have custom modules that need to be serialized alongside your program. If None, then no modules
  will be registered for serialization.

  We also save the dependency versions, so that the loaded model can check if there is a version mismatch on
  critical dependencies or DSPy version.

  ## Parameters

  - `path` - Path to the saved state file, which should be a .json or .pkl file when `save_program=False`, and a directory when `save_program=True`. (type: `String.t()`)
  - `save_program` - If True, save the whole module to a directory via cloudpickle, otherwise only save the state. (type: `boolean()`)
  - `modules_to_serialize` - A list of modules to serialize with cloudpickle's `register_pickle_by_value`. If None, then no modules will be registered for serialization. (type: `list()`)

  ## Returns

  - `term()`
  """
  @spec save(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def save(ref, path, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :save, [path] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `Predict.set_lm`.

  ## Parameters

  - `lm` (term())

  ## Returns

  - `term()`
  """
  @spec set_lm(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def set_lm(ref, lm, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :set_lm, [lm], opts)
  end

  @doc """
  Python method `Predict.update_config`.

  ## Parameters

  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec update_config(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def update_config(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :update_config, [], opts)
  end
end
