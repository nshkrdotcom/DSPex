# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.streaming
# Python class: StreamListener

defmodule Dspy.Streaming.StreamListener do
  def __snakebridge_python_name__, do: "dspy.streaming"
  def __snakebridge_python_class__, do: "StreamListener"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @spec new(String.t(), list(term()), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(signature_field_name, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_class(
      __MODULE__,
      :__init__,
      [signature_field_name] ++ List.wrap(args),
      opts
    )
  end

  @spec _buffered_message_end_with_start_identifier(
          SnakeBridge.Ref.t(),
          String.t(),
          String.t(),
          keyword()
        ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def _buffered_message_end_with_start_identifier(
        ref,
        concat_message,
        start_identifier,
        opts \\ []
      ) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_buffered_message_end_with_start_identifier,
      [concat_message, start_identifier],
      opts
    )
  end

  @spec _could_form_end_identifier(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def _could_form_end_identifier(ref, concat_message, adapter_name, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_could_form_end_identifier,
      [concat_message, adapter_name],
      opts
    )
  end

  @spec _default_handle_stream_chunk(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _default_handle_stream_chunk(ref, token, end_identifier, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_default_handle_stream_chunk,
      [token, end_identifier],
      opts
    )
  end

  @spec _json_adapter_handle_stream_chunk(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _json_adapter_handle_stream_chunk(ref, token, chunk_message, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_json_adapter_handle_stream_chunk,
      [token, chunk_message],
      opts
    )
  end

  @spec finalize(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def finalize(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :finalize, [], opts)
  end

  @spec flush(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def flush(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :flush, [], opts)
  end

  @spec py_receive(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def py_receive(ref, chunk, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "receive", [chunk], opts)
  end

  @spec _output_type(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _output_type(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_output_type)
  end
end
