# Generated by SnakeBridge v0.13.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.streaming.streaming_listener
# Python class: StreamListener

defmodule Dspy.Streaming.StreamingListener.StreamListener do
  @moduledoc """
  Class that listens to the stream to capture the streeaming of a specific output field of a predictor.
  """
  def __snakebridge_python_name__, do: "dspy.streaming.streaming_listener"
  def __snakebridge_python_class__, do: "StreamListener"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Args:

  signature_field_name: The name of the field to listen to.
      predict: The predictor to listen to. If None, when calling `streamify()` it will automatically look for
          the predictor that has the `signature_field_name` in its signature.
      predict_name: The name of the predictor to listen to. If None, when calling `streamify()` it will
          automatically look for the predictor that has the `signature_field_name` in its signature.
      allow_reuse: If True, the stream listener can be reused for multiple streams. Please note that this could
          hurt the performance because the same stream chunk is sent to multiple listeners.

  ## Parameters

  - `signature_field_name` (String.t())
  - `predict` (term() default: None)
  - `predict_name` (term() default: None)
  - `allow_reuse` (boolean() default: False)
  """
  @spec new(String.t(), list(term()), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(signature_field_name, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_class(
      __MODULE__,
      :__init__,
      [signature_field_name] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Python method `StreamListener._buffered_message_end_with_start_identifier`.

  ## Parameters

  - `concat_message` (String.t())
  - `start_identifier` (String.t())

  ## Returns

  - `String.t()`
  """
  @spec _buffered_message_end_with_start_identifier(
          SnakeBridge.Ref.t(),
          String.t(),
          String.t(),
          keyword()
        ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def _buffered_message_end_with_start_identifier(
        ref,
        concat_message,
        start_identifier,
        opts \\ []
      ) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_buffered_message_end_with_start_identifier,
      [concat_message, start_identifier],
      opts
    )
  end

  @doc """
  Check if the buffered message could potentially form the end identifier.

  This prevents unnecessary buffering when the tokens clearly cannot form the end pattern.
  For example, if buffered message is "hello world" and end pattern is "[[ ## ... ## ]]",
  we know it cannot form the pattern, so we should yield immediately.

  ## Parameters

  - `concat_message` - The concatenated buffered message
  - `adapter_name` - The name of the adapter being used

  ## Returns

  - `boolean()`
  """
  @spec _could_form_end_identifier(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def _could_form_end_identifier(ref, concat_message, adapter_name, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_could_form_end_identifier,
      [concat_message, adapter_name],
      opts
    )
  end

  @doc """
  Python method `StreamListener._default_handle_stream_chunk`.

  ## Parameters

  - `token` (String.t())
  - `end_identifier` (String.t())

  ## Returns

  - `term()`
  """
  @spec _default_handle_stream_chunk(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _default_handle_stream_chunk(ref, token, end_identifier, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_default_handle_stream_chunk,
      [token, end_identifier],
      opts
    )
  end

  @doc """
  Python method `StreamListener._json_adapter_handle_stream_chunk`.

  ## Parameters

  - `token` (String.t())
  - `chunk_message` (String.t())

  ## Returns

  - `term()`
  """
  @spec _json_adapter_handle_stream_chunk(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _json_adapter_handle_stream_chunk(ref, token, chunk_message, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_json_adapter_handle_stream_chunk,
      [token, chunk_message],
      opts
    )
  end

  @doc """
  Finalize the stream and flush any remaining buffered tokens.

  This should be called when the stream ends.
  It ensures no tokens are lost from the buffer and marks the final chunk appropriately.

  ## Returns

  - `term()`
  """
  @spec finalize(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def finalize(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :finalize, [], opts)
  end

  @doc """
  Flush all tokens in the field end queue.

  This method is called to flush out the last a few tokens when the stream is ended. These tokens
  are in the buffer because we don't directly yield the tokens received by the stream listener
  with the purpose to not yield the end_identifier tokens, e.g., "[[ ## ... ## ]]" for ChatAdapter.

  ## Returns

  - `String.t()`
  """
  @spec flush(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def flush(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :flush, [], opts)
  end

  @doc """
  Python method `StreamListener.receive`.

  ## Parameters

  - `chunk` (term())

  ## Returns

  - `term()`
  """
  @spec py_receive(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def py_receive(ref, chunk, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "receive", [chunk], opts)
  end

  @spec _output_type(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _output_type(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_output_type)
  end
end
