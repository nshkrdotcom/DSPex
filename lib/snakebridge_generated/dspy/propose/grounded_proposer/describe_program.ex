# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.propose.grounded_proposer
# Python class: DescribeProgram

defmodule Dspy.Propose.GroundedProposer.DescribeProgram do
  def __snakebridge_python_name__, do: "dspy.propose.grounded_proposer"
  def __snakebridge_python_class__, do: "DescribeProgram"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @spec new(keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [], opts)
  end

  @spec model_validate_json(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_validate_json(ref, json_data, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_validate_json, [json_data], opts)
  end

  @spec parse_raw(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def parse_raw(ref, b, content_type, encoding, proto, allow_pickle, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :parse_raw,
      [b, content_type, encoding, proto, allow_pickle],
      opts
    )
  end

  @spec model_dump(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def model_dump(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_dump, [], opts)
  end

  @spec parse_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def parse_obj(ref, obj, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :parse_obj, [obj], opts)
  end

  @spec _get_value(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _get_value(ref, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_value, [args, kwargs], opts)
  end

  @spec dict(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def dict(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :dict, [], opts)
  end

  @spec model_construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_construct(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :model_construct, [] ++ List.wrap(args), opts)
  end

  @spec _calculate_keys(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _calculate_keys(ref, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_calculate_keys, [args, kwargs], opts)
  end

  @spec dump_state(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dump_state(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :dump_state, [], opts)
  end

  @spec schema_json(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def schema_json(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :schema_json, [], opts)
  end

  @spec copy(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def copy(ref, include, exclude, update, deep, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :copy, [include, exclude, update, deep], opts)
  end

  @spec model_validate_strings(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_validate_strings(ref, obj, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_validate_strings, [obj], opts)
  end

  @spec model_rebuild(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_rebuild(ref, force, raise_errors, parent_namespace_depth, types_namespace, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :model_rebuild,
      [force, raise_errors, parent_namespace_depth, types_namespace],
      opts
    )
  end

  @spec with_instructions(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def with_instructions(ref, instructions, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :with_instructions, [instructions], opts)
  end

  @spec _iter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _iter(ref, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_iter, [args, kwargs], opts)
  end

  @spec delete(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def delete(ref, name, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :delete, [name], opts)
  end

  @spec load_state(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def load_state(ref, state, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :load_state, [state], opts)
  end

  @spec prepend(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def prepend(ref, name, field, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :prepend, [name, field] ++ List.wrap(args), opts)
  end

  @spec model_validate(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_validate(ref, obj, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_validate, [obj], opts)
  end

  @spec model_dump_json(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def model_dump_json(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_dump_json, [], opts)
  end

  @spec construct(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def construct(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :construct, [] ++ List.wrap(args), opts)
  end

  @spec from_orm(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def from_orm(ref, obj, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :from_orm, [obj], opts)
  end

  @spec _copy_and_set_values(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _copy_and_set_values(ref, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_copy_and_set_values, [args, kwargs], opts)
  end

  @spec with_updated_fields(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def with_updated_fields(ref, name, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :with_updated_fields, [name] ++ List.wrap(args), opts)
  end

  @spec model_post_init(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def model_post_init(ref, context, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_post_init, [context], opts)
  end

  @spec append(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def append(ref, name, field, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :append, [name, field] ++ List.wrap(args), opts)
  end

  @spec model_parametrized_name(SnakeBridge.Ref.t(), {term(), term()}, keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def model_parametrized_name(ref, params, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_parametrized_name, [params], opts)
  end

  @spec json(SnakeBridge.Ref.t(), keyword()) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def json(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :json, [], opts)
  end

  @spec model_json_schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def model_json_schema(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :model_json_schema, [] ++ List.wrap(args), opts)
  end

  @spec model_copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_copy(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :model_copy, [], opts)
  end

  @spec validate(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def validate(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :validate, [value], opts)
  end

  @spec equals(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def equals(ref, other, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :equals, [other], opts)
  end

  @spec schema(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def schema(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :schema, [] ++ List.wrap(args), opts)
  end

  @spec insert(SnakeBridge.Ref.t(), integer(), String.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def insert(ref, index, name, field, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :insert, [index, name, field] ++ List.wrap(args), opts)
  end

  @spec _setattr_handler(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
          {:ok, term() | nil} | {:error, Snakepit.Error.t()}
  def _setattr_handler(ref, name, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_setattr_handler, [name, value], opts)
  end

  @spec update_forward_refs(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def update_forward_refs(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :update_forward_refs, [], opts)
  end

  @spec parse_file(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def parse_file(ref, path, content_type, encoding, proto, allow_pickle, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :parse_file,
      [path, content_type, encoding, proto, allow_pickle],
      opts
    )
  end

  @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _abc_impl(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
  end

  @spec model_computed_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_computed_fields(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_computed_fields)
  end

  @spec model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_config(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_config)
  end

  @spec model_extra(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_extra(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_extra)
  end

  @spec model_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_fields(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_fields)
  end

  @spec model_fields_set(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_fields_set(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_fields_set)
  end
end
