# Generated by SnakeBridge v0.13.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy.propose
# Python class: GroundedProposer

defmodule Dspy.Propose.GroundedProposerClass3 do
  @moduledoc """
  Helper class that provides a standard way to create an ABC using

  inheritance.
  """
  def __snakebridge_python_name__, do: "dspy.propose"
  def __snakebridge_python_class__, do: "GroundedProposer"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `prompt_model` (term())
  - `program` (term())
  - `trainset` (term())
  - `view_data_batch_size` (term() default: 10)
  - `use_dataset_summary` (term() default: True)
  - `program_aware` (term() default: True)
  - `use_task_demos` (term() default: True)
  - `num_demos_in_context` (term() default: 3)
  - `use_instruct_history` (term() default: True)
  - `use_tip` (term() default: True)
  - `set_tip_randomly` (term() default: True)
  - `set_history_randomly` (term() default: True)
  - `verbose` (term() default: False)
  - `rng` (term() default: None)
  - `init_temperature` (float() default: 1.0)
  """
  @spec new(term(), term(), term(), list(term()), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(prompt_model, program, trainset, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_class(
      __MODULE__,
      :__init__,
      [prompt_model, program, trainset] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  This method is responsible for returning a single instruction for a given predictor, using the specified criteria.

  ## Parameters

  - `program` (term())
  - `predictor` (term())
  - `pred_i` (term())
  - `demo_candidates` (term())
  - `demo_set_i` (term())
  - `trial_logs` (term())
  - `tip` (term() default: None)

  ## Returns

  - `String.t()`
  """
  @spec propose_instruction_for_predictor(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          list(term()),
          keyword()
        ) :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def propose_instruction_for_predictor(
        ref,
        program,
        predictor,
        pred_i,
        demo_candidates,
        demo_set_i,
        trial_logs,
        args,
        opts \\ []
      ) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :propose_instruction_for_predictor,
      [program, predictor, pred_i, demo_candidates, demo_set_i, trial_logs] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  This method is responsible for returning the full set of new instructions for our program, given the specified criteria.

  ## Parameters

  - `trainset` (term())
  - `program` (term())
  - `demo_candidates` (term())
  - `trial_logs` (term())
  - `n` (term())

  ## Returns

  - `list(String.t())`
  """
  @spec propose_instructions_for_program(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, list(String.t())} | {:error, Snakepit.Error.t()}
  def propose_instructions_for_program(
        ref,
        trainset,
        program,
        demo_candidates,
        trial_logs,
        n,
        opts \\ []
      ) do
    SnakeBridge.Runtime.call_method(
      ref,
      :propose_instructions_for_program,
      [trainset, program, demo_candidates, trial_logs, n],
      opts
    )
  end

  @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _abc_impl(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
  end
end
