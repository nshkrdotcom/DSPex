# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: dspy 3.1.2
# Python module: dspy
# Python class: SignatureMeta

defmodule Dspy.SignatureMeta do
  @moduledoc """
  Metaclass for defining Abstract Base Classes (ABCs).

  Use this metaclass to create an ABC.  An ABC can be subclassed
  directly, and then acts as a mix-in class.  You can also register
  unrelated concrete classes (even built-in classes) and unrelated
  ABCs as 'virtual subclasses' -- these and their descendants will
  be considered subclasses of the registering ABC by the built-in
  issubclass() function, but the registering ABC won't show up in
  their MRO (Method Resolution Order) nor will method
  implementations defined by the registering ABC be callable (not
  even via super()).
  """
  def __snakebridge_python_name__, do: "dspy"
  def __snakebridge_python_class__, do: "SignatureMeta"
  def __snakebridge_library__, do: "dspy"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  Clear the caches (for debugging or testing).

  ## Returns

  - `term()`
  """
  @spec _abc_caches_clear(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _abc_caches_clear(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_abc_caches_clear, [], opts)
  end

  @doc """
  Clear the registry (for debugging or testing).

  ## Returns

  - `term()`
  """
  @spec _abc_registry_clear(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _abc_registry_clear(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_abc_registry_clear, [], opts)
  end

  @doc """
  Python method `SignatureMeta._collect_bases_data`.

  ## Parameters

  - `bases` (term())

  ## Returns

  - `term()`
  """
  @spec _collect_bases_data(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _collect_bases_data(ref, bases, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_collect_bases_data, [bases], opts)
  end

  @doc """
  Detect custom types from the caller's frame based on the signature string.

  Note: This method relies on Python's frame introspection which has some limitations:
  1. May not work in all Python implementations (e.g., compiled with optimizations)
  2. Looks up a limited number of frames in the call stack
  3. Cannot find types that are imported but not in the caller's namespace

  For more reliable custom type resolution, explicitly provide types using the
  `custom_types` parameter when creating a Signature.

  ## Parameters

  - `signature_str` (term())

  ## Returns

  - `term()`
  """
  @spec _detect_custom_types_from_caller(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _detect_custom_types_from_caller(ref, signature_str, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_detect_custom_types_from_caller, [signature_str], opts)
  end

  @doc """
  Debug helper to print the ABC registry.

  ## Parameters

  - `file` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec _dump_registry(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _dump_registry(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :_dump_registry, [] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `SignatureMeta._get_fields_with_type`.

  ## Parameters

  - `field_type` (term())

  ## Returns

  - `%{optional(String.t()) => term()}`
  """
  @spec _get_fields_with_type(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def _get_fields_with_type(ref, field_type, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_fields_with_type, [field_type], opts)
  end

  @doc """
  Python method `SignatureMeta._validate_fields`.

  ## Returns

  - `term()`
  """
  @spec _validate_fields(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _validate_fields(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_validate_fields, [], opts)
  end

  @doc """
  Return a type's method resolution order.

  ## Returns

  - `term()`
  """
  @spec mro(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def mro(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :mro, [], opts)
  end

  @doc """
  Register a virtual subclass of an ABC.

  Returns the subclass, to allow usage as a class decorator.

  ## Parameters

  - `subclass` (term())

  ## Returns

  - `term()`
  """
  @spec register(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def register(ref, subclass, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :register, [subclass], opts)
  end

  @spec fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def fields(ref) do
    SnakeBridge.Runtime.get_attr(ref, :fields)
  end

  @spec input_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def input_fields(ref) do
    SnakeBridge.Runtime.get_attr(ref, :input_fields)
  end

  @spec instructions(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def instructions(ref) do
    SnakeBridge.Runtime.get_attr(ref, :instructions)
  end

  @spec output_fields(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def output_fields(ref) do
    SnakeBridge.Runtime.get_attr(ref, :output_fields)
  end

  @spec signature(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def signature(ref) do
    SnakeBridge.Runtime.get_attr(ref, :signature)
  end
end
