# Detailed In-Place Implementation Plan

## Overview

This document outlines the definitive, step-by-step plan to refactor the existing system into the **Light Snakepit + Heavy Bridge** architecture. This plan prioritizes a clean separation of concerns by purifying the infrastructure layer *before* building the platform layer on top of it.

**Strategy**: Purify the existing `snakepit` infrastructure first, then build the ML platform (`snakepit_grpc_bridge`) on top of that proven, generic foundation.

**Required Reading**: Before beginning, ensure you are familiar with the high-level architecture defined in `01_...` through `06_...`. This plan is the "how" that implements the "what" described in those documents.

---

## Phase 1: Purify Snakepit & Bootstrap Bridge (Week 1)

The goal of this phase is to transform `snakepit` into a pure, domain-agnostic infrastructure library and set up the new `snakepit_grpc_bridge` application to house all ML-specific logic.

### Day 1: Audit Snakepit Domain Logic
**Objective:** Identify all ML/DSPy/gRPC domain logic currently residing within the `snakepit` application.

*   **Action:** Systematically audit all Elixir and Python files in the `snakepit` project.
*   **Action:** Create a manifest (`purification_manifest.md`) listing every file and code block that contains domain-specific logic (e.g., mentions of "dspy", "variable", "tool", hardcoded Python paths, gRPC specifics). This is your "kill list".

### Day 2: Execute Snakepit Purification
**Objective:** Execute the removal of all domain logic from `snakepit`, leaving only pure, generic infrastructure.

*   **Action:** In a new Git branch, delete or move all files and code blocks identified in the Day 1 audit.
*   **Action:** Remove all gRPC-related modules and dependencies from `snakepit/mix.exs`. The choice of communication protocol belongs to the adapter's implementation in the platform layer.
*   **Action:** Ensure the `Snakepit.Adapter` behavior is now the ONLY public contract between the `snakepit` core and the outside world.

### Day 3: Prove Snakepit Generality
**Objective:** Confirm `snakepit` is completely domain-agnostic and fully functional.

*   **Action:** Create a `test/support/mock_adapter.ex` that implements the `Snakepit.Adapter` behavior with simple, in-memory logic (e.g., a GenServer that echoes commands).
*   **Action:** Create a new test suite, `test/infrastructure_purity_test.exs`, that configures `snakepit` to use this `MockAdapter`.
*   **Validation:** All tests in this new suite must pass, proving that the pool, worker supervision, and session management work correctly without any ML or Python logic. **This is a critical quality gate.**

### Day 4-5: Bootstrap SnakepitGRPCBridge Package
**Objective:** Create the new `snakepit_grpc_bridge` package and move the previously extracted domain logic into it.

*   **Action:** Create the new Mix project for `snakepit_grpc_bridge` following the structure in `prompts/01_bootstrap_snakepit_grpc_bridge.md`.
*   **Action:** Move all the Python code and any relevant Elixir logic from your "kill list" into the new package structure.
*   **Action:** Set up the basic OTP application, adapter stub, and placeholder APIs as detailed in the bootstrap prompt.

---

## Phase 2: Build the ML Platform (Weeks 2-3)

The goal of this phase is to build the core functionality of the ML platform *inside* the new `snakepit_grpc_bridge` application, leveraging the now-pure `snakepit` infrastructure.

### Day 6-8: Implement Python Bridge and Adapter
**Objective:** Implement the core communication layer that connects the generic `snakepit` infrastructure to the Python runtime.

*   **Action:** Follow the detailed instructions in `prompts/05_implement_python_bridge_CORRECTED.md`.
    *   Implement `SnakepitGRPCBridge.Python.Process` to manage the `Port`.
    *   Implement the `SnakepitGRPCBridge.Adapter` callbacks to correctly start and communicate with the `Python.Process` worker.
    *   Implement the Python-side `worker.py` script.
*   **Validation:** A call to `Snakepit.execute` now successfully routes through your adapter to the Python process and back.

### Day 9-11: Implement the Variables System
**Objective:** Build the complete, session-aware variable management system.

*   **Action:** Follow the detailed instructions in `prompts/02_implement_variables_system.md`.
*   **Validation:** The `Variables.Manager` is fully functional, and all unit tests pass. Calls to `Snakepit.execute` with variable commands (e.g., "create_variable") work end-to-end.

### Day 12-14: Implement the Tools System
**Objective:** Build the bidirectional tool registry and execution system.

*   **Action:** Follow the detailed instructions in `prompts/03_implement_tools_system.md`.
*   **Validation:** Both Elixir and Python functions can be registered as tools and called from the other language.

### Day 15: Implement the DSPy System
**Objective:** Build the high-level DSPy integration layer.

*   **Action:** Follow the detailed instructions in `prompts/04_implement_dspy_system.md`.
*   **Validation:** High-level DSPy operations like `enhanced_predict` work correctly, leveraging the underlying variable and tool systems.

---

## Phase 3: Simplify DSPex Consumer Layer (Week 4)

### Day 16-18: Refactor DSPex
**Objective:** Transform `DSPex` into a pure orchestration layer.

*   **Action:** Update `dspex/mix.exs` to depend on `snakepit_grpc_bridge`.
*   **Action:** Remove all implementation logic (variables, tools, python bridge) from `dspex`.
*   **Action:** Rewrite the `DSPex` main module and the `defdsyp` macro to be thin wrappers that call the clean APIs provided by `SnakepitGRPCBridge.API.*`.

---

## Phase 4: Integration, Testing, and Release (Week 5)

### Day 19-22: Full-Stack Integration Testing
**Objective:** Ensure the complete three-layer system works flawlessly together.

*   **Action:** Create a comprehensive integration test suite that exercises user stories starting from `DSPex` down through the entire stack.
*   **Action:** Perform performance and benchmark testing to identify any regressions.
*   **Action:** Address bugs and polish the APIs based on testing feedback.

### Day 23-25: Documentation and Release
**Objective:** Update all documentation and prepare for release.

*   **Action:** Update all `README.md` files and module documentation to reflect the new architecture.
*   **Action:** Create a migration guide for existing users.
*   **Action:** Prepare and publish the packages in the correct dependency order: `snakepit`, then `snakepit_grpc_bridge`, then `dspex`.
